
build/Menelaus.elf:     file format elf32-littlearm


Disassembly of section .text:

00000410 <Reset_Handler>:
     410:	b672      	cpsid	i
     412:	4824      	ldr	r0, [pc, #144]	; (4a4 <endfiniloop+0x6>)
     414:	f380 8808 	msr	MSP, r0
     418:	4823      	ldr	r0, [pc, #140]	; (4a8 <endfiniloop+0xa>)
     41a:	f380 8809 	msr	PSP, r0
     41e:	2002      	movs	r0, #2
     420:	f380 8814 	msr	CONTROL, r0
     424:	f3bf 8f6f 	isb	sy
     428:	f000 fcfa 	bl	e20 <__core_init>
     42c:	f003 f858 	bl	34e0 <__early_init>
     430:	481e      	ldr	r0, [pc, #120]	; (4ac <endfiniloop+0xe>)
     432:	491f      	ldr	r1, [pc, #124]	; (4b0 <endfiniloop+0x12>)
     434:	4a1b      	ldr	r2, [pc, #108]	; (4a4 <endfiniloop+0x6>)

00000436 <msloop>:
     436:	4291      	cmp	r1, r2
     438:	da02      	bge.n	440 <endmsloop>
     43a:	6008      	str	r0, [r1, #0]
     43c:	3104      	adds	r1, #4
     43e:	e7fa      	b.n	436 <msloop>

00000440 <endmsloop>:
     440:	491c      	ldr	r1, [pc, #112]	; (4b4 <endfiniloop+0x16>)
     442:	4a19      	ldr	r2, [pc, #100]	; (4a8 <endfiniloop+0xa>)

00000444 <psloop>:
     444:	4291      	cmp	r1, r2
     446:	da02      	bge.n	44e <endpsloop>
     448:	6008      	str	r0, [r1, #0]
     44a:	3104      	adds	r1, #4
     44c:	e7fa      	b.n	444 <psloop>

0000044e <endpsloop>:
     44e:	491a      	ldr	r1, [pc, #104]	; (4b8 <endfiniloop+0x1a>)
     450:	4a1a      	ldr	r2, [pc, #104]	; (4bc <endfiniloop+0x1e>)
     452:	4b1b      	ldr	r3, [pc, #108]	; (4c0 <endfiniloop+0x22>)

00000454 <dloop>:
     454:	429a      	cmp	r2, r3
     456:	da04      	bge.n	462 <enddloop>
     458:	6808      	ldr	r0, [r1, #0]
     45a:	6010      	str	r0, [r2, #0]
     45c:	3104      	adds	r1, #4
     45e:	3204      	adds	r2, #4
     460:	e7f8      	b.n	454 <dloop>

00000462 <enddloop>:
     462:	2000      	movs	r0, #0
     464:	4917      	ldr	r1, [pc, #92]	; (4c4 <endfiniloop+0x26>)
     466:	4a18      	ldr	r2, [pc, #96]	; (4c8 <endfiniloop+0x2a>)

00000468 <bloop>:
     468:	4291      	cmp	r1, r2
     46a:	da02      	bge.n	472 <endbloop>
     46c:	6008      	str	r0, [r1, #0]
     46e:	3104      	adds	r1, #4
     470:	e7fa      	b.n	468 <bloop>

00000472 <endbloop>:
     472:	f000 fced 	bl	e50 <__init_ram_areas>
     476:	f000 fcdb 	bl	e30 <__late_init>
     47a:	4c14      	ldr	r4, [pc, #80]	; (4cc <endfiniloop+0x2e>)
     47c:	4d14      	ldr	r5, [pc, #80]	; (4d0 <endfiniloop+0x32>)

0000047e <initloop>:
     47e:	42ac      	cmp	r4, r5
     480:	da03      	bge.n	48a <endinitloop>
     482:	6821      	ldr	r1, [r4, #0]
     484:	4788      	blx	r1
     486:	3404      	adds	r4, #4
     488:	e7f9      	b.n	47e <initloop>

0000048a <endinitloop>:
     48a:	f003 fd01 	bl	3e90 <main>
     48e:	4c11      	ldr	r4, [pc, #68]	; (4d4 <endfiniloop+0x36>)
     490:	4d11      	ldr	r5, [pc, #68]	; (4d8 <endfiniloop+0x3a>)

00000492 <finiloop>:
     492:	42ac      	cmp	r4, r5
     494:	da03      	bge.n	49e <endfiniloop>
     496:	6821      	ldr	r1, [r4, #0]
     498:	4788      	blx	r1
     49a:	3404      	adds	r4, #4
     49c:	e7f9      	b.n	492 <finiloop>

0000049e <endfiniloop>:
     49e:	490f      	ldr	r1, [pc, #60]	; (4dc <endfiniloop+0x3e>)
     4a0:	4708      	bx	r1
     4a2:	0000      	.short	0x0000
     4a4:	1ffffc00 	.word	0x1ffffc00
     4a8:	1ffffe00 	.word	0x1ffffe00
     4ac:	55555555 	.word	0x55555555
     4b0:	1ffff800 	.word	0x1ffff800
     4b4:	1ffffc00 	.word	0x1ffffc00
     4b8:	000093b8 	.word	0x000093b8
     4bc:	1ffffe00 	.word	0x1ffffe00
     4c0:	1ffffe40 	.word	0x1ffffe40
     4c4:	20000000 	.word	0x20000000
     4c8:	20000ce0 	.word	0x20000ce0
     4cc:	00000410 	.word	0x00000410
     4d0:	00000410 	.word	0x00000410
     4d4:	00000410 	.word	0x00000410
     4d8:	00000410 	.word	0x00000410
     4dc:	00000e41 	.word	0x00000e41

000004e0 <_port_switch>:
     4e0:	b5f0      	push	{r4, r5, r6, r7, lr}
     4e2:	4644      	mov	r4, r8
     4e4:	464d      	mov	r5, r9
     4e6:	4656      	mov	r6, sl
     4e8:	465f      	mov	r7, fp
     4ea:	b4f0      	push	{r4, r5, r6, r7}
     4ec:	466b      	mov	r3, sp
     4ee:	60cb      	str	r3, [r1, #12]
     4f0:	68c3      	ldr	r3, [r0, #12]
     4f2:	469d      	mov	sp, r3
     4f4:	bcf0      	pop	{r4, r5, r6, r7}
     4f6:	46a0      	mov	r8, r4
     4f8:	46a9      	mov	r9, r5
     4fa:	46b2      	mov	sl, r6
     4fc:	46bb      	mov	fp, r7
     4fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000500 <_port_thread_start>:
     500:	f000 fd86 	bl	1010 <_dbg_check_unlock>
     504:	b662      	cpsie	i
     506:	1c28      	adds	r0, r5, #0
     508:	47a0      	blx	r4
     50a:	2000      	movs	r0, #0
     50c:	f001 f960 	bl	17d0 <chThdExit>

00000510 <_port_switch_from_isr>:
     510:	f000 fd66 	bl	fe0 <_dbg_check_lock>
     514:	f000 fffc 	bl	1510 <chSchDoReschedule>
     518:	f000 fd7a 	bl	1010 <_dbg_check_unlock>

0000051c <_port_exit_from_isr>:
     51c:	4a01      	ldr	r2, [pc, #4]	; (524 <_port_exit_from_isr+0x8>)
     51e:	4b02      	ldr	r3, [pc, #8]	; (528 <_port_exit_from_isr+0xc>)
     520:	6013      	str	r3, [r2, #0]
     522:	e7fe      	b.n	522 <_port_exit_from_isr+0x6>
     524:	e000ed04 	.word	0xe000ed04
     528:	80000000 	.word	0x80000000

0000052c <__udivsi3>:
     52c:	2200      	movs	r2, #0
     52e:	0843      	lsrs	r3, r0, #1
     530:	428b      	cmp	r3, r1
     532:	d374      	bcc.n	61e <__udivsi3+0xf2>
     534:	0903      	lsrs	r3, r0, #4
     536:	428b      	cmp	r3, r1
     538:	d35f      	bcc.n	5fa <__udivsi3+0xce>
     53a:	0a03      	lsrs	r3, r0, #8
     53c:	428b      	cmp	r3, r1
     53e:	d344      	bcc.n	5ca <__udivsi3+0x9e>
     540:	0b03      	lsrs	r3, r0, #12
     542:	428b      	cmp	r3, r1
     544:	d328      	bcc.n	598 <__udivsi3+0x6c>
     546:	0c03      	lsrs	r3, r0, #16
     548:	428b      	cmp	r3, r1
     54a:	d30d      	bcc.n	568 <__udivsi3+0x3c>
     54c:	22ff      	movs	r2, #255	; 0xff
     54e:	0209      	lsls	r1, r1, #8
     550:	ba12      	rev	r2, r2
     552:	0c03      	lsrs	r3, r0, #16
     554:	428b      	cmp	r3, r1
     556:	d302      	bcc.n	55e <__udivsi3+0x32>
     558:	1212      	asrs	r2, r2, #8
     55a:	0209      	lsls	r1, r1, #8
     55c:	d065      	beq.n	62a <__udivsi3+0xfe>
     55e:	0b03      	lsrs	r3, r0, #12
     560:	428b      	cmp	r3, r1
     562:	d319      	bcc.n	598 <__udivsi3+0x6c>
     564:	e000      	b.n	568 <__udivsi3+0x3c>
     566:	0a09      	lsrs	r1, r1, #8
     568:	0bc3      	lsrs	r3, r0, #15
     56a:	428b      	cmp	r3, r1
     56c:	d301      	bcc.n	572 <__udivsi3+0x46>
     56e:	03cb      	lsls	r3, r1, #15
     570:	1ac0      	subs	r0, r0, r3
     572:	4152      	adcs	r2, r2
     574:	0b83      	lsrs	r3, r0, #14
     576:	428b      	cmp	r3, r1
     578:	d301      	bcc.n	57e <__udivsi3+0x52>
     57a:	038b      	lsls	r3, r1, #14
     57c:	1ac0      	subs	r0, r0, r3
     57e:	4152      	adcs	r2, r2
     580:	0b43      	lsrs	r3, r0, #13
     582:	428b      	cmp	r3, r1
     584:	d301      	bcc.n	58a <__udivsi3+0x5e>
     586:	034b      	lsls	r3, r1, #13
     588:	1ac0      	subs	r0, r0, r3
     58a:	4152      	adcs	r2, r2
     58c:	0b03      	lsrs	r3, r0, #12
     58e:	428b      	cmp	r3, r1
     590:	d301      	bcc.n	596 <__udivsi3+0x6a>
     592:	030b      	lsls	r3, r1, #12
     594:	1ac0      	subs	r0, r0, r3
     596:	4152      	adcs	r2, r2
     598:	0ac3      	lsrs	r3, r0, #11
     59a:	428b      	cmp	r3, r1
     59c:	d301      	bcc.n	5a2 <__udivsi3+0x76>
     59e:	02cb      	lsls	r3, r1, #11
     5a0:	1ac0      	subs	r0, r0, r3
     5a2:	4152      	adcs	r2, r2
     5a4:	0a83      	lsrs	r3, r0, #10
     5a6:	428b      	cmp	r3, r1
     5a8:	d301      	bcc.n	5ae <__udivsi3+0x82>
     5aa:	028b      	lsls	r3, r1, #10
     5ac:	1ac0      	subs	r0, r0, r3
     5ae:	4152      	adcs	r2, r2
     5b0:	0a43      	lsrs	r3, r0, #9
     5b2:	428b      	cmp	r3, r1
     5b4:	d301      	bcc.n	5ba <__udivsi3+0x8e>
     5b6:	024b      	lsls	r3, r1, #9
     5b8:	1ac0      	subs	r0, r0, r3
     5ba:	4152      	adcs	r2, r2
     5bc:	0a03      	lsrs	r3, r0, #8
     5be:	428b      	cmp	r3, r1
     5c0:	d301      	bcc.n	5c6 <__udivsi3+0x9a>
     5c2:	020b      	lsls	r3, r1, #8
     5c4:	1ac0      	subs	r0, r0, r3
     5c6:	4152      	adcs	r2, r2
     5c8:	d2cd      	bcs.n	566 <__udivsi3+0x3a>
     5ca:	09c3      	lsrs	r3, r0, #7
     5cc:	428b      	cmp	r3, r1
     5ce:	d301      	bcc.n	5d4 <__udivsi3+0xa8>
     5d0:	01cb      	lsls	r3, r1, #7
     5d2:	1ac0      	subs	r0, r0, r3
     5d4:	4152      	adcs	r2, r2
     5d6:	0983      	lsrs	r3, r0, #6
     5d8:	428b      	cmp	r3, r1
     5da:	d301      	bcc.n	5e0 <__udivsi3+0xb4>
     5dc:	018b      	lsls	r3, r1, #6
     5de:	1ac0      	subs	r0, r0, r3
     5e0:	4152      	adcs	r2, r2
     5e2:	0943      	lsrs	r3, r0, #5
     5e4:	428b      	cmp	r3, r1
     5e6:	d301      	bcc.n	5ec <__udivsi3+0xc0>
     5e8:	014b      	lsls	r3, r1, #5
     5ea:	1ac0      	subs	r0, r0, r3
     5ec:	4152      	adcs	r2, r2
     5ee:	0903      	lsrs	r3, r0, #4
     5f0:	428b      	cmp	r3, r1
     5f2:	d301      	bcc.n	5f8 <__udivsi3+0xcc>
     5f4:	010b      	lsls	r3, r1, #4
     5f6:	1ac0      	subs	r0, r0, r3
     5f8:	4152      	adcs	r2, r2
     5fa:	08c3      	lsrs	r3, r0, #3
     5fc:	428b      	cmp	r3, r1
     5fe:	d301      	bcc.n	604 <__udivsi3+0xd8>
     600:	00cb      	lsls	r3, r1, #3
     602:	1ac0      	subs	r0, r0, r3
     604:	4152      	adcs	r2, r2
     606:	0883      	lsrs	r3, r0, #2
     608:	428b      	cmp	r3, r1
     60a:	d301      	bcc.n	610 <__udivsi3+0xe4>
     60c:	008b      	lsls	r3, r1, #2
     60e:	1ac0      	subs	r0, r0, r3
     610:	4152      	adcs	r2, r2
     612:	0843      	lsrs	r3, r0, #1
     614:	428b      	cmp	r3, r1
     616:	d301      	bcc.n	61c <__udivsi3+0xf0>
     618:	004b      	lsls	r3, r1, #1
     61a:	1ac0      	subs	r0, r0, r3
     61c:	4152      	adcs	r2, r2
     61e:	1a41      	subs	r1, r0, r1
     620:	d200      	bcs.n	624 <__udivsi3+0xf8>
     622:	4601      	mov	r1, r0
     624:	4152      	adcs	r2, r2
     626:	4610      	mov	r0, r2
     628:	4770      	bx	lr
     62a:	e7ff      	b.n	62c <__udivsi3+0x100>
     62c:	b501      	push	{r0, lr}
     62e:	2000      	movs	r0, #0
     630:	f000 f8f0 	bl	814 <__aeabi_idiv0>
     634:	bd02      	pop	{r1, pc}
     636:	46c0      	nop			; (mov r8, r8)

00000638 <__aeabi_uidivmod>:
     638:	2900      	cmp	r1, #0
     63a:	d0f7      	beq.n	62c <__udivsi3+0x100>
     63c:	e776      	b.n	52c <__udivsi3>
     63e:	4770      	bx	lr

00000640 <__divsi3>:
     640:	4603      	mov	r3, r0
     642:	430b      	orrs	r3, r1
     644:	d47f      	bmi.n	746 <__divsi3+0x106>
     646:	2200      	movs	r2, #0
     648:	0843      	lsrs	r3, r0, #1
     64a:	428b      	cmp	r3, r1
     64c:	d374      	bcc.n	738 <__divsi3+0xf8>
     64e:	0903      	lsrs	r3, r0, #4
     650:	428b      	cmp	r3, r1
     652:	d35f      	bcc.n	714 <__divsi3+0xd4>
     654:	0a03      	lsrs	r3, r0, #8
     656:	428b      	cmp	r3, r1
     658:	d344      	bcc.n	6e4 <__divsi3+0xa4>
     65a:	0b03      	lsrs	r3, r0, #12
     65c:	428b      	cmp	r3, r1
     65e:	d328      	bcc.n	6b2 <__divsi3+0x72>
     660:	0c03      	lsrs	r3, r0, #16
     662:	428b      	cmp	r3, r1
     664:	d30d      	bcc.n	682 <__divsi3+0x42>
     666:	22ff      	movs	r2, #255	; 0xff
     668:	0209      	lsls	r1, r1, #8
     66a:	ba12      	rev	r2, r2
     66c:	0c03      	lsrs	r3, r0, #16
     66e:	428b      	cmp	r3, r1
     670:	d302      	bcc.n	678 <__divsi3+0x38>
     672:	1212      	asrs	r2, r2, #8
     674:	0209      	lsls	r1, r1, #8
     676:	d065      	beq.n	744 <__divsi3+0x104>
     678:	0b03      	lsrs	r3, r0, #12
     67a:	428b      	cmp	r3, r1
     67c:	d319      	bcc.n	6b2 <__divsi3+0x72>
     67e:	e000      	b.n	682 <__divsi3+0x42>
     680:	0a09      	lsrs	r1, r1, #8
     682:	0bc3      	lsrs	r3, r0, #15
     684:	428b      	cmp	r3, r1
     686:	d301      	bcc.n	68c <__divsi3+0x4c>
     688:	03cb      	lsls	r3, r1, #15
     68a:	1ac0      	subs	r0, r0, r3
     68c:	4152      	adcs	r2, r2
     68e:	0b83      	lsrs	r3, r0, #14
     690:	428b      	cmp	r3, r1
     692:	d301      	bcc.n	698 <__divsi3+0x58>
     694:	038b      	lsls	r3, r1, #14
     696:	1ac0      	subs	r0, r0, r3
     698:	4152      	adcs	r2, r2
     69a:	0b43      	lsrs	r3, r0, #13
     69c:	428b      	cmp	r3, r1
     69e:	d301      	bcc.n	6a4 <__divsi3+0x64>
     6a0:	034b      	lsls	r3, r1, #13
     6a2:	1ac0      	subs	r0, r0, r3
     6a4:	4152      	adcs	r2, r2
     6a6:	0b03      	lsrs	r3, r0, #12
     6a8:	428b      	cmp	r3, r1
     6aa:	d301      	bcc.n	6b0 <__divsi3+0x70>
     6ac:	030b      	lsls	r3, r1, #12
     6ae:	1ac0      	subs	r0, r0, r3
     6b0:	4152      	adcs	r2, r2
     6b2:	0ac3      	lsrs	r3, r0, #11
     6b4:	428b      	cmp	r3, r1
     6b6:	d301      	bcc.n	6bc <__divsi3+0x7c>
     6b8:	02cb      	lsls	r3, r1, #11
     6ba:	1ac0      	subs	r0, r0, r3
     6bc:	4152      	adcs	r2, r2
     6be:	0a83      	lsrs	r3, r0, #10
     6c0:	428b      	cmp	r3, r1
     6c2:	d301      	bcc.n	6c8 <__divsi3+0x88>
     6c4:	028b      	lsls	r3, r1, #10
     6c6:	1ac0      	subs	r0, r0, r3
     6c8:	4152      	adcs	r2, r2
     6ca:	0a43      	lsrs	r3, r0, #9
     6cc:	428b      	cmp	r3, r1
     6ce:	d301      	bcc.n	6d4 <__divsi3+0x94>
     6d0:	024b      	lsls	r3, r1, #9
     6d2:	1ac0      	subs	r0, r0, r3
     6d4:	4152      	adcs	r2, r2
     6d6:	0a03      	lsrs	r3, r0, #8
     6d8:	428b      	cmp	r3, r1
     6da:	d301      	bcc.n	6e0 <__divsi3+0xa0>
     6dc:	020b      	lsls	r3, r1, #8
     6de:	1ac0      	subs	r0, r0, r3
     6e0:	4152      	adcs	r2, r2
     6e2:	d2cd      	bcs.n	680 <__divsi3+0x40>
     6e4:	09c3      	lsrs	r3, r0, #7
     6e6:	428b      	cmp	r3, r1
     6e8:	d301      	bcc.n	6ee <__divsi3+0xae>
     6ea:	01cb      	lsls	r3, r1, #7
     6ec:	1ac0      	subs	r0, r0, r3
     6ee:	4152      	adcs	r2, r2
     6f0:	0983      	lsrs	r3, r0, #6
     6f2:	428b      	cmp	r3, r1
     6f4:	d301      	bcc.n	6fa <__divsi3+0xba>
     6f6:	018b      	lsls	r3, r1, #6
     6f8:	1ac0      	subs	r0, r0, r3
     6fa:	4152      	adcs	r2, r2
     6fc:	0943      	lsrs	r3, r0, #5
     6fe:	428b      	cmp	r3, r1
     700:	d301      	bcc.n	706 <__divsi3+0xc6>
     702:	014b      	lsls	r3, r1, #5
     704:	1ac0      	subs	r0, r0, r3
     706:	4152      	adcs	r2, r2
     708:	0903      	lsrs	r3, r0, #4
     70a:	428b      	cmp	r3, r1
     70c:	d301      	bcc.n	712 <__divsi3+0xd2>
     70e:	010b      	lsls	r3, r1, #4
     710:	1ac0      	subs	r0, r0, r3
     712:	4152      	adcs	r2, r2
     714:	08c3      	lsrs	r3, r0, #3
     716:	428b      	cmp	r3, r1
     718:	d301      	bcc.n	71e <__divsi3+0xde>
     71a:	00cb      	lsls	r3, r1, #3
     71c:	1ac0      	subs	r0, r0, r3
     71e:	4152      	adcs	r2, r2
     720:	0883      	lsrs	r3, r0, #2
     722:	428b      	cmp	r3, r1
     724:	d301      	bcc.n	72a <__divsi3+0xea>
     726:	008b      	lsls	r3, r1, #2
     728:	1ac0      	subs	r0, r0, r3
     72a:	4152      	adcs	r2, r2
     72c:	0843      	lsrs	r3, r0, #1
     72e:	428b      	cmp	r3, r1
     730:	d301      	bcc.n	736 <__divsi3+0xf6>
     732:	004b      	lsls	r3, r1, #1
     734:	1ac0      	subs	r0, r0, r3
     736:	4152      	adcs	r2, r2
     738:	1a41      	subs	r1, r0, r1
     73a:	d200      	bcs.n	73e <__divsi3+0xfe>
     73c:	4601      	mov	r1, r0
     73e:	4152      	adcs	r2, r2
     740:	4610      	mov	r0, r2
     742:	4770      	bx	lr
     744:	e05d      	b.n	802 <__eeprom_workarea_size__+0x2>
     746:	0fca      	lsrs	r2, r1, #31
     748:	d000      	beq.n	74c <__divsi3+0x10c>
     74a:	4249      	negs	r1, r1
     74c:	1003      	asrs	r3, r0, #32
     74e:	d300      	bcc.n	752 <__divsi3+0x112>
     750:	4240      	negs	r0, r0
     752:	4053      	eors	r3, r2
     754:	2200      	movs	r2, #0
     756:	469c      	mov	ip, r3
     758:	0903      	lsrs	r3, r0, #4
     75a:	428b      	cmp	r3, r1
     75c:	d32d      	bcc.n	7ba <__divsi3+0x17a>
     75e:	0a03      	lsrs	r3, r0, #8
     760:	428b      	cmp	r3, r1
     762:	d312      	bcc.n	78a <__divsi3+0x14a>
     764:	22fc      	movs	r2, #252	; 0xfc
     766:	0189      	lsls	r1, r1, #6
     768:	ba12      	rev	r2, r2
     76a:	0a03      	lsrs	r3, r0, #8
     76c:	428b      	cmp	r3, r1
     76e:	d30c      	bcc.n	78a <__divsi3+0x14a>
     770:	0189      	lsls	r1, r1, #6
     772:	1192      	asrs	r2, r2, #6
     774:	428b      	cmp	r3, r1
     776:	d308      	bcc.n	78a <__divsi3+0x14a>
     778:	0189      	lsls	r1, r1, #6
     77a:	1192      	asrs	r2, r2, #6
     77c:	428b      	cmp	r3, r1
     77e:	d304      	bcc.n	78a <__divsi3+0x14a>
     780:	0189      	lsls	r1, r1, #6
     782:	d03a      	beq.n	7fa <__divsi3+0x1ba>
     784:	1192      	asrs	r2, r2, #6
     786:	e000      	b.n	78a <__divsi3+0x14a>
     788:	0989      	lsrs	r1, r1, #6
     78a:	09c3      	lsrs	r3, r0, #7
     78c:	428b      	cmp	r3, r1
     78e:	d301      	bcc.n	794 <__divsi3+0x154>
     790:	01cb      	lsls	r3, r1, #7
     792:	1ac0      	subs	r0, r0, r3
     794:	4152      	adcs	r2, r2
     796:	0983      	lsrs	r3, r0, #6
     798:	428b      	cmp	r3, r1
     79a:	d301      	bcc.n	7a0 <__divsi3+0x160>
     79c:	018b      	lsls	r3, r1, #6
     79e:	1ac0      	subs	r0, r0, r3
     7a0:	4152      	adcs	r2, r2
     7a2:	0943      	lsrs	r3, r0, #5
     7a4:	428b      	cmp	r3, r1
     7a6:	d301      	bcc.n	7ac <__divsi3+0x16c>
     7a8:	014b      	lsls	r3, r1, #5
     7aa:	1ac0      	subs	r0, r0, r3
     7ac:	4152      	adcs	r2, r2
     7ae:	0903      	lsrs	r3, r0, #4
     7b0:	428b      	cmp	r3, r1
     7b2:	d301      	bcc.n	7b8 <__divsi3+0x178>
     7b4:	010b      	lsls	r3, r1, #4
     7b6:	1ac0      	subs	r0, r0, r3
     7b8:	4152      	adcs	r2, r2
     7ba:	08c3      	lsrs	r3, r0, #3
     7bc:	428b      	cmp	r3, r1
     7be:	d301      	bcc.n	7c4 <__divsi3+0x184>
     7c0:	00cb      	lsls	r3, r1, #3
     7c2:	1ac0      	subs	r0, r0, r3
     7c4:	4152      	adcs	r2, r2
     7c6:	0883      	lsrs	r3, r0, #2
     7c8:	428b      	cmp	r3, r1
     7ca:	d301      	bcc.n	7d0 <__divsi3+0x190>
     7cc:	008b      	lsls	r3, r1, #2
     7ce:	1ac0      	subs	r0, r0, r3
     7d0:	4152      	adcs	r2, r2
     7d2:	d2d9      	bcs.n	788 <__divsi3+0x148>
     7d4:	0843      	lsrs	r3, r0, #1
     7d6:	428b      	cmp	r3, r1
     7d8:	d301      	bcc.n	7de <__divsi3+0x19e>
     7da:	004b      	lsls	r3, r1, #1
     7dc:	1ac0      	subs	r0, r0, r3
     7de:	4152      	adcs	r2, r2
     7e0:	1a41      	subs	r1, r0, r1
     7e2:	d200      	bcs.n	7e6 <__divsi3+0x1a6>
     7e4:	4601      	mov	r1, r0
     7e6:	4663      	mov	r3, ip
     7e8:	4152      	adcs	r2, r2
     7ea:	105b      	asrs	r3, r3, #1
     7ec:	4610      	mov	r0, r2
     7ee:	d301      	bcc.n	7f4 <__divsi3+0x1b4>
     7f0:	4240      	negs	r0, r0
     7f2:	2b00      	cmp	r3, #0
     7f4:	d500      	bpl.n	7f8 <__divsi3+0x1b8>
     7f6:	4249      	negs	r1, r1
     7f8:	4770      	bx	lr
     7fa:	4663      	mov	r3, ip
     7fc:	105b      	asrs	r3, r3, #1
     7fe:	d300      	bcc.n	802 <__eeprom_workarea_size__+0x2>
     800:	4240      	negs	r0, r0
     802:	b501      	push	{r0, lr}
     804:	2000      	movs	r0, #0
     806:	f000 f805 	bl	814 <__aeabi_idiv0>
     80a:	bd02      	pop	{r1, pc}

0000080c <__aeabi_idivmod>:
     80c:	2900      	cmp	r1, #0
     80e:	d0f8      	beq.n	802 <__eeprom_workarea_size__+0x2>
     810:	e716      	b.n	640 <__divsi3>
     812:	4770      	bx	lr

00000814 <__aeabi_idiv0>:
     814:	4770      	bx	lr
     816:	46c0      	nop			; (mov r8, r8)

00000818 <__aeabi_dmul>:
     818:	b5f0      	push	{r4, r5, r6, r7, lr}
     81a:	4657      	mov	r7, sl
     81c:	46de      	mov	lr, fp
     81e:	464e      	mov	r6, r9
     820:	4645      	mov	r5, r8
     822:	b5e0      	push	{r5, r6, r7, lr}
     824:	4683      	mov	fp, r0
     826:	0006      	movs	r6, r0
     828:	030f      	lsls	r7, r1, #12
     82a:	0048      	lsls	r0, r1, #1
     82c:	b087      	sub	sp, #28
     82e:	4692      	mov	sl, r2
     830:	001d      	movs	r5, r3
     832:	0b3f      	lsrs	r7, r7, #12
     834:	0d40      	lsrs	r0, r0, #21
     836:	0fcc      	lsrs	r4, r1, #31
     838:	2800      	cmp	r0, #0
     83a:	d100      	bne.n	83e <__aeabi_dmul+0x26>
     83c:	e06f      	b.n	91e <__aeabi_dmul+0x106>
     83e:	4bde      	ldr	r3, [pc, #888]	; (bb8 <__aeabi_dmul+0x3a0>)
     840:	4298      	cmp	r0, r3
     842:	d038      	beq.n	8b6 <__aeabi_dmul+0x9e>
     844:	2380      	movs	r3, #128	; 0x80
     846:	00ff      	lsls	r7, r7, #3
     848:	041b      	lsls	r3, r3, #16
     84a:	431f      	orrs	r7, r3
     84c:	0f73      	lsrs	r3, r6, #29
     84e:	433b      	orrs	r3, r7
     850:	9301      	str	r3, [sp, #4]
     852:	4bda      	ldr	r3, [pc, #872]	; (bbc <__aeabi_dmul+0x3a4>)
     854:	2700      	movs	r7, #0
     856:	4699      	mov	r9, r3
     858:	2300      	movs	r3, #0
     85a:	469b      	mov	fp, r3
     85c:	00f6      	lsls	r6, r6, #3
     85e:	4481      	add	r9, r0
     860:	032b      	lsls	r3, r5, #12
     862:	0069      	lsls	r1, r5, #1
     864:	0b1b      	lsrs	r3, r3, #12
     866:	4652      	mov	r2, sl
     868:	4698      	mov	r8, r3
     86a:	0d49      	lsrs	r1, r1, #21
     86c:	0fed      	lsrs	r5, r5, #31
     86e:	2900      	cmp	r1, #0
     870:	d100      	bne.n	874 <__aeabi_dmul+0x5c>
     872:	e085      	b.n	980 <__aeabi_dmul+0x168>
     874:	4bd0      	ldr	r3, [pc, #832]	; (bb8 <__aeabi_dmul+0x3a0>)
     876:	4299      	cmp	r1, r3
     878:	d100      	bne.n	87c <__aeabi_dmul+0x64>
     87a:	e073      	b.n	964 <__aeabi_dmul+0x14c>
     87c:	4643      	mov	r3, r8
     87e:	00da      	lsls	r2, r3, #3
     880:	2380      	movs	r3, #128	; 0x80
     882:	041b      	lsls	r3, r3, #16
     884:	4313      	orrs	r3, r2
     886:	4652      	mov	r2, sl
     888:	48cc      	ldr	r0, [pc, #816]	; (bbc <__aeabi_dmul+0x3a4>)
     88a:	0f52      	lsrs	r2, r2, #29
     88c:	4684      	mov	ip, r0
     88e:	4313      	orrs	r3, r2
     890:	4652      	mov	r2, sl
     892:	2000      	movs	r0, #0
     894:	4461      	add	r1, ip
     896:	00d2      	lsls	r2, r2, #3
     898:	4489      	add	r9, r1
     89a:	0021      	movs	r1, r4
     89c:	4069      	eors	r1, r5
     89e:	9100      	str	r1, [sp, #0]
     8a0:	468c      	mov	ip, r1
     8a2:	2101      	movs	r1, #1
     8a4:	4449      	add	r1, r9
     8a6:	468a      	mov	sl, r1
     8a8:	2f0f      	cmp	r7, #15
     8aa:	d900      	bls.n	8ae <__aeabi_dmul+0x96>
     8ac:	e090      	b.n	9d0 <__aeabi_dmul+0x1b8>
     8ae:	49c4      	ldr	r1, [pc, #784]	; (bc0 <__aeabi_dmul+0x3a8>)
     8b0:	00bf      	lsls	r7, r7, #2
     8b2:	59cf      	ldr	r7, [r1, r7]
     8b4:	46bf      	mov	pc, r7
     8b6:	465b      	mov	r3, fp
     8b8:	433b      	orrs	r3, r7
     8ba:	9301      	str	r3, [sp, #4]
     8bc:	d000      	beq.n	8c0 <__aeabi_dmul+0xa8>
     8be:	e16a      	b.n	b96 <__aeabi_dmul+0x37e>
     8c0:	2302      	movs	r3, #2
     8c2:	2708      	movs	r7, #8
     8c4:	2600      	movs	r6, #0
     8c6:	4681      	mov	r9, r0
     8c8:	469b      	mov	fp, r3
     8ca:	e7c9      	b.n	860 <__aeabi_dmul+0x48>
     8cc:	0032      	movs	r2, r6
     8ce:	4658      	mov	r0, fp
     8d0:	9b01      	ldr	r3, [sp, #4]
     8d2:	4661      	mov	r1, ip
     8d4:	9100      	str	r1, [sp, #0]
     8d6:	2802      	cmp	r0, #2
     8d8:	d100      	bne.n	8dc <__aeabi_dmul+0xc4>
     8da:	e075      	b.n	9c8 <__aeabi_dmul+0x1b0>
     8dc:	2803      	cmp	r0, #3
     8de:	d100      	bne.n	8e2 <__aeabi_dmul+0xca>
     8e0:	e1fe      	b.n	ce0 <__aeabi_dmul+0x4c8>
     8e2:	2801      	cmp	r0, #1
     8e4:	d000      	beq.n	8e8 <__aeabi_dmul+0xd0>
     8e6:	e12c      	b.n	b42 <__aeabi_dmul+0x32a>
     8e8:	2300      	movs	r3, #0
     8ea:	2700      	movs	r7, #0
     8ec:	2600      	movs	r6, #0
     8ee:	2500      	movs	r5, #0
     8f0:	033f      	lsls	r7, r7, #12
     8f2:	0d2a      	lsrs	r2, r5, #20
     8f4:	0b3f      	lsrs	r7, r7, #12
     8f6:	48b3      	ldr	r0, [pc, #716]	; (bc4 <__aeabi_dmul+0x3ac>)
     8f8:	0512      	lsls	r2, r2, #20
     8fa:	433a      	orrs	r2, r7
     8fc:	4002      	ands	r2, r0
     8fe:	051b      	lsls	r3, r3, #20
     900:	4313      	orrs	r3, r2
     902:	9a00      	ldr	r2, [sp, #0]
     904:	005b      	lsls	r3, r3, #1
     906:	07d1      	lsls	r1, r2, #31
     908:	085b      	lsrs	r3, r3, #1
     90a:	430b      	orrs	r3, r1
     90c:	0030      	movs	r0, r6
     90e:	0019      	movs	r1, r3
     910:	b007      	add	sp, #28
     912:	bc3c      	pop	{r2, r3, r4, r5}
     914:	4690      	mov	r8, r2
     916:	4699      	mov	r9, r3
     918:	46a2      	mov	sl, r4
     91a:	46ab      	mov	fp, r5
     91c:	bdf0      	pop	{r4, r5, r6, r7, pc}
     91e:	465b      	mov	r3, fp
     920:	433b      	orrs	r3, r7
     922:	9301      	str	r3, [sp, #4]
     924:	d100      	bne.n	928 <__aeabi_dmul+0x110>
     926:	e12f      	b.n	b88 <__aeabi_dmul+0x370>
     928:	2f00      	cmp	r7, #0
     92a:	d100      	bne.n	92e <__aeabi_dmul+0x116>
     92c:	e1a5      	b.n	c7a <__aeabi_dmul+0x462>
     92e:	0038      	movs	r0, r7
     930:	f000 fa54 	bl	ddc <__clzsi2>
     934:	0003      	movs	r3, r0
     936:	3b0b      	subs	r3, #11
     938:	2b1c      	cmp	r3, #28
     93a:	dd00      	ble.n	93e <__aeabi_dmul+0x126>
     93c:	e196      	b.n	c6c <__aeabi_dmul+0x454>
     93e:	221d      	movs	r2, #29
     940:	1ad3      	subs	r3, r2, r3
     942:	465a      	mov	r2, fp
     944:	0001      	movs	r1, r0
     946:	40da      	lsrs	r2, r3
     948:	465e      	mov	r6, fp
     94a:	3908      	subs	r1, #8
     94c:	408f      	lsls	r7, r1
     94e:	0013      	movs	r3, r2
     950:	408e      	lsls	r6, r1
     952:	433b      	orrs	r3, r7
     954:	9301      	str	r3, [sp, #4]
     956:	4b9c      	ldr	r3, [pc, #624]	; (bc8 <__aeabi_dmul+0x3b0>)
     958:	2700      	movs	r7, #0
     95a:	1a1b      	subs	r3, r3, r0
     95c:	4699      	mov	r9, r3
     95e:	2300      	movs	r3, #0
     960:	469b      	mov	fp, r3
     962:	e77d      	b.n	860 <__aeabi_dmul+0x48>
     964:	4641      	mov	r1, r8
     966:	4653      	mov	r3, sl
     968:	430b      	orrs	r3, r1
     96a:	4993      	ldr	r1, [pc, #588]	; (bb8 <__aeabi_dmul+0x3a0>)
     96c:	468c      	mov	ip, r1
     96e:	44e1      	add	r9, ip
     970:	2b00      	cmp	r3, #0
     972:	d000      	beq.n	976 <__aeabi_dmul+0x15e>
     974:	e11a      	b.n	bac <__aeabi_dmul+0x394>
     976:	2202      	movs	r2, #2
     978:	2002      	movs	r0, #2
     97a:	4317      	orrs	r7, r2
     97c:	2200      	movs	r2, #0
     97e:	e78c      	b.n	89a <__aeabi_dmul+0x82>
     980:	4313      	orrs	r3, r2
     982:	d100      	bne.n	986 <__aeabi_dmul+0x16e>
     984:	e10d      	b.n	ba2 <__aeabi_dmul+0x38a>
     986:	4643      	mov	r3, r8
     988:	2b00      	cmp	r3, #0
     98a:	d100      	bne.n	98e <__aeabi_dmul+0x176>
     98c:	e181      	b.n	c92 <__aeabi_dmul+0x47a>
     98e:	4640      	mov	r0, r8
     990:	f000 fa24 	bl	ddc <__clzsi2>
     994:	0002      	movs	r2, r0
     996:	3a0b      	subs	r2, #11
     998:	2a1c      	cmp	r2, #28
     99a:	dd00      	ble.n	99e <__aeabi_dmul+0x186>
     99c:	e172      	b.n	c84 <__aeabi_dmul+0x46c>
     99e:	0001      	movs	r1, r0
     9a0:	4643      	mov	r3, r8
     9a2:	3908      	subs	r1, #8
     9a4:	408b      	lsls	r3, r1
     9a6:	4698      	mov	r8, r3
     9a8:	231d      	movs	r3, #29
     9aa:	1a9a      	subs	r2, r3, r2
     9ac:	4653      	mov	r3, sl
     9ae:	40d3      	lsrs	r3, r2
     9b0:	001a      	movs	r2, r3
     9b2:	4643      	mov	r3, r8
     9b4:	4313      	orrs	r3, r2
     9b6:	4652      	mov	r2, sl
     9b8:	408a      	lsls	r2, r1
     9ba:	4649      	mov	r1, r9
     9bc:	1a08      	subs	r0, r1, r0
     9be:	4982      	ldr	r1, [pc, #520]	; (bc8 <__aeabi_dmul+0x3b0>)
     9c0:	4689      	mov	r9, r1
     9c2:	4481      	add	r9, r0
     9c4:	2000      	movs	r0, #0
     9c6:	e768      	b.n	89a <__aeabi_dmul+0x82>
     9c8:	4b7b      	ldr	r3, [pc, #492]	; (bb8 <__aeabi_dmul+0x3a0>)
     9ca:	2700      	movs	r7, #0
     9cc:	2600      	movs	r6, #0
     9ce:	e78e      	b.n	8ee <__aeabi_dmul+0xd6>
     9d0:	0c14      	lsrs	r4, r2, #16
     9d2:	0412      	lsls	r2, r2, #16
     9d4:	0c12      	lsrs	r2, r2, #16
     9d6:	0011      	movs	r1, r2
     9d8:	0c37      	lsrs	r7, r6, #16
     9da:	0436      	lsls	r6, r6, #16
     9dc:	0c35      	lsrs	r5, r6, #16
     9de:	4379      	muls	r1, r7
     9e0:	0028      	movs	r0, r5
     9e2:	468c      	mov	ip, r1
     9e4:	002e      	movs	r6, r5
     9e6:	4360      	muls	r0, r4
     9e8:	4460      	add	r0, ip
     9ea:	4683      	mov	fp, r0
     9ec:	4356      	muls	r6, r2
     9ee:	0021      	movs	r1, r4
     9f0:	0c30      	lsrs	r0, r6, #16
     9f2:	4680      	mov	r8, r0
     9f4:	4658      	mov	r0, fp
     9f6:	4379      	muls	r1, r7
     9f8:	4440      	add	r0, r8
     9fa:	9102      	str	r1, [sp, #8]
     9fc:	4584      	cmp	ip, r0
     9fe:	d906      	bls.n	a0e <__aeabi_dmul+0x1f6>
     a00:	4688      	mov	r8, r1
     a02:	2180      	movs	r1, #128	; 0x80
     a04:	0249      	lsls	r1, r1, #9
     a06:	468c      	mov	ip, r1
     a08:	44e0      	add	r8, ip
     a0a:	4641      	mov	r1, r8
     a0c:	9102      	str	r1, [sp, #8]
     a0e:	0436      	lsls	r6, r6, #16
     a10:	0c01      	lsrs	r1, r0, #16
     a12:	0c36      	lsrs	r6, r6, #16
     a14:	0400      	lsls	r0, r0, #16
     a16:	468b      	mov	fp, r1
     a18:	1981      	adds	r1, r0, r6
     a1a:	0c1e      	lsrs	r6, r3, #16
     a1c:	041b      	lsls	r3, r3, #16
     a1e:	0c1b      	lsrs	r3, r3, #16
     a20:	9103      	str	r1, [sp, #12]
     a22:	0019      	movs	r1, r3
     a24:	4379      	muls	r1, r7
     a26:	468c      	mov	ip, r1
     a28:	0028      	movs	r0, r5
     a2a:	4375      	muls	r5, r6
     a2c:	4465      	add	r5, ip
     a2e:	46a8      	mov	r8, r5
     a30:	4358      	muls	r0, r3
     a32:	0c05      	lsrs	r5, r0, #16
     a34:	4445      	add	r5, r8
     a36:	4377      	muls	r7, r6
     a38:	42a9      	cmp	r1, r5
     a3a:	d903      	bls.n	a44 <__aeabi_dmul+0x22c>
     a3c:	2180      	movs	r1, #128	; 0x80
     a3e:	0249      	lsls	r1, r1, #9
     a40:	468c      	mov	ip, r1
     a42:	4467      	add	r7, ip
     a44:	0c29      	lsrs	r1, r5, #16
     a46:	468c      	mov	ip, r1
     a48:	0039      	movs	r1, r7
     a4a:	0400      	lsls	r0, r0, #16
     a4c:	0c00      	lsrs	r0, r0, #16
     a4e:	042d      	lsls	r5, r5, #16
     a50:	182d      	adds	r5, r5, r0
     a52:	4461      	add	r1, ip
     a54:	44ab      	add	fp, r5
     a56:	9105      	str	r1, [sp, #20]
     a58:	4659      	mov	r1, fp
     a5a:	9104      	str	r1, [sp, #16]
     a5c:	9901      	ldr	r1, [sp, #4]
     a5e:	040f      	lsls	r7, r1, #16
     a60:	0c3f      	lsrs	r7, r7, #16
     a62:	0c08      	lsrs	r0, r1, #16
     a64:	0039      	movs	r1, r7
     a66:	4351      	muls	r1, r2
     a68:	4342      	muls	r2, r0
     a6a:	4690      	mov	r8, r2
     a6c:	0002      	movs	r2, r0
     a6e:	468c      	mov	ip, r1
     a70:	0c09      	lsrs	r1, r1, #16
     a72:	468b      	mov	fp, r1
     a74:	4362      	muls	r2, r4
     a76:	437c      	muls	r4, r7
     a78:	4444      	add	r4, r8
     a7a:	445c      	add	r4, fp
     a7c:	45a0      	cmp	r8, r4
     a7e:	d903      	bls.n	a88 <__aeabi_dmul+0x270>
     a80:	2180      	movs	r1, #128	; 0x80
     a82:	0249      	lsls	r1, r1, #9
     a84:	4688      	mov	r8, r1
     a86:	4442      	add	r2, r8
     a88:	0c21      	lsrs	r1, r4, #16
     a8a:	4688      	mov	r8, r1
     a8c:	4661      	mov	r1, ip
     a8e:	0409      	lsls	r1, r1, #16
     a90:	0c09      	lsrs	r1, r1, #16
     a92:	468c      	mov	ip, r1
     a94:	0039      	movs	r1, r7
     a96:	4359      	muls	r1, r3
     a98:	4343      	muls	r3, r0
     a9a:	4370      	muls	r0, r6
     a9c:	437e      	muls	r6, r7
     a9e:	0c0f      	lsrs	r7, r1, #16
     aa0:	18f6      	adds	r6, r6, r3
     aa2:	0424      	lsls	r4, r4, #16
     aa4:	19be      	adds	r6, r7, r6
     aa6:	4464      	add	r4, ip
     aa8:	4442      	add	r2, r8
     aaa:	468c      	mov	ip, r1
     aac:	42b3      	cmp	r3, r6
     aae:	d903      	bls.n	ab8 <__aeabi_dmul+0x2a0>
     ab0:	2380      	movs	r3, #128	; 0x80
     ab2:	025b      	lsls	r3, r3, #9
     ab4:	4698      	mov	r8, r3
     ab6:	4440      	add	r0, r8
     ab8:	9b02      	ldr	r3, [sp, #8]
     aba:	4661      	mov	r1, ip
     abc:	4698      	mov	r8, r3
     abe:	9b04      	ldr	r3, [sp, #16]
     ac0:	0437      	lsls	r7, r6, #16
     ac2:	4443      	add	r3, r8
     ac4:	469b      	mov	fp, r3
     ac6:	45ab      	cmp	fp, r5
     ac8:	41ad      	sbcs	r5, r5
     aca:	426b      	negs	r3, r5
     acc:	040d      	lsls	r5, r1, #16
     ace:	9905      	ldr	r1, [sp, #20]
     ad0:	0c2d      	lsrs	r5, r5, #16
     ad2:	468c      	mov	ip, r1
     ad4:	197f      	adds	r7, r7, r5
     ad6:	4467      	add	r7, ip
     ad8:	18fd      	adds	r5, r7, r3
     ada:	46a8      	mov	r8, r5
     adc:	465d      	mov	r5, fp
     ade:	192d      	adds	r5, r5, r4
     ae0:	42a5      	cmp	r5, r4
     ae2:	41a4      	sbcs	r4, r4
     ae4:	4693      	mov	fp, r2
     ae6:	4264      	negs	r4, r4
     ae8:	46a4      	mov	ip, r4
     aea:	44c3      	add	fp, r8
     aec:	44dc      	add	ip, fp
     aee:	428f      	cmp	r7, r1
     af0:	41bf      	sbcs	r7, r7
     af2:	4598      	cmp	r8, r3
     af4:	419b      	sbcs	r3, r3
     af6:	4593      	cmp	fp, r2
     af8:	4192      	sbcs	r2, r2
     afa:	45a4      	cmp	ip, r4
     afc:	41a4      	sbcs	r4, r4
     afe:	425b      	negs	r3, r3
     b00:	427f      	negs	r7, r7
     b02:	431f      	orrs	r7, r3
     b04:	0c36      	lsrs	r6, r6, #16
     b06:	4252      	negs	r2, r2
     b08:	4264      	negs	r4, r4
     b0a:	19bf      	adds	r7, r7, r6
     b0c:	4322      	orrs	r2, r4
     b0e:	18bf      	adds	r7, r7, r2
     b10:	4662      	mov	r2, ip
     b12:	1838      	adds	r0, r7, r0
     b14:	0243      	lsls	r3, r0, #9
     b16:	0dd2      	lsrs	r2, r2, #23
     b18:	9903      	ldr	r1, [sp, #12]
     b1a:	4313      	orrs	r3, r2
     b1c:	026a      	lsls	r2, r5, #9
     b1e:	430a      	orrs	r2, r1
     b20:	1e50      	subs	r0, r2, #1
     b22:	4182      	sbcs	r2, r0
     b24:	4661      	mov	r1, ip
     b26:	0ded      	lsrs	r5, r5, #23
     b28:	432a      	orrs	r2, r5
     b2a:	024e      	lsls	r6, r1, #9
     b2c:	4332      	orrs	r2, r6
     b2e:	01d9      	lsls	r1, r3, #7
     b30:	d400      	bmi.n	b34 <__aeabi_dmul+0x31c>
     b32:	e0b3      	b.n	c9c <__aeabi_dmul+0x484>
     b34:	2601      	movs	r6, #1
     b36:	0850      	lsrs	r0, r2, #1
     b38:	4032      	ands	r2, r6
     b3a:	4302      	orrs	r2, r0
     b3c:	07de      	lsls	r6, r3, #31
     b3e:	4332      	orrs	r2, r6
     b40:	085b      	lsrs	r3, r3, #1
     b42:	4c22      	ldr	r4, [pc, #136]	; (bcc <__aeabi_dmul+0x3b4>)
     b44:	4454      	add	r4, sl
     b46:	2c00      	cmp	r4, #0
     b48:	dd62      	ble.n	c10 <__aeabi_dmul+0x3f8>
     b4a:	0751      	lsls	r1, r2, #29
     b4c:	d009      	beq.n	b62 <__aeabi_dmul+0x34a>
     b4e:	200f      	movs	r0, #15
     b50:	4010      	ands	r0, r2
     b52:	2804      	cmp	r0, #4
     b54:	d005      	beq.n	b62 <__aeabi_dmul+0x34a>
     b56:	1d10      	adds	r0, r2, #4
     b58:	4290      	cmp	r0, r2
     b5a:	4192      	sbcs	r2, r2
     b5c:	4252      	negs	r2, r2
     b5e:	189b      	adds	r3, r3, r2
     b60:	0002      	movs	r2, r0
     b62:	01d9      	lsls	r1, r3, #7
     b64:	d504      	bpl.n	b70 <__aeabi_dmul+0x358>
     b66:	2480      	movs	r4, #128	; 0x80
     b68:	4819      	ldr	r0, [pc, #100]	; (bd0 <__aeabi_dmul+0x3b8>)
     b6a:	00e4      	lsls	r4, r4, #3
     b6c:	4003      	ands	r3, r0
     b6e:	4454      	add	r4, sl
     b70:	4818      	ldr	r0, [pc, #96]	; (bd4 <__aeabi_dmul+0x3bc>)
     b72:	4284      	cmp	r4, r0
     b74:	dd00      	ble.n	b78 <__aeabi_dmul+0x360>
     b76:	e727      	b.n	9c8 <__aeabi_dmul+0x1b0>
     b78:	075e      	lsls	r6, r3, #29
     b7a:	025b      	lsls	r3, r3, #9
     b7c:	08d2      	lsrs	r2, r2, #3
     b7e:	0b1f      	lsrs	r7, r3, #12
     b80:	0563      	lsls	r3, r4, #21
     b82:	4316      	orrs	r6, r2
     b84:	0d5b      	lsrs	r3, r3, #21
     b86:	e6b2      	b.n	8ee <__aeabi_dmul+0xd6>
     b88:	2300      	movs	r3, #0
     b8a:	4699      	mov	r9, r3
     b8c:	3301      	adds	r3, #1
     b8e:	2704      	movs	r7, #4
     b90:	2600      	movs	r6, #0
     b92:	469b      	mov	fp, r3
     b94:	e664      	b.n	860 <__aeabi_dmul+0x48>
     b96:	2303      	movs	r3, #3
     b98:	9701      	str	r7, [sp, #4]
     b9a:	4681      	mov	r9, r0
     b9c:	270c      	movs	r7, #12
     b9e:	469b      	mov	fp, r3
     ba0:	e65e      	b.n	860 <__aeabi_dmul+0x48>
     ba2:	2201      	movs	r2, #1
     ba4:	2001      	movs	r0, #1
     ba6:	4317      	orrs	r7, r2
     ba8:	2200      	movs	r2, #0
     baa:	e676      	b.n	89a <__aeabi_dmul+0x82>
     bac:	2303      	movs	r3, #3
     bae:	2003      	movs	r0, #3
     bb0:	431f      	orrs	r7, r3
     bb2:	4643      	mov	r3, r8
     bb4:	e671      	b.n	89a <__aeabi_dmul+0x82>
     bb6:	46c0      	nop			; (mov r8, r8)
     bb8:	000007ff 	.word	0x000007ff
     bbc:	fffffc01 	.word	0xfffffc01
     bc0:	00007a34 	.word	0x00007a34
     bc4:	800fffff 	.word	0x800fffff
     bc8:	fffffc0d 	.word	0xfffffc0d
     bcc:	000003ff 	.word	0x000003ff
     bd0:	feffffff 	.word	0xfeffffff
     bd4:	000007fe 	.word	0x000007fe
     bd8:	2300      	movs	r3, #0
     bda:	2780      	movs	r7, #128	; 0x80
     bdc:	9300      	str	r3, [sp, #0]
     bde:	033f      	lsls	r7, r7, #12
     be0:	2600      	movs	r6, #0
     be2:	4b43      	ldr	r3, [pc, #268]	; (cf0 <__aeabi_dmul+0x4d8>)
     be4:	e683      	b.n	8ee <__aeabi_dmul+0xd6>
     be6:	9b01      	ldr	r3, [sp, #4]
     be8:	0032      	movs	r2, r6
     bea:	46a4      	mov	ip, r4
     bec:	4658      	mov	r0, fp
     bee:	e670      	b.n	8d2 <__aeabi_dmul+0xba>
     bf0:	46ac      	mov	ip, r5
     bf2:	e66e      	b.n	8d2 <__aeabi_dmul+0xba>
     bf4:	2780      	movs	r7, #128	; 0x80
     bf6:	9901      	ldr	r1, [sp, #4]
     bf8:	033f      	lsls	r7, r7, #12
     bfa:	4239      	tst	r1, r7
     bfc:	d02d      	beq.n	c5a <__aeabi_dmul+0x442>
     bfe:	423b      	tst	r3, r7
     c00:	d12b      	bne.n	c5a <__aeabi_dmul+0x442>
     c02:	431f      	orrs	r7, r3
     c04:	033f      	lsls	r7, r7, #12
     c06:	0b3f      	lsrs	r7, r7, #12
     c08:	9500      	str	r5, [sp, #0]
     c0a:	0016      	movs	r6, r2
     c0c:	4b38      	ldr	r3, [pc, #224]	; (cf0 <__aeabi_dmul+0x4d8>)
     c0e:	e66e      	b.n	8ee <__aeabi_dmul+0xd6>
     c10:	2501      	movs	r5, #1
     c12:	1b2d      	subs	r5, r5, r4
     c14:	2d38      	cmp	r5, #56	; 0x38
     c16:	dd00      	ble.n	c1a <__aeabi_dmul+0x402>
     c18:	e666      	b.n	8e8 <__aeabi_dmul+0xd0>
     c1a:	2d1f      	cmp	r5, #31
     c1c:	dc40      	bgt.n	ca0 <__aeabi_dmul+0x488>
     c1e:	4835      	ldr	r0, [pc, #212]	; (cf4 <__aeabi_dmul+0x4dc>)
     c20:	001c      	movs	r4, r3
     c22:	4450      	add	r0, sl
     c24:	0016      	movs	r6, r2
     c26:	4082      	lsls	r2, r0
     c28:	4084      	lsls	r4, r0
     c2a:	40ee      	lsrs	r6, r5
     c2c:	1e50      	subs	r0, r2, #1
     c2e:	4182      	sbcs	r2, r0
     c30:	4334      	orrs	r4, r6
     c32:	4314      	orrs	r4, r2
     c34:	40eb      	lsrs	r3, r5
     c36:	0762      	lsls	r2, r4, #29
     c38:	d009      	beq.n	c4e <__aeabi_dmul+0x436>
     c3a:	220f      	movs	r2, #15
     c3c:	4022      	ands	r2, r4
     c3e:	2a04      	cmp	r2, #4
     c40:	d005      	beq.n	c4e <__aeabi_dmul+0x436>
     c42:	0022      	movs	r2, r4
     c44:	1d14      	adds	r4, r2, #4
     c46:	4294      	cmp	r4, r2
     c48:	4180      	sbcs	r0, r0
     c4a:	4240      	negs	r0, r0
     c4c:	181b      	adds	r3, r3, r0
     c4e:	021a      	lsls	r2, r3, #8
     c50:	d53e      	bpl.n	cd0 <__aeabi_dmul+0x4b8>
     c52:	2301      	movs	r3, #1
     c54:	2700      	movs	r7, #0
     c56:	2600      	movs	r6, #0
     c58:	e649      	b.n	8ee <__aeabi_dmul+0xd6>
     c5a:	2780      	movs	r7, #128	; 0x80
     c5c:	9b01      	ldr	r3, [sp, #4]
     c5e:	033f      	lsls	r7, r7, #12
     c60:	431f      	orrs	r7, r3
     c62:	033f      	lsls	r7, r7, #12
     c64:	0b3f      	lsrs	r7, r7, #12
     c66:	9400      	str	r4, [sp, #0]
     c68:	4b21      	ldr	r3, [pc, #132]	; (cf0 <__aeabi_dmul+0x4d8>)
     c6a:	e640      	b.n	8ee <__aeabi_dmul+0xd6>
     c6c:	0003      	movs	r3, r0
     c6e:	465a      	mov	r2, fp
     c70:	3b28      	subs	r3, #40	; 0x28
     c72:	409a      	lsls	r2, r3
     c74:	2600      	movs	r6, #0
     c76:	9201      	str	r2, [sp, #4]
     c78:	e66d      	b.n	956 <__aeabi_dmul+0x13e>
     c7a:	4658      	mov	r0, fp
     c7c:	f000 f8ae 	bl	ddc <__clzsi2>
     c80:	3020      	adds	r0, #32
     c82:	e657      	b.n	934 <__aeabi_dmul+0x11c>
     c84:	0003      	movs	r3, r0
     c86:	4652      	mov	r2, sl
     c88:	3b28      	subs	r3, #40	; 0x28
     c8a:	409a      	lsls	r2, r3
     c8c:	0013      	movs	r3, r2
     c8e:	2200      	movs	r2, #0
     c90:	e693      	b.n	9ba <__aeabi_dmul+0x1a2>
     c92:	4650      	mov	r0, sl
     c94:	f000 f8a2 	bl	ddc <__clzsi2>
     c98:	3020      	adds	r0, #32
     c9a:	e67b      	b.n	994 <__aeabi_dmul+0x17c>
     c9c:	46ca      	mov	sl, r9
     c9e:	e750      	b.n	b42 <__aeabi_dmul+0x32a>
     ca0:	201f      	movs	r0, #31
     ca2:	001e      	movs	r6, r3
     ca4:	4240      	negs	r0, r0
     ca6:	1b04      	subs	r4, r0, r4
     ca8:	40e6      	lsrs	r6, r4
     caa:	2d20      	cmp	r5, #32
     cac:	d003      	beq.n	cb6 <__aeabi_dmul+0x49e>
     cae:	4c12      	ldr	r4, [pc, #72]	; (cf8 <__aeabi_dmul+0x4e0>)
     cb0:	4454      	add	r4, sl
     cb2:	40a3      	lsls	r3, r4
     cb4:	431a      	orrs	r2, r3
     cb6:	1e50      	subs	r0, r2, #1
     cb8:	4182      	sbcs	r2, r0
     cba:	4332      	orrs	r2, r6
     cbc:	2607      	movs	r6, #7
     cbe:	2700      	movs	r7, #0
     cc0:	4016      	ands	r6, r2
     cc2:	d009      	beq.n	cd8 <__aeabi_dmul+0x4c0>
     cc4:	200f      	movs	r0, #15
     cc6:	2300      	movs	r3, #0
     cc8:	4010      	ands	r0, r2
     cca:	0014      	movs	r4, r2
     ccc:	2804      	cmp	r0, #4
     cce:	d1b9      	bne.n	c44 <__aeabi_dmul+0x42c>
     cd0:	0022      	movs	r2, r4
     cd2:	075e      	lsls	r6, r3, #29
     cd4:	025b      	lsls	r3, r3, #9
     cd6:	0b1f      	lsrs	r7, r3, #12
     cd8:	08d2      	lsrs	r2, r2, #3
     cda:	4316      	orrs	r6, r2
     cdc:	2300      	movs	r3, #0
     cde:	e606      	b.n	8ee <__aeabi_dmul+0xd6>
     ce0:	2780      	movs	r7, #128	; 0x80
     ce2:	033f      	lsls	r7, r7, #12
     ce4:	431f      	orrs	r7, r3
     ce6:	033f      	lsls	r7, r7, #12
     ce8:	0b3f      	lsrs	r7, r7, #12
     cea:	0016      	movs	r6, r2
     cec:	4b00      	ldr	r3, [pc, #0]	; (cf0 <__aeabi_dmul+0x4d8>)
     cee:	e5fe      	b.n	8ee <__aeabi_dmul+0xd6>
     cf0:	000007ff 	.word	0x000007ff
     cf4:	0000041e 	.word	0x0000041e
     cf8:	0000043e 	.word	0x0000043e

00000cfc <__aeabi_d2iz>:
     cfc:	b530      	push	{r4, r5, lr}
     cfe:	4d14      	ldr	r5, [pc, #80]	; (d50 <__aeabi_d2iz+0x54>)
     d00:	030a      	lsls	r2, r1, #12
     d02:	004b      	lsls	r3, r1, #1
     d04:	0b12      	lsrs	r2, r2, #12
     d06:	0d5b      	lsrs	r3, r3, #21
     d08:	0fc9      	lsrs	r1, r1, #31
     d0a:	2400      	movs	r4, #0
     d0c:	42ab      	cmp	r3, r5
     d0e:	dd11      	ble.n	d34 <__aeabi_d2iz+0x38>
     d10:	4c10      	ldr	r4, [pc, #64]	; (d54 <__aeabi_d2iz+0x58>)
     d12:	42a3      	cmp	r3, r4
     d14:	dc10      	bgt.n	d38 <__aeabi_d2iz+0x3c>
     d16:	2480      	movs	r4, #128	; 0x80
     d18:	0364      	lsls	r4, r4, #13
     d1a:	4322      	orrs	r2, r4
     d1c:	4c0e      	ldr	r4, [pc, #56]	; (d58 <__aeabi_d2iz+0x5c>)
     d1e:	1ae4      	subs	r4, r4, r3
     d20:	2c1f      	cmp	r4, #31
     d22:	dd0c      	ble.n	d3e <__aeabi_d2iz+0x42>
     d24:	480d      	ldr	r0, [pc, #52]	; (d5c <__aeabi_d2iz+0x60>)
     d26:	1ac3      	subs	r3, r0, r3
     d28:	40da      	lsrs	r2, r3
     d2a:	0013      	movs	r3, r2
     d2c:	425c      	negs	r4, r3
     d2e:	2900      	cmp	r1, #0
     d30:	d100      	bne.n	d34 <__aeabi_d2iz+0x38>
     d32:	001c      	movs	r4, r3
     d34:	0020      	movs	r0, r4
     d36:	bd30      	pop	{r4, r5, pc}
     d38:	4b09      	ldr	r3, [pc, #36]	; (d60 <__aeabi_d2iz+0x64>)
     d3a:	18cc      	adds	r4, r1, r3
     d3c:	e7fa      	b.n	d34 <__aeabi_d2iz+0x38>
     d3e:	4d09      	ldr	r5, [pc, #36]	; (d64 <__aeabi_d2iz+0x68>)
     d40:	40e0      	lsrs	r0, r4
     d42:	46ac      	mov	ip, r5
     d44:	4463      	add	r3, ip
     d46:	409a      	lsls	r2, r3
     d48:	0013      	movs	r3, r2
     d4a:	4303      	orrs	r3, r0
     d4c:	e7ee      	b.n	d2c <__aeabi_d2iz+0x30>
     d4e:	46c0      	nop			; (mov r8, r8)
     d50:	000003fe 	.word	0x000003fe
     d54:	0000041d 	.word	0x0000041d
     d58:	00000433 	.word	0x00000433
     d5c:	00000413 	.word	0x00000413
     d60:	7fffffff 	.word	0x7fffffff
     d64:	fffffbed 	.word	0xfffffbed

00000d68 <__aeabi_i2d>:
     d68:	b570      	push	{r4, r5, r6, lr}
     d6a:	2800      	cmp	r0, #0
     d6c:	d02d      	beq.n	dca <__aeabi_i2d+0x62>
     d6e:	17c3      	asrs	r3, r0, #31
     d70:	18c5      	adds	r5, r0, r3
     d72:	405d      	eors	r5, r3
     d74:	0fc4      	lsrs	r4, r0, #31
     d76:	0028      	movs	r0, r5
     d78:	f000 f830 	bl	ddc <__clzsi2>
     d7c:	4b15      	ldr	r3, [pc, #84]	; (dd4 <__aeabi_i2d+0x6c>)
     d7e:	1a1b      	subs	r3, r3, r0
     d80:	055b      	lsls	r3, r3, #21
     d82:	0d5b      	lsrs	r3, r3, #21
     d84:	280a      	cmp	r0, #10
     d86:	dd15      	ble.n	db4 <__aeabi_i2d+0x4c>
     d88:	380b      	subs	r0, #11
     d8a:	4085      	lsls	r5, r0
     d8c:	2200      	movs	r2, #0
     d8e:	032d      	lsls	r5, r5, #12
     d90:	0b2d      	lsrs	r5, r5, #12
     d92:	2100      	movs	r1, #0
     d94:	0010      	movs	r0, r2
     d96:	032d      	lsls	r5, r5, #12
     d98:	0d0a      	lsrs	r2, r1, #20
     d9a:	0b2d      	lsrs	r5, r5, #12
     d9c:	0512      	lsls	r2, r2, #20
     d9e:	432a      	orrs	r2, r5
     da0:	4d0d      	ldr	r5, [pc, #52]	; (dd8 <__aeabi_i2d+0x70>)
     da2:	051b      	lsls	r3, r3, #20
     da4:	402a      	ands	r2, r5
     da6:	4313      	orrs	r3, r2
     da8:	005b      	lsls	r3, r3, #1
     daa:	07e4      	lsls	r4, r4, #31
     dac:	085b      	lsrs	r3, r3, #1
     dae:	4323      	orrs	r3, r4
     db0:	0019      	movs	r1, r3
     db2:	bd70      	pop	{r4, r5, r6, pc}
     db4:	0002      	movs	r2, r0
     db6:	0029      	movs	r1, r5
     db8:	3215      	adds	r2, #21
     dba:	4091      	lsls	r1, r2
     dbc:	000a      	movs	r2, r1
     dbe:	210b      	movs	r1, #11
     dc0:	1a08      	subs	r0, r1, r0
     dc2:	40c5      	lsrs	r5, r0
     dc4:	032d      	lsls	r5, r5, #12
     dc6:	0b2d      	lsrs	r5, r5, #12
     dc8:	e7e3      	b.n	d92 <__aeabi_i2d+0x2a>
     dca:	2400      	movs	r4, #0
     dcc:	2300      	movs	r3, #0
     dce:	2500      	movs	r5, #0
     dd0:	2200      	movs	r2, #0
     dd2:	e7de      	b.n	d92 <__aeabi_i2d+0x2a>
     dd4:	0000041e 	.word	0x0000041e
     dd8:	800fffff 	.word	0x800fffff

00000ddc <__clzsi2>:
     ddc:	211c      	movs	r1, #28
     dde:	2301      	movs	r3, #1
     de0:	041b      	lsls	r3, r3, #16
     de2:	4298      	cmp	r0, r3
     de4:	d301      	bcc.n	dea <__clzsi2+0xe>
     de6:	0c00      	lsrs	r0, r0, #16
     de8:	3910      	subs	r1, #16
     dea:	0a1b      	lsrs	r3, r3, #8
     dec:	4298      	cmp	r0, r3
     dee:	d301      	bcc.n	df4 <__clzsi2+0x18>
     df0:	0a00      	lsrs	r0, r0, #8
     df2:	3908      	subs	r1, #8
     df4:	091b      	lsrs	r3, r3, #4
     df6:	4298      	cmp	r0, r3
     df8:	d301      	bcc.n	dfe <__clzsi2+0x22>
     dfa:	0900      	lsrs	r0, r0, #4
     dfc:	3904      	subs	r1, #4
     dfe:	a202      	add	r2, pc, #8	; (adr r2, e08 <__clzsi2+0x2c>)
     e00:	5c10      	ldrb	r0, [r2, r0]
     e02:	1840      	adds	r0, r0, r1
     e04:	4770      	bx	lr
     e06:	46c0      	nop			; (mov r8, r8)
     e08:	02020304 	.word	0x02020304
     e0c:	01010101 	.word	0x01010101
	...

00000e20 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
     e20:	4770      	bx	lr
     e22:	46c0      	nop			; (mov r8, r8)
	...

00000e30 <__late_init>:
     e30:	4770      	bx	lr
     e32:	46c0      	nop			; (mov r8, r8)
	...

00000e40 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
     e40:	e7fe      	b.n	e40 <__default_exit>
     e42:	46c0      	nop			; (mov r8, r8)
	...

00000e50 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
     e50:	2280      	movs	r2, #128	; 0x80
     e52:	4694      	mov	ip, r2
     e54:	b5f0      	push	{r4, r5, r6, r7, lr}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
     e56:	2700      	movs	r7, #0
  const ram_init_area_t *rap = ram_areas;
     e58:	4e10      	ldr	r6, [pc, #64]	; (e9c <__init_ram_areas+0x4c>)
void __init_ram_areas(void) {
     e5a:	4d11      	ldr	r5, [pc, #68]	; (ea0 <__init_ram_areas+0x50>)
     e5c:	4c11      	ldr	r4, [pc, #68]	; (ea4 <__init_ram_areas+0x54>)
     e5e:	4b12      	ldr	r3, [pc, #72]	; (ea8 <__init_ram_areas+0x58>)
     e60:	4912      	ldr	r1, [pc, #72]	; (eac <__init_ram_areas+0x5c>)
     e62:	44b4      	add	ip, r6
    while (p < rap->clear_area) {
     e64:	429c      	cmp	r4, r3
     e66:	d90d      	bls.n	e84 <__init_ram_areas+0x34>
     e68:	001a      	movs	r2, r3
      *p = *tp;
     e6a:	c901      	ldmia	r1!, {r0}
     e6c:	c201      	stmia	r2!, {r0}
    while (p < rap->clear_area) {
     e6e:	4294      	cmp	r4, r2
     e70:	d8fb      	bhi.n	e6a <__init_ram_areas+0x1a>
     e72:	43da      	mvns	r2, r3
     e74:	1914      	adds	r4, r2, r4
     e76:	08a4      	lsrs	r4, r4, #2
     e78:	3401      	adds	r4, #1
     e7a:	00a4      	lsls	r4, r4, #2
     e7c:	191b      	adds	r3, r3, r4
    while (p < rap->no_init_area) {
     e7e:	429d      	cmp	r5, r3
     e80:	d902      	bls.n	e88 <__init_ram_areas+0x38>
      *p = 0;
     e82:	c380      	stmia	r3!, {r7}
    while (p < rap->no_init_area) {
     e84:	429d      	cmp	r5, r3
     e86:	d8fc      	bhi.n	e82 <__init_ram_areas+0x32>
      p++;
    }
    rap++;
     e88:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
     e8a:	4566      	cmp	r6, ip
     e8c:	d004      	beq.n	e98 <__init_ram_areas+0x48>
     e8e:	6831      	ldr	r1, [r6, #0]
     e90:	6873      	ldr	r3, [r6, #4]
     e92:	68b4      	ldr	r4, [r6, #8]
     e94:	68f5      	ldr	r5, [r6, #12]
     e96:	e7e5      	b.n	e64 <__init_ram_areas+0x14>
#endif
}
     e98:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e9a:	46c0      	nop			; (mov r8, r8)
     e9c:	00007a74 	.word	0x00007a74
     ea0:	20000ce0 	.word	0x20000ce0
     ea4:	20000ce0 	.word	0x20000ce0
     ea8:	20000ce0 	.word	0x20000ce0
     eac:	000093f8 	.word	0x000093f8

00000eb0 <_unhandled_exception>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
     eb0:	e7fe      	b.n	eb0 <_unhandled_exception>
     eb2:	46c0      	nop			; (mov r8, r8)
	...

00000ec0 <_idle_thread>:
  \brief   Wait For Interrupt
  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
     ec0:	bf30      	wfi
     ec2:	e7fd      	b.n	ec0 <_idle_thread>
	...

00000ed0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
     ed0:	b510      	push	{r4, lr}

  _scheduler_init();
     ed2:	f000 f9ad 	bl	1230 <_scheduler_init>
  _vt_init();
     ed6:	f000 f943 	bl	1160 <_vt_init>
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
     eda:	2300      	movs	r3, #0
     edc:	4c0f      	ldr	r4, [pc, #60]	; (f1c <chSysInit+0x4c>)
     ede:	6323      	str	r3, [r4, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
     ee0:	6363      	str	r3, [r4, #52]	; 0x34
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
     ee2:	f000 fe9d 	bl	1c20 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
     ee6:	f000 fefb 	bl	1ce0 <_heap_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
     eea:	0020      	movs	r0, r4
     eec:	2280      	movs	r2, #128	; 0x80
     eee:	490c      	ldr	r1, [pc, #48]	; (f20 <chSysInit+0x50>)
     ef0:	3038      	adds	r0, #56	; 0x38
     ef2:	f000 fb3d 	bl	1570 <_thread_init>
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
     ef6:	4b0b      	ldr	r3, [pc, #44]	; (f24 <chSysInit+0x54>)
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
     ef8:	2201      	movs	r2, #1
    currp->wabase = &__main_thread_stack_base__;
     efa:	61c3      	str	r3, [r0, #28]
  currp->state = CH_STATE_CURRENT;
     efc:	2320      	movs	r3, #32
     efe:	54c2      	strb	r2, [r0, r3]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
     f00:	4a09      	ldr	r2, [pc, #36]	; (f28 <chSysInit+0x58>)
     f02:	490a      	ldr	r1, [pc, #40]	; (f2c <chSysInit+0x5c>)
     f04:	6a13      	ldr	r3, [r2, #32]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
     f06:	61a0      	str	r0, [r4, #24]
     f08:	400b      	ands	r3, r1
     f0a:	6213      	str	r3, [r2, #32]
 *
 * @special
 */
static inline void chSysEnable(void) {

  _dbg_check_enable();
     f0c:	f000 f858 	bl	fc0 <_dbg_check_enable>
  __ASM volatile ("cpsie i" : : : "memory");
     f10:	b662      	cpsie	i
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
     f12:	4807      	ldr	r0, [pc, #28]	; (f30 <chSysInit+0x60>)
     f14:	f000 fba4 	bl	1660 <chThdCreate>
  }
#endif
}
     f18:	bd10      	pop	{r4, pc}
     f1a:	46c0      	nop			; (mov r8, r8)
     f1c:	200000d8 	.word	0x200000d8
     f20:	00007c80 	.word	0x00007c80
     f24:	1ffffc00 	.word	0x1ffffc00
     f28:	e000ed00 	.word	0xe000ed00
     f2c:	ff00ffff 	.word	0xff00ffff
     f30:	00007af4 	.word	0x00007af4
	...

00000f40 <chSysHalt>:
  __ASM volatile ("cpsid i" : : : "memory");
     f40:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
     f42:	4b01      	ldr	r3, [pc, #4]	; (f48 <chSysHalt+0x8>)
     f44:	62d8      	str	r0, [r3, #44]	; 0x2c
     f46:	e7fe      	b.n	f46 <chSysHalt+0x6>
     f48:	200000d8 	.word	0x200000d8
     f4c:	00000000 	.word	0x00000000

00000f50 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
     f50:	b5f0      	push	{r4, r5, r6, r7, lr}
     f52:	46c6      	mov	lr, r8
     f54:	b500      	push	{lr}

  chDbgCheckClassI();
     f56:	f000 f8d3 	bl	1100 <chDbgCheckClassI>

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->preempt > (tslices_t)0) {
     f5a:	2223      	movs	r2, #35	; 0x23
     f5c:	4d15      	ldr	r5, [pc, #84]	; (fb4 <chSysTimerHandlerI+0x64>)
     f5e:	69a9      	ldr	r1, [r5, #24]
     f60:	5c8b      	ldrb	r3, [r1, r2]
     f62:	2b00      	cmp	r3, #0
     f64:	d001      	beq.n	f6a <chSysTimerHandlerI+0x1a>
    /* Decrement remaining quantum.*/
    currp->preempt--;
     f66:	3b01      	subs	r3, #1
     f68:	548b      	strb	r3, [r1, r2]

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
     f6a:	002f      	movs	r7, r5
  chDbgCheckClassI();
     f6c:	f000 f8c8 	bl	1100 <chDbgCheckClassI>
  ch.vtlist.systime++;
     f70:	6aab      	ldr	r3, [r5, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
     f72:	69ec      	ldr	r4, [r5, #28]
  ch.vtlist.systime++;
     f74:	3301      	adds	r3, #1
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
     f76:	371c      	adds	r7, #28
  ch.vtlist.systime++;
     f78:	62ab      	str	r3, [r5, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
     f7a:	42bc      	cmp	r4, r7
     f7c:	d017      	beq.n	fae <chSysTimerHandlerI+0x5e>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
     f7e:	68a3      	ldr	r3, [r4, #8]
     f80:	3b01      	subs	r3, #1
     f82:	60a3      	str	r3, [r4, #8]
    while (ch.vtlist.next->delta == (systime_t)0) {
     f84:	2b00      	cmp	r3, #0
     f86:	d112      	bne.n	fae <chSysTimerHandlerI+0x5e>
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
      vtp->func = NULL;
     f88:	4698      	mov	r8, r3
     f8a:	4643      	mov	r3, r8
      fn = vtp->func;
     f8c:	68e6      	ldr	r6, [r4, #12]
      vtp->func = NULL;
     f8e:	60e3      	str	r3, [r4, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
     f90:	6823      	ldr	r3, [r4, #0]
     f92:	605f      	str	r7, [r3, #4]
      ch.vtlist.next = vtp->next;
     f94:	61eb      	str	r3, [r5, #28]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
     f96:	f000 f86b 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
     f9a:	b662      	cpsie	i
      chSysUnlockFromISR();
      fn(vtp->par);
     f9c:	6920      	ldr	r0, [r4, #16]
     f9e:	47b0      	blx	r6
  __ASM volatile ("cpsid i" : : : "memory");
     fa0:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
     fa2:	f000 f84d 	bl	1040 <_dbg_check_lock_from_isr>
    while (ch.vtlist.next->delta == (systime_t)0) {
     fa6:	69ec      	ldr	r4, [r5, #28]
     fa8:	68a3      	ldr	r3, [r4, #8]
     faa:	2b00      	cmp	r3, #0
     fac:	d0ed      	beq.n	f8a <chSysTimerHandlerI+0x3a>
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
  CH_CFG_SYSTEM_TICK_HOOK();
}
     fae:	bc04      	pop	{r2}
     fb0:	4690      	mov	r8, r2
     fb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     fb4:	200000d8 	.word	0x200000d8
	...

00000fc0 <_dbg_check_enable>:
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     fc0:	4b05      	ldr	r3, [pc, #20]	; (fd8 <_dbg_check_enable+0x18>)
void _dbg_check_enable(void) {
     fc2:	b510      	push	{r4, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     fc4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     fc6:	2a00      	cmp	r2, #0
     fc8:	d102      	bne.n	fd0 <_dbg_check_enable+0x10>
     fca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     fcc:	2b00      	cmp	r3, #0
     fce:	d002      	beq.n	fd6 <_dbg_check_enable+0x16>
    chSysHalt("SV#3");
     fd0:	4802      	ldr	r0, [pc, #8]	; (fdc <_dbg_check_enable+0x1c>)
     fd2:	f7ff ffb5 	bl	f40 <chSysHalt>
  }
}
     fd6:	bd10      	pop	{r4, pc}
     fd8:	200000d8 	.word	0x200000d8
     fdc:	00007b14 	.word	0x00007b14

00000fe0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
     fe0:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
     fe2:	4c06      	ldr	r4, [pc, #24]	; (ffc <_dbg_check_lock+0x1c>)
     fe4:	6b23      	ldr	r3, [r4, #48]	; 0x30
     fe6:	2b00      	cmp	r3, #0
     fe8:	d102      	bne.n	ff0 <_dbg_check_lock+0x10>
     fea:	6b63      	ldr	r3, [r4, #52]	; 0x34
     fec:	2b00      	cmp	r3, #0
     fee:	d002      	beq.n	ff6 <_dbg_check_lock+0x16>
    chSysHalt("SV#4");
     ff0:	4803      	ldr	r0, [pc, #12]	; (1000 <_dbg_check_lock+0x20>)
     ff2:	f7ff ffa5 	bl	f40 <chSysHalt>
  }
  _dbg_enter_lock();
     ff6:	2301      	movs	r3, #1
     ff8:	6363      	str	r3, [r4, #52]	; 0x34
}
     ffa:	bd10      	pop	{r4, pc}
     ffc:	200000d8 	.word	0x200000d8
    1000:	00007b2c 	.word	0x00007b2c
	...

00001010 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
    1010:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1012:	4c07      	ldr	r4, [pc, #28]	; (1030 <_dbg_check_unlock+0x20>)
    1014:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1016:	2b00      	cmp	r3, #0
    1018:	d105      	bne.n	1026 <_dbg_check_unlock+0x16>
    101a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    101c:	2b00      	cmp	r3, #0
    101e:	dd02      	ble.n	1026 <_dbg_check_unlock+0x16>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
    1020:	2300      	movs	r3, #0
    1022:	6363      	str	r3, [r4, #52]	; 0x34
}
    1024:	bd10      	pop	{r4, pc}
    chSysHalt("SV#5");
    1026:	4803      	ldr	r0, [pc, #12]	; (1034 <_dbg_check_unlock+0x24>)
    1028:	f7ff ff8a 	bl	f40 <chSysHalt>
    102c:	e7f8      	b.n	1020 <_dbg_check_unlock+0x10>
    102e:	46c0      	nop			; (mov r8, r8)
    1030:	200000d8 	.word	0x200000d8
    1034:	00007b3c 	.word	0x00007b3c
	...

00001040 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
    1040:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    1042:	4c06      	ldr	r4, [pc, #24]	; (105c <_dbg_check_lock_from_isr+0x1c>)
    1044:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1046:	2b00      	cmp	r3, #0
    1048:	dd02      	ble.n	1050 <_dbg_check_lock_from_isr+0x10>
    104a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    104c:	2b00      	cmp	r3, #0
    104e:	d002      	beq.n	1056 <_dbg_check_lock_from_isr+0x16>
    chSysHalt("SV#6");
    1050:	4803      	ldr	r0, [pc, #12]	; (1060 <_dbg_check_lock_from_isr+0x20>)
    1052:	f7ff ff75 	bl	f40 <chSysHalt>
  }
  _dbg_enter_lock();
    1056:	2301      	movs	r3, #1
    1058:	6363      	str	r3, [r4, #52]	; 0x34
}
    105a:	bd10      	pop	{r4, pc}
    105c:	200000d8 	.word	0x200000d8
    1060:	00007b34 	.word	0x00007b34
	...

00001070 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
    1070:	b510      	push	{r4, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1072:	4c07      	ldr	r4, [pc, #28]	; (1090 <_dbg_check_unlock_from_isr+0x20>)
    1074:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1076:	2b00      	cmp	r3, #0
    1078:	dd05      	ble.n	1086 <_dbg_check_unlock_from_isr+0x16>
    107a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    107c:	2b00      	cmp	r3, #0
    107e:	dd02      	ble.n	1086 <_dbg_check_unlock_from_isr+0x16>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
    1080:	2300      	movs	r3, #0
    1082:	6363      	str	r3, [r4, #52]	; 0x34
}
    1084:	bd10      	pop	{r4, pc}
    chSysHalt("SV#7");
    1086:	4803      	ldr	r0, [pc, #12]	; (1094 <_dbg_check_unlock_from_isr+0x24>)
    1088:	f7ff ff5a 	bl	f40 <chSysHalt>
    108c:	e7f8      	b.n	1080 <_dbg_check_unlock_from_isr+0x10>
    108e:	46c0      	nop			; (mov r8, r8)
    1090:	200000d8 	.word	0x200000d8
    1094:	00007b44 	.word	0x00007b44
	...

000010a0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
    10a0:	b510      	push	{r4, lr}
    10a2:	b672      	cpsid	i

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    10a4:	4c07      	ldr	r4, [pc, #28]	; (10c4 <_dbg_check_enter_isr+0x24>)
    10a6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    10a8:	2b00      	cmp	r3, #0
    10aa:	db02      	blt.n	10b2 <_dbg_check_enter_isr+0x12>
    10ac:	6b62      	ldr	r2, [r4, #52]	; 0x34
    10ae:	2a00      	cmp	r2, #0
    10b0:	d003      	beq.n	10ba <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
    10b2:	4805      	ldr	r0, [pc, #20]	; (10c8 <_dbg_check_enter_isr+0x28>)
    10b4:	f7ff ff44 	bl	f40 <chSysHalt>
    10b8:	6b23      	ldr	r3, [r4, #48]	; 0x30
  }
  ch.dbg.isr_cnt++;
    10ba:	3301      	adds	r3, #1
    10bc:	6323      	str	r3, [r4, #48]	; 0x30
  __ASM volatile ("cpsie i" : : : "memory");
    10be:	b662      	cpsie	i
  port_unlock_from_isr();
}
    10c0:	bd10      	pop	{r4, pc}
    10c2:	46c0      	nop			; (mov r8, r8)
    10c4:	200000d8 	.word	0x200000d8
    10c8:	00007b1c 	.word	0x00007b1c
    10cc:	00000000 	.word	0x00000000

000010d0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
    10d0:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    10d2:	b672      	cpsid	i

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    10d4:	4c07      	ldr	r4, [pc, #28]	; (10f4 <_dbg_check_leave_isr+0x24>)
    10d6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    10d8:	2b00      	cmp	r3, #0
    10da:	dd02      	ble.n	10e2 <_dbg_check_leave_isr+0x12>
    10dc:	6b62      	ldr	r2, [r4, #52]	; 0x34
    10de:	2a00      	cmp	r2, #0
    10e0:	d003      	beq.n	10ea <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
    10e2:	4805      	ldr	r0, [pc, #20]	; (10f8 <_dbg_check_leave_isr+0x28>)
    10e4:	f7ff ff2c 	bl	f40 <chSysHalt>
    10e8:	6b23      	ldr	r3, [r4, #48]	; 0x30
  }
  ch.dbg.isr_cnt--;
    10ea:	3b01      	subs	r3, #1
    10ec:	6323      	str	r3, [r4, #48]	; 0x30
  __ASM volatile ("cpsie i" : : : "memory");
    10ee:	b662      	cpsie	i
  port_unlock_from_isr();
}
    10f0:	bd10      	pop	{r4, pc}
    10f2:	46c0      	nop			; (mov r8, r8)
    10f4:	200000d8 	.word	0x200000d8
    10f8:	00007b24 	.word	0x00007b24
    10fc:	00000000 	.word	0x00000000

00001100 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1100:	4b06      	ldr	r3, [pc, #24]	; (111c <chDbgCheckClassI+0x1c>)
void chDbgCheckClassI(void) {
    1102:	b510      	push	{r4, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1104:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1106:	2a00      	cmp	r2, #0
    1108:	db03      	blt.n	1112 <chDbgCheckClassI+0x12>
    110a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    110c:	2b00      	cmp	r3, #0
    110e:	dd00      	ble.n	1112 <chDbgCheckClassI+0x12>
    chSysHalt("SV#10");
  }
}
    1110:	bd10      	pop	{r4, pc}
    chSysHalt("SV#10");
    1112:	4803      	ldr	r0, [pc, #12]	; (1120 <chDbgCheckClassI+0x20>)
    1114:	f7ff ff14 	bl	f40 <chSysHalt>
}
    1118:	e7fa      	b.n	1110 <chDbgCheckClassI+0x10>
    111a:	46c0      	nop			; (mov r8, r8)
    111c:	200000d8 	.word	0x200000d8
    1120:	00007b4c 	.word	0x00007b4c
	...

00001130 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1130:	4b06      	ldr	r3, [pc, #24]	; (114c <chDbgCheckClassS+0x1c>)
void chDbgCheckClassS(void) {
    1132:	b510      	push	{r4, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    1134:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1136:	2a00      	cmp	r2, #0
    1138:	d103      	bne.n	1142 <chDbgCheckClassS+0x12>
    113a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    113c:	2b00      	cmp	r3, #0
    113e:	dd00      	ble.n	1142 <chDbgCheckClassS+0x12>
    chSysHalt("SV#11");
  }
}
    1140:	bd10      	pop	{r4, pc}
    chSysHalt("SV#11");
    1142:	4803      	ldr	r0, [pc, #12]	; (1150 <chDbgCheckClassS+0x20>)
    1144:	f7ff fefc 	bl	f40 <chSysHalt>
}
    1148:	e7fa      	b.n	1140 <chDbgCheckClassS+0x10>
    114a:	46c0      	nop			; (mov r8, r8)
    114c:	200000d8 	.word	0x200000d8
    1150:	00007b54 	.word	0x00007b54
	...

00001160 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
    1160:	4b05      	ldr	r3, [pc, #20]	; (1178 <_vt_init+0x18>)
    1162:	001a      	movs	r2, r3
    1164:	321c      	adds	r2, #28
    1166:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
    1168:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
    116a:	2201      	movs	r2, #1
    116c:	4252      	negs	r2, r2
    116e:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
    1170:	2200      	movs	r2, #0
    1172:	629a      	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
    1174:	4770      	bx	lr
    1176:	46c0      	nop			; (mov r8, r8)
    1178:	200000d8 	.word	0x200000d8
    117c:	00000000 	.word	0x00000000

00001180 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
    1180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1182:	0005      	movs	r5, r0
    1184:	000c      	movs	r4, r1
    1186:	0016      	movs	r6, r2
    1188:	001f      	movs	r7, r3
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
    118a:	f7ff ffb9 	bl	1100 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
    118e:	2d00      	cmp	r5, #0
    1190:	d01c      	beq.n	11cc <chVTDoSetI+0x4c>
    1192:	2e00      	cmp	r6, #0
    1194:	d01a      	beq.n	11cc <chVTDoSetI+0x4c>
    1196:	2c00      	cmp	r4, #0
    1198:	d018      	beq.n	11cc <chVTDoSetI+0x4c>
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.next;
    119a:	490e      	ldr	r1, [pc, #56]	; (11d4 <chVTDoSetI+0x54>)
  vtp->par = par;
    119c:	612f      	str	r7, [r5, #16]
  p = ch.vtlist.next;
    119e:	69cb      	ldr	r3, [r1, #28]
  vtp->func = vtfunc;
    11a0:	60ee      	str	r6, [r5, #12]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    11a2:	689a      	ldr	r2, [r3, #8]
    11a4:	4294      	cmp	r4, r2
    11a6:	d904      	bls.n	11b2 <chVTDoSetI+0x32>
    delta -= p->delta;
    p = p->next;
    11a8:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
    11aa:	1aa4      	subs	r4, r4, r2
  while (p->delta < delta) {
    11ac:	689a      	ldr	r2, [r3, #8]
    11ae:	42a2      	cmp	r2, r4
    11b0:	d3fa      	bcc.n	11a8 <chVTDoSetI+0x28>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
    11b2:	685a      	ldr	r2, [r3, #4]
  vtp->next = p;
    11b4:	602b      	str	r3, [r5, #0]
  vtp->prev = vtp->next->prev;
    11b6:	606a      	str	r2, [r5, #4]
  vtp->prev->next = vtp;
    11b8:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
    11ba:	605d      	str	r5, [r3, #4]
  vtp->delta = delta
    11bc:	60ac      	str	r4, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
    11be:	689a      	ldr	r2, [r3, #8]
    11c0:	1b14      	subs	r4, r2, r4
    11c2:	609c      	str	r4, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
    11c4:	2301      	movs	r3, #1
    11c6:	425b      	negs	r3, r3
    11c8:	624b      	str	r3, [r1, #36]	; 0x24
}
    11ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
    11cc:	4802      	ldr	r0, [pc, #8]	; (11d8 <chVTDoSetI+0x58>)
    11ce:	f7ff feb7 	bl	f40 <chSysHalt>
    11d2:	e7e2      	b.n	119a <chVTDoSetI+0x1a>
    11d4:	200000d8 	.word	0x200000d8
    11d8:	00007b5c 	.word	0x00007b5c
    11dc:	00000000 	.word	0x00000000

000011e0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
    11e0:	b510      	push	{r4, lr}
    11e2:	0004      	movs	r4, r0

  chDbgCheckClassI();
    11e4:	f7ff ff8c 	bl	1100 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
    11e8:	2c00      	cmp	r4, #0
    11ea:	d017      	beq.n	121c <chVTDoResetI+0x3c>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
    11ec:	68e3      	ldr	r3, [r4, #12]
    11ee:	2b00      	cmp	r3, #0
    11f0:	d010      	beq.n	1214 <chVTDoResetI+0x34>

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
    11f2:	68a1      	ldr	r1, [r4, #8]
    11f4:	6823      	ldr	r3, [r4, #0]
    11f6:	468c      	mov	ip, r1
    11f8:	689a      	ldr	r2, [r3, #8]
    11fa:	4462      	add	r2, ip
    11fc:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
    11fe:	6862      	ldr	r2, [r4, #4]
    1200:	6013      	str	r3, [r2, #0]
  vtp->next->prev = vtp->prev;
    1202:	6823      	ldr	r3, [r4, #0]
    1204:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
    1206:	2300      	movs	r3, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
    1208:	2201      	movs	r2, #1
  vtp->func = NULL;
    120a:	60e3      	str	r3, [r4, #12]
  ch.vtlist.delta = (systime_t)-1;
    120c:	4b05      	ldr	r3, [pc, #20]	; (1224 <chVTDoResetI+0x44>)
    120e:	4252      	negs	r2, r2
    1210:	625a      	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
    1212:	bd10      	pop	{r4, pc}
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
    1214:	4804      	ldr	r0, [pc, #16]	; (1228 <chVTDoResetI+0x48>)
    1216:	f7ff fe93 	bl	f40 <chSysHalt>
    121a:	e7ea      	b.n	11f2 <chVTDoResetI+0x12>
  chDbgCheck(vtp != NULL);
    121c:	4802      	ldr	r0, [pc, #8]	; (1228 <chVTDoResetI+0x48>)
    121e:	f7ff fe8f 	bl	f40 <chSysHalt>
    1222:	e7e3      	b.n	11ec <chVTDoResetI+0xc>
    1224:	200000d8 	.word	0x200000d8
    1228:	00007b68 	.word	0x00007b68
    122c:	00000000 	.word	0x00000000

00001230 <_scheduler_init>:
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
    1230:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
    1232:	4b03      	ldr	r3, [pc, #12]	; (1240 <_scheduler_init+0x10>)
    1234:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
    1236:	605b      	str	r3, [r3, #4]
    1238:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
    123a:	611b      	str	r3, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
    123c:	615b      	str	r3, [r3, #20]
#endif
}
    123e:	4770      	bx	lr
    1240:	200000d8 	.word	0x200000d8
	...

00001250 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
    1250:	b510      	push	{r4, lr}
    1252:	0004      	movs	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
    1254:	f7ff ff54 	bl	1100 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    1258:	2c00      	cmp	r4, #0
    125a:	d019      	beq.n	1290 <chSchReadyI+0x40>
  chDbgAssert((tp->state != CH_STATE_READY) &&
    125c:	2320      	movs	r3, #32
    125e:	5ce3      	ldrb	r3, [r4, r3]
    1260:	2b00      	cmp	r3, #0
    1262:	d011      	beq.n	1288 <chSchReadyI+0x38>
    1264:	2b0f      	cmp	r3, #15
    1266:	d00f      	beq.n	1288 <chSchReadyI+0x38>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
    1268:	2320      	movs	r3, #32
    126a:	2200      	movs	r2, #0
    126c:	54e2      	strb	r2, [r4, r3]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
    126e:	68a2      	ldr	r2, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
    1270:	4b09      	ldr	r3, [pc, #36]	; (1298 <chSchReadyI+0x48>)
    cp = cp->queue.next;
    1272:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
    1274:	6899      	ldr	r1, [r3, #8]
    1276:	4291      	cmp	r1, r2
    1278:	d2fb      	bcs.n	1272 <chSchReadyI+0x22>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
    127a:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
    127c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
    127e:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
    1280:	0020      	movs	r0, r4
  tp->queue.prev->queue.next = tp;
    1282:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
    1284:	605c      	str	r4, [r3, #4]
}
    1286:	bd10      	pop	{r4, pc}
  chDbgAssert((tp->state != CH_STATE_READY) &&
    1288:	4804      	ldr	r0, [pc, #16]	; (129c <chSchReadyI+0x4c>)
    128a:	f7ff fe59 	bl	f40 <chSysHalt>
    128e:	e7eb      	b.n	1268 <chSchReadyI+0x18>
  chDbgCheck(tp != NULL);
    1290:	4802      	ldr	r0, [pc, #8]	; (129c <chSchReadyI+0x4c>)
    1292:	f7ff fe55 	bl	f40 <chSysHalt>
    1296:	e7e1      	b.n	125c <chSchReadyI+0xc>
    1298:	200000d8 	.word	0x200000d8
    129c:	00007b98 	.word	0x00007b98

000012a0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
    12a0:	b570      	push	{r4, r5, r6, lr}
    12a2:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
    12a4:	b672      	cpsid	i
    12a6:	f7ff fecb 	bl	1040 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
    12aa:	2320      	movs	r3, #32
    12ac:	5ce3      	ldrb	r3, [r4, r3]
    12ae:	2b07      	cmp	r3, #7
    12b0:	d80e      	bhi.n	12d0 <wakeup+0x30>
    12b2:	4a11      	ldr	r2, [pc, #68]	; (12f8 <wakeup+0x58>)
    12b4:	009b      	lsls	r3, r3, #2
    12b6:	58d3      	ldr	r3, [r2, r3]
    12b8:	469f      	mov	pc, r3
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
    12ba:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
    12bc:	f7ff ff20 	bl	1100 <chDbgCheckClassI>

  sp->cnt++;
    12c0:	68ab      	ldr	r3, [r5, #8]
    12c2:	3301      	adds	r3, #1
    12c4:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
    12c6:	6822      	ldr	r2, [r4, #0]
    12c8:	6863      	ldr	r3, [r4, #4]
    12ca:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
    12cc:	6822      	ldr	r2, [r4, #0]
    12ce:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
    12d0:	2301      	movs	r3, #1
    12d2:	425b      	negs	r3, r3
    12d4:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
    12d6:	0020      	movs	r0, r4
    12d8:	f7ff ffba 	bl	1250 <chSchReadyI>
  _dbg_check_unlock_from_isr();
    12dc:	f7ff fec8 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    12e0:	b662      	cpsie	i
  chSysUnlockFromISR();
}
    12e2:	bd70      	pop	{r4, r5, r6, pc}
    *tp->u.wttrp = NULL;
    12e4:	2200      	movs	r2, #0
    12e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
    12e8:	0020      	movs	r0, r4
    *tp->u.wttrp = NULL;
    12ea:	601a      	str	r2, [r3, #0]
  tp->u.rdymsg = MSG_TIMEOUT;
    12ec:	2301      	movs	r3, #1
    12ee:	425b      	negs	r3, r3
    12f0:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
    12f2:	f7ff ffad 	bl	1250 <chSchReadyI>
    12f6:	e7f1      	b.n	12dc <wakeup+0x3c>
    12f8:	00007b78 	.word	0x00007b78
    12fc:	00000000 	.word	0x00000000

00001300 <chSchReadyAheadI>:
thread_t *chSchReadyAheadI(thread_t *tp) {
    1300:	b510      	push	{r4, lr}
    1302:	0004      	movs	r4, r0
  chDbgCheckClassI();
    1304:	f7ff fefc 	bl	1100 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
    1308:	2c00      	cmp	r4, #0
    130a:	d019      	beq.n	1340 <chSchReadyAheadI+0x40>
  chDbgAssert((tp->state != CH_STATE_READY) &&
    130c:	2320      	movs	r3, #32
    130e:	5ce3      	ldrb	r3, [r4, r3]
    1310:	2b00      	cmp	r3, #0
    1312:	d011      	beq.n	1338 <chSchReadyAheadI+0x38>
    1314:	2b0f      	cmp	r3, #15
    1316:	d00f      	beq.n	1338 <chSchReadyAheadI+0x38>
  tp->state = CH_STATE_READY;
    1318:	2320      	movs	r3, #32
    131a:	2200      	movs	r2, #0
    131c:	54e2      	strb	r2, [r4, r3]
  } while (cp->prio > tp->prio);
    131e:	68a2      	ldr	r2, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
    1320:	4b09      	ldr	r3, [pc, #36]	; (1348 <chSchReadyAheadI+0x48>)
    cp = cp->queue.next;
    1322:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
    1324:	6899      	ldr	r1, [r3, #8]
    1326:	4291      	cmp	r1, r2
    1328:	d8fb      	bhi.n	1322 <chSchReadyAheadI+0x22>
  tp->queue.prev             = cp->queue.prev;
    132a:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
    132c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
    132e:	6062      	str	r2, [r4, #4]
}
    1330:	0020      	movs	r0, r4
  tp->queue.prev->queue.next = tp;
    1332:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
    1334:	605c      	str	r4, [r3, #4]
}
    1336:	bd10      	pop	{r4, pc}
  chDbgAssert((tp->state != CH_STATE_READY) &&
    1338:	4804      	ldr	r0, [pc, #16]	; (134c <chSchReadyAheadI+0x4c>)
    133a:	f7ff fe01 	bl	f40 <chSysHalt>
    133e:	e7eb      	b.n	1318 <chSchReadyAheadI+0x18>
  chDbgCheck(tp != NULL);
    1340:	4802      	ldr	r0, [pc, #8]	; (134c <chSchReadyAheadI+0x4c>)
    1342:	f7ff fdfd 	bl	f40 <chSysHalt>
    1346:	e7e1      	b.n	130c <chSchReadyAheadI+0xc>
    1348:	200000d8 	.word	0x200000d8
    134c:	00007ba4 	.word	0x00007ba4

00001350 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
    1350:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
    1352:	4c0f      	ldr	r4, [pc, #60]	; (1390 <chSchGoSleepS+0x40>)
void chSchGoSleepS(tstate_t newstate) {
    1354:	0006      	movs	r6, r0
  thread_t *otp = currp;
    1356:	69a5      	ldr	r5, [r4, #24]
  chDbgCheckClassS();
    1358:	f7ff feea 	bl	1130 <chDbgCheckClassS>
  otp->state = newstate;
    135c:	2320      	movs	r3, #32
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
    135e:	2223      	movs	r2, #35	; 0x23
    1360:	2114      	movs	r1, #20
  thread_t *tp = tqp->next;
    1362:	6820      	ldr	r0, [r4, #0]
  otp->state = newstate;
    1364:	54ee      	strb	r6, [r5, r3]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
    1366:	54a9      	strb	r1, [r5, r2]
  tqp->next             = tp->queue.next;
    1368:	6802      	ldr	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
    136a:	6054      	str	r4, [r2, #4]
  tqp->next             = tp->queue.next;
    136c:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
    136e:	2201      	movs	r2, #1
  currp = queue_fifo_remove(&ch.rlist.queue);
    1370:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
    1372:	54c2      	strb	r2, [r0, r3]
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    1374:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
    1378:	69ea      	ldr	r2, [r5, #28]
    137a:	3b24      	subs	r3, #36	; 0x24
    137c:	429a      	cmp	r2, r3
    137e:	d903      	bls.n	1388 <chSchGoSleepS+0x38>
    1380:	4804      	ldr	r0, [pc, #16]	; (1394 <chSchGoSleepS+0x44>)
    1382:	f7ff fddd 	bl	f40 <chSysHalt>
    1386:	69a0      	ldr	r0, [r4, #24]
    1388:	0029      	movs	r1, r5
    138a:	f7ff f8a9 	bl	4e0 <_port_switch>
}
    138e:	bd70      	pop	{r4, r5, r6, pc}
    1390:	200000d8 	.word	0x200000d8
    1394:	00007bc8 	.word	0x00007bc8
	...

000013a0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    13a0:	b570      	push	{r4, r5, r6, lr}
    13a2:	000d      	movs	r5, r1
    13a4:	b086      	sub	sp, #24
    13a6:	0006      	movs	r6, r0

  chDbgCheckClassS();
    13a8:	f7ff fec2 	bl	1130 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
    13ac:	1c6b      	adds	r3, r5, #1
    13ae:	d015      	beq.n	13dc <chSchGoSleepTimeoutS+0x3c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
    13b0:	4c0d      	ldr	r4, [pc, #52]	; (13e8 <chSchGoSleepTimeoutS+0x48>)
    13b2:	4a0e      	ldr	r2, [pc, #56]	; (13ec <chSchGoSleepTimeoutS+0x4c>)
    13b4:	69a3      	ldr	r3, [r4, #24]
    13b6:	0029      	movs	r1, r5
    13b8:	a801      	add	r0, sp, #4
    13ba:	f7ff fee1 	bl	1180 <chVTDoSetI>
    chSchGoSleepS(newstate);
    13be:	0030      	movs	r0, r6
    13c0:	f7ff ffc6 	bl	1350 <chSchGoSleepS>
  chDbgCheckClassI();
    13c4:	f7ff fe9c 	bl	1100 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
    13c8:	9b04      	ldr	r3, [sp, #16]
    13ca:	2b00      	cmp	r3, #0
    13cc:	d002      	beq.n	13d4 <chSchGoSleepTimeoutS+0x34>
      chVTDoResetI(&vt);
    13ce:	a801      	add	r0, sp, #4
    13d0:	f7ff ff06 	bl	11e0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
    13d4:	69a3      	ldr	r3, [r4, #24]
    13d6:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
    13d8:	b006      	add	sp, #24
    13da:	bd70      	pop	{r4, r5, r6, pc}
    chSchGoSleepS(newstate);
    13dc:	0030      	movs	r0, r6
    13de:	f7ff ffb7 	bl	1350 <chSchGoSleepS>
    13e2:	4c01      	ldr	r4, [pc, #4]	; (13e8 <chSchGoSleepTimeoutS+0x48>)
    13e4:	e7f6      	b.n	13d4 <chSchGoSleepTimeoutS+0x34>
    13e6:	46c0      	nop			; (mov r8, r8)
    13e8:	200000d8 	.word	0x200000d8
    13ec:	000012a1 	.word	0x000012a1

000013f0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    13f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *otp = currp;
    13f2:	4c1b      	ldr	r4, [pc, #108]	; (1460 <chSchWakeupS+0x70>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    13f4:	0005      	movs	r5, r0
    13f6:	000f      	movs	r7, r1
  thread_t *otp = currp;
    13f8:	69a6      	ldr	r6, [r4, #24]

  chDbgCheckClassS();
    13fa:	f7ff fe99 	bl	1130 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    13fe:	6823      	ldr	r3, [r4, #0]
    1400:	42a3      	cmp	r3, r4
    1402:	d004      	beq.n	140e <chSchWakeupS+0x1e>
    1404:	69a2      	ldr	r2, [r4, #24]
    1406:	689b      	ldr	r3, [r3, #8]
    1408:	6892      	ldr	r2, [r2, #8]
    140a:	429a      	cmp	r2, r3
    140c:	d317      	bcc.n	143e <chSchWakeupS+0x4e>

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    140e:	68ab      	ldr	r3, [r5, #8]
    1410:	68b2      	ldr	r2, [r6, #8]
  ntp->u.rdymsg = msg;
    1412:	626f      	str	r7, [r5, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
    1414:	4293      	cmp	r3, r2
    1416:	d91a      	bls.n	144e <chSchWakeupS+0x5e>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
    1418:	0030      	movs	r0, r6
    141a:	f7ff ff19 	bl	1250 <chSchReadyI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
    141e:	2320      	movs	r3, #32
    1420:	2201      	movs	r2, #1
    otp = chSchReadyI(otp);
    1422:	0006      	movs	r6, r0
    currp = ntp;
    1424:	61a5      	str	r5, [r4, #24]
    ntp->state = CH_STATE_CURRENT;
    1426:	54ea      	strb	r2, [r5, r3]
    1428:	f3ef 8309 	mrs	r3, PSP

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
    142c:	69c2      	ldr	r2, [r0, #28]
    142e:	3b24      	subs	r3, #36	; 0x24
    1430:	429a      	cmp	r2, r3
    1432:	d810      	bhi.n	1456 <chSchWakeupS+0x66>
    1434:	0031      	movs	r1, r6
    1436:	0028      	movs	r0, r5
    1438:	f7ff f852 	bl	4e0 <_port_switch>
  }
}
    143c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    143e:	4809      	ldr	r0, [pc, #36]	; (1464 <chSchWakeupS+0x74>)
    1440:	f7ff fd7e 	bl	f40 <chSysHalt>
  if (ntp->prio <= otp->prio) {
    1444:	68ab      	ldr	r3, [r5, #8]
    1446:	68b2      	ldr	r2, [r6, #8]
  ntp->u.rdymsg = msg;
    1448:	626f      	str	r7, [r5, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
    144a:	4293      	cmp	r3, r2
    144c:	d8e4      	bhi.n	1418 <chSchWakeupS+0x28>
    (void) chSchReadyI(ntp);
    144e:	0028      	movs	r0, r5
    1450:	f7ff fefe 	bl	1250 <chSchReadyI>
    1454:	e7f2      	b.n	143c <chSchWakeupS+0x4c>
    chSysSwitch(ntp, otp);
    1456:	4804      	ldr	r0, [pc, #16]	; (1468 <chSchWakeupS+0x78>)
    1458:	f7ff fd72 	bl	f40 <chSysHalt>
    145c:	e7ea      	b.n	1434 <chSchWakeupS+0x44>
    145e:	46c0      	nop			; (mov r8, r8)
    1460:	200000d8 	.word	0x200000d8
    1464:	00007bb8 	.word	0x00007bb8
    1468:	00007bc8 	.word	0x00007bc8
    146c:	00000000 	.word	0x00000000

00001470 <chSchIsPreemptionRequired>:
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
    1470:	2023      	movs	r0, #35	; 0x23
  tprio_t p1 = firstprio(&ch.rlist.queue);
    1472:	4b08      	ldr	r3, [pc, #32]	; (1494 <chSchIsPreemptionRequired+0x24>)
    1474:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->prio;
    1476:	699b      	ldr	r3, [r3, #24]
  tprio_t p1 = firstprio(&ch.rlist.queue);
    1478:	6891      	ldr	r1, [r2, #8]
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
    147a:	5c18      	ldrb	r0, [r3, r0]
  tprio_t p2 = currp->prio;
    147c:	689a      	ldr	r2, [r3, #8]
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
    147e:	2800      	cmp	r0, #0
    1480:	d103      	bne.n	148a <chSchIsPreemptionRequired+0x1a>
    1482:	4291      	cmp	r1, r2
    1484:	4140      	adcs	r0, r0
    1486:	b2c0      	uxtb	r0, r0
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
    1488:	4770      	bx	lr
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
    148a:	428a      	cmp	r2, r1
    148c:	4180      	sbcs	r0, r0
    148e:	4240      	negs	r0, r0
    1490:	e7fa      	b.n	1488 <chSchIsPreemptionRequired+0x18>
    1492:	46c0      	nop			; (mov r8, r8)
    1494:	200000d8 	.word	0x200000d8
	...

000014a0 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
    14a0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
    14a2:	4c0d      	ldr	r4, [pc, #52]	; (14d8 <chSchDoRescheduleAhead+0x38>)

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
    14a4:	2101      	movs	r1, #1
  thread_t *tp = tqp->next;
    14a6:	6823      	ldr	r3, [r4, #0]
  thread_t *otp = currp;
    14a8:	69a0      	ldr	r0, [r4, #24]
  tqp->next             = tp->queue.next;
    14aa:	681a      	ldr	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
    14ac:	6054      	str	r4, [r2, #4]
  tqp->next             = tp->queue.next;
    14ae:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
    14b0:	2220      	movs	r2, #32
    14b2:	5499      	strb	r1, [r3, r2]
  currp = queue_fifo_remove(&ch.rlist.queue);
    14b4:	61a3      	str	r3, [r4, #24]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
    14b6:	f7ff ff23 	bl	1300 <chSchReadyAheadI>
    14ba:	0005      	movs	r5, r0
    14bc:	f3ef 8309 	mrs	r3, PSP

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    14c0:	69c2      	ldr	r2, [r0, #28]
    14c2:	3b24      	subs	r3, #36	; 0x24
    14c4:	429a      	cmp	r2, r3
    14c6:	d902      	bls.n	14ce <chSchDoRescheduleAhead+0x2e>
    14c8:	4804      	ldr	r0, [pc, #16]	; (14dc <chSchDoRescheduleAhead+0x3c>)
    14ca:	f7ff fd39 	bl	f40 <chSysHalt>
    14ce:	0029      	movs	r1, r5
    14d0:	69a0      	ldr	r0, [r4, #24]
    14d2:	f7ff f805 	bl	4e0 <_port_switch>
}
    14d6:	bd70      	pop	{r4, r5, r6, pc}
    14d8:	200000d8 	.word	0x200000d8
    14dc:	00007bc8 	.word	0x00007bc8

000014e0 <chSchRescheduleS>:
void chSchRescheduleS(void) {
    14e0:	b510      	push	{r4, lr}
  chDbgCheckClassS();
    14e2:	f7ff fe25 	bl	1130 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
    14e6:	f7ff fe0b 	bl	1100 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
    14ea:	4b05      	ldr	r3, [pc, #20]	; (1500 <chSchRescheduleS+0x20>)
    14ec:	681a      	ldr	r2, [r3, #0]
    14ee:	699b      	ldr	r3, [r3, #24]
  if (chSchIsRescRequiredI()) {
    14f0:	6892      	ldr	r2, [r2, #8]
    14f2:	689b      	ldr	r3, [r3, #8]
    14f4:	429a      	cmp	r2, r3
    14f6:	d901      	bls.n	14fc <chSchRescheduleS+0x1c>
    chSchDoRescheduleAhead();
    14f8:	f7ff ffd2 	bl	14a0 <chSchDoRescheduleAhead>
}
    14fc:	bd10      	pop	{r4, pc}
    14fe:	46c0      	nop			; (mov r8, r8)
    1500:	200000d8 	.word	0x200000d8
	...

00001510 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    1510:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
    1512:	4c12      	ldr	r4, [pc, #72]	; (155c <chSchDoReschedule+0x4c>)

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
    1514:	2101      	movs	r1, #1
  thread_t *tp = tqp->next;
    1516:	6823      	ldr	r3, [r4, #0]
  thread_t *otp = currp;
    1518:	69a0      	ldr	r0, [r4, #24]
  tqp->next             = tp->queue.next;
    151a:	681a      	ldr	r2, [r3, #0]
  }

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->preempt == (tslices_t)0) {
    151c:	2623      	movs	r6, #35	; 0x23
  tqp->next->queue.prev = (thread_t *)tqp;
    151e:	6054      	str	r4, [r2, #4]
  tqp->next             = tp->queue.next;
    1520:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
    1522:	2220      	movs	r2, #32
  currp = queue_fifo_remove(&ch.rlist.queue);
    1524:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
    1526:	5499      	strb	r1, [r3, r2]
  if (currp->preempt == (tslices_t)0) {
    1528:	5d9b      	ldrb	r3, [r3, r6]
    152a:	2b00      	cmp	r3, #0
    152c:	d112      	bne.n	1554 <chSchDoReschedule+0x44>

    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    otp = chSchReadyI(otp);
    152e:	f7ff fe8f 	bl	1250 <chSchReadyI>

    /* The thread being swapped out receives a new time quantum.*/
    otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
    1532:	2314      	movs	r3, #20
    otp = chSchReadyI(otp);
    1534:	0005      	movs	r5, r0
    otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
    1536:	5583      	strb	r3, [r0, r6]
    1538:	f3ef 8309 	mrs	r3, PSP
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
    153c:	69ea      	ldr	r2, [r5, #28]
    153e:	3b24      	subs	r3, #36	; 0x24
    1540:	429a      	cmp	r2, r3
    1542:	d902      	bls.n	154a <chSchDoReschedule+0x3a>
    1544:	4806      	ldr	r0, [pc, #24]	; (1560 <chSchDoReschedule+0x50>)
    1546:	f7ff fcfb 	bl	f40 <chSysHalt>
    154a:	0029      	movs	r1, r5
    154c:	69a0      	ldr	r0, [r4, #24]
    154e:	f7fe ffc7 	bl	4e0 <_port_switch>
}
    1552:	bd70      	pop	{r4, r5, r6, pc}
    otp = chSchReadyAheadI(otp);
    1554:	f7ff fed4 	bl	1300 <chSchReadyAheadI>
    1558:	0005      	movs	r5, r0
    155a:	e7ed      	b.n	1538 <chSchDoReschedule+0x28>
    155c:	200000d8 	.word	0x200000d8
    1560:	00007bc8 	.word	0x00007bc8
	...

00001570 <_thread_init>:
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
    1570:	2300      	movs	r3, #0
    1572:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
    1574:	6343      	str	r3, [r0, #52]	; 0x34
  tp->state     = CH_STATE_WTSTART;
    1576:	4b09      	ldr	r3, [pc, #36]	; (159c <_thread_init+0x2c>)
  tp->prio      = prio;
    1578:	6082      	str	r2, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
    157a:	6203      	str	r3, [r0, #32]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
    157c:	4b08      	ldr	r3, [pc, #32]	; (15a0 <_thread_init+0x30>)
  tp->realprio  = prio;
    157e:	63c2      	str	r2, [r0, #60]	; 0x3c
  REG_INSERT(tp);
    1580:	695a      	ldr	r2, [r3, #20]
    1582:	6103      	str	r3, [r0, #16]
    1584:	6142      	str	r2, [r0, #20]
  tp->name      = name;
    1586:	6181      	str	r1, [r0, #24]
  REG_INSERT(tp);
    1588:	6110      	str	r0, [r2, #16]
    158a:	6158      	str	r0, [r3, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
    158c:	0003      	movs	r3, r0
    158e:	3328      	adds	r3, #40	; 0x28
  tlp->next = (thread_t *)tlp;
    1590:	6283      	str	r3, [r0, #40]	; 0x28
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
    1592:	3304      	adds	r3, #4
  tqp->next = (thread_t *)tqp;
    1594:	62c3      	str	r3, [r0, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
    1596:	6303      	str	r3, [r0, #48]	; 0x30
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
    1598:	4770      	bx	lr
    159a:	46c0      	nop			; (mov r8, r8)
    159c:	14010002 	.word	0x14010002
    15a0:	200000d8 	.word	0x200000d8
	...

000015b0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
    15b0:	b570      	push	{r4, r5, r6, lr}
    15b2:	0004      	movs	r4, r0
  thread_t *tp;

  chDbgCheckClassI();
    15b4:	f7ff fda4 	bl	1100 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
    15b8:	2c00      	cmp	r4, #0
    15ba:	d047      	beq.n	164c <chThdCreateSuspendedI+0x9c>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
    15bc:	2307      	movs	r3, #7
    15be:	6862      	ldr	r2, [r4, #4]
    15c0:	421a      	tst	r2, r3
    15c2:	d102      	bne.n	15ca <chThdCreateSuspendedI+0x1a>
    15c4:	68a1      	ldr	r1, [r4, #8]
    15c6:	4219      	tst	r1, r3
    15c8:	d03a      	beq.n	1640 <chThdCreateSuspendedI+0x90>
    15ca:	4822      	ldr	r0, [pc, #136]	; (1654 <chThdCreateSuspendedI+0xa4>)
    15cc:	f7ff fcb8 	bl	f40 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
    15d0:	68e1      	ldr	r1, [r4, #12]
    15d2:	29ff      	cmp	r1, #255	; 0xff
    15d4:	d82e      	bhi.n	1634 <chThdCreateSuspendedI+0x84>
    15d6:	6925      	ldr	r5, [r4, #16]
    15d8:	2d00      	cmp	r5, #0
    15da:	d02b      	beq.n	1634 <chThdCreateSuspendedI+0x84>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
    15dc:	68a3      	ldr	r3, [r4, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
    15de:	6862      	ldr	r2, [r4, #4]
  tp = (thread_t *)((uint8_t *)tdp->wend -
    15e0:	0018      	movs	r0, r3
    15e2:	3848      	subs	r0, #72	; 0x48
  tp->wabase = tdp->wbase;
    15e4:	61c2      	str	r2, [r0, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
    15e6:	001a      	movs	r2, r3
    15e8:	3a6c      	subs	r2, #108	; 0x6c
    15ea:	60c2      	str	r2, [r0, #12]
    15ec:	6115      	str	r5, [r2, #16]
    15ee:	6965      	ldr	r5, [r4, #20]
    15f0:	6155      	str	r5, [r2, #20]
    15f2:	4d19      	ldr	r5, [pc, #100]	; (1658 <chThdCreateSuspendedI+0xa8>)
    15f4:	6215      	str	r5, [r2, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
    15f6:	6822      	ldr	r2, [r4, #0]
  tp->state     = CH_STATE_WTSTART;
    15f8:	2402      	movs	r4, #2
  return _thread_init(tp, tdp->name, tdp->prio);
    15fa:	6182      	str	r2, [r0, #24]
  tp->state     = CH_STATE_WTSTART;
    15fc:	2220      	movs	r2, #32
  tp->prio      = prio;
    15fe:	6081      	str	r1, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
    1600:	5484      	strb	r4, [r0, r2]
  tp->flags     = CH_FLAG_MODE_STATIC;
    1602:	2200      	movs	r2, #0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
    1604:	2514      	movs	r5, #20
  tp->flags     = CH_FLAG_MODE_STATIC;
    1606:	341f      	adds	r4, #31
    1608:	5502      	strb	r2, [r0, r4]
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
    160a:	3402      	adds	r4, #2
    160c:	5505      	strb	r5, [r0, r4]
  tp->realprio  = prio;
    160e:	63c1      	str	r1, [r0, #60]	; 0x3c
  tp->refs      = (trefs_t)1;
    1610:	2101      	movs	r1, #1
  tp->mtxlist   = NULL;
    1612:	6382      	str	r2, [r0, #56]	; 0x38
  tp->epending  = (eventmask_t)0;
    1614:	6342      	str	r2, [r0, #52]	; 0x34
  tp->refs      = (trefs_t)1;
    1616:	3222      	adds	r2, #34	; 0x22
    1618:	5481      	strb	r1, [r0, r2]
  REG_INSERT(tp);
    161a:	4a10      	ldr	r2, [pc, #64]	; (165c <chThdCreateSuspendedI+0xac>)
    161c:	6951      	ldr	r1, [r2, #20]
    161e:	6102      	str	r2, [r0, #16]
    1620:	6141      	str	r1, [r0, #20]
    1622:	6108      	str	r0, [r1, #16]
    1624:	6150      	str	r0, [r2, #20]
  tlp->next = (thread_t *)tlp;
    1626:	001a      	movs	r2, r3
  queue_init(&tp->msgqueue);
    1628:	3b1c      	subs	r3, #28
    162a:	3a20      	subs	r2, #32
    162c:	6012      	str	r2, [r2, #0]
  tqp->next = (thread_t *)tqp;
    162e:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
    1630:	605b      	str	r3, [r3, #4]
}
    1632:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
    1634:	4807      	ldr	r0, [pc, #28]	; (1654 <chThdCreateSuspendedI+0xa4>)
    1636:	f7ff fc83 	bl	f40 <chSysHalt>
    163a:	6925      	ldr	r5, [r4, #16]
    163c:	68e1      	ldr	r1, [r4, #12]
    163e:	e7cd      	b.n	15dc <chThdCreateSuspendedI+0x2c>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
    1640:	428a      	cmp	r2, r1
    1642:	d2c2      	bcs.n	15ca <chThdCreateSuspendedI+0x1a>
    1644:	1a8a      	subs	r2, r1, r2
    1646:	2ac7      	cmp	r2, #199	; 0xc7
    1648:	d8c2      	bhi.n	15d0 <chThdCreateSuspendedI+0x20>
    164a:	e7be      	b.n	15ca <chThdCreateSuspendedI+0x1a>
  chDbgCheck(tdp != NULL);
    164c:	4801      	ldr	r0, [pc, #4]	; (1654 <chThdCreateSuspendedI+0xa4>)
    164e:	f7ff fc77 	bl	f40 <chSysHalt>
    1652:	e7b3      	b.n	15bc <chThdCreateSuspendedI+0xc>
    1654:	00007c04 	.word	0x00007c04
    1658:	00000501 	.word	0x00000501
    165c:	200000d8 	.word	0x200000d8

00001660 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
    1660:	b510      	push	{r4, lr}
    1662:	0004      	movs	r4, r0
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
    1664:	6840      	ldr	r0, [r0, #4]
    1666:	f000 f9a3 	bl	19b0 <chRegFindThreadByWorkingArea>
    166a:	2800      	cmp	r0, #0
    166c:	d002      	beq.n	1674 <chThdCreate+0x14>
    166e:	4814      	ldr	r0, [pc, #80]	; (16c0 <chThdCreate+0x60>)
    1670:	f7ff fc66 	bl	f40 <chSysHalt>
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
    1674:	6863      	ldr	r3, [r4, #4]
                  (uint8_t *)tdp->wend,
    1676:	68a2      	ldr	r2, [r4, #8]
  while (startp < endp) {
    1678:	4293      	cmp	r3, r2
    167a:	d204      	bcs.n	1686 <chThdCreate+0x26>
    *startp++ = v;
    167c:	2155      	movs	r1, #85	; 0x55
    167e:	7019      	strb	r1, [r3, #0]
    1680:	3301      	adds	r3, #1
  while (startp < endp) {
    1682:	429a      	cmp	r2, r3
    1684:	d1fb      	bne.n	167e <chThdCreate+0x1e>
  __ASM volatile ("cpsid i" : : : "memory");
    1686:	b672      	cpsid	i
  _dbg_check_lock();
    1688:	f7ff fcaa 	bl	fe0 <_dbg_check_lock>
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
    168c:	0020      	movs	r0, r4
    168e:	f7ff ff8f 	bl	15b0 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
    1692:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(tdp);
    1694:	0004      	movs	r4, r0
  chSchWakeupS(tp, MSG_OK);
    1696:	f7ff feab 	bl	13f0 <chSchWakeupS>
  _dbg_check_unlock();
    169a:	f7ff fcb9 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    169e:	4b09      	ldr	r3, [pc, #36]	; (16c4 <chThdCreate+0x64>)
    16a0:	681a      	ldr	r2, [r3, #0]
    16a2:	429a      	cmp	r2, r3
    16a4:	d004      	beq.n	16b0 <chThdCreate+0x50>
    16a6:	699b      	ldr	r3, [r3, #24]
    16a8:	6899      	ldr	r1, [r3, #8]
    16aa:	6893      	ldr	r3, [r2, #8]
    16ac:	4299      	cmp	r1, r3
    16ae:	d302      	bcc.n	16b6 <chThdCreate+0x56>
  __ASM volatile ("cpsie i" : : : "memory");
    16b0:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
    16b2:	0020      	movs	r0, r4
    16b4:	bd10      	pop	{r4, pc}
    16b6:	4804      	ldr	r0, [pc, #16]	; (16c8 <chThdCreate+0x68>)
    16b8:	f7ff fc42 	bl	f40 <chSysHalt>
    16bc:	e7f8      	b.n	16b0 <chThdCreate+0x50>
    16be:	46c0      	nop			; (mov r8, r8)
    16c0:	00007c1c 	.word	0x00007c1c
    16c4:	200000d8 	.word	0x200000d8
    16c8:	00007bd8 	.word	0x00007bd8
    16cc:	00000000 	.word	0x00000000

000016d0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
    16d0:	b570      	push	{r4, r5, r6, lr}
    16d2:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
    16d4:	b672      	cpsid	i

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
    16d6:	2522      	movs	r5, #34	; 0x22
  _dbg_check_lock();
    16d8:	f7ff fc82 	bl	fe0 <_dbg_check_lock>
    16dc:	5d63      	ldrb	r3, [r4, r5]
    16de:	2b00      	cmp	r3, #0
    16e0:	d032      	beq.n	1748 <chThdRelease+0x78>
  tp->refs--;
    16e2:	2222      	movs	r2, #34	; 0x22
    16e4:	3b01      	subs	r3, #1
    16e6:	54a3      	strb	r3, [r4, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    16e8:	6a22      	ldr	r2, [r4, #32]
    16ea:	4b20      	ldr	r3, [pc, #128]	; (176c <chThdRelease+0x9c>)
    16ec:	4013      	ands	r3, r2
    16ee:	2b0f      	cmp	r3, #15
    16f0:	d00c      	beq.n	170c <chThdRelease+0x3c>
  _dbg_check_unlock();
    16f2:	f7ff fc8d 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    16f6:	4b1e      	ldr	r3, [pc, #120]	; (1770 <chThdRelease+0xa0>)
    16f8:	681a      	ldr	r2, [r3, #0]
    16fa:	429a      	cmp	r2, r3
    16fc:	d004      	beq.n	1708 <chThdRelease+0x38>
    16fe:	699b      	ldr	r3, [r3, #24]
    1700:	6899      	ldr	r1, [r3, #8]
    1702:	6893      	ldr	r3, [r2, #8]
    1704:	4299      	cmp	r1, r3
    1706:	d324      	bcc.n	1752 <chThdRelease+0x82>
  __ASM volatile ("cpsie i" : : : "memory");
    1708:	b662      	cpsie	i
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
    170a:	bd70      	pop	{r4, r5, r6, pc}
    REG_REMOVE(tp);
    170c:	6963      	ldr	r3, [r4, #20]
    170e:	6922      	ldr	r2, [r4, #16]
    1710:	611a      	str	r2, [r3, #16]
    1712:	6922      	ldr	r2, [r4, #16]
    1714:	6153      	str	r3, [r2, #20]
  _dbg_check_unlock();
    1716:	f7ff fc7b 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    171a:	4b15      	ldr	r3, [pc, #84]	; (1770 <chThdRelease+0xa0>)
    171c:	681a      	ldr	r2, [r3, #0]
    171e:	429a      	cmp	r2, r3
    1720:	d004      	beq.n	172c <chThdRelease+0x5c>
    1722:	699b      	ldr	r3, [r3, #24]
    1724:	6899      	ldr	r1, [r3, #8]
    1726:	6893      	ldr	r3, [r2, #8]
    1728:	4299      	cmp	r1, r3
    172a:	d316      	bcc.n	175a <chThdRelease+0x8a>
    172c:	b662      	cpsie	i
    switch (tp->flags & CH_FLAG_MODE_MASK) {
    172e:	2321      	movs	r3, #33	; 0x21
    1730:	5ce2      	ldrb	r2, [r4, r3]
    1732:	3b1e      	subs	r3, #30
    1734:	4013      	ands	r3, r2
    1736:	2b01      	cmp	r3, #1
    1738:	d013      	beq.n	1762 <chThdRelease+0x92>
    173a:	2b02      	cmp	r3, #2
    173c:	d1e5      	bne.n	170a <chThdRelease+0x3a>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
    173e:	69e1      	ldr	r1, [r4, #28]
    1740:	6c20      	ldr	r0, [r4, #64]	; 0x40
    1742:	f000 fb55 	bl	1df0 <chPoolFree>
    1746:	e7e0      	b.n	170a <chThdRelease+0x3a>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
    1748:	480a      	ldr	r0, [pc, #40]	; (1774 <chThdRelease+0xa4>)
    174a:	f7ff fbf9 	bl	f40 <chSysHalt>
    174e:	5d63      	ldrb	r3, [r4, r5]
    1750:	e7c7      	b.n	16e2 <chThdRelease+0x12>
    1752:	4809      	ldr	r0, [pc, #36]	; (1778 <chThdRelease+0xa8>)
    1754:	f7ff fbf4 	bl	f40 <chSysHalt>
    1758:	e7d6      	b.n	1708 <chThdRelease+0x38>
    175a:	4807      	ldr	r0, [pc, #28]	; (1778 <chThdRelease+0xa8>)
    175c:	f7ff fbf0 	bl	f40 <chSysHalt>
    1760:	e7e4      	b.n	172c <chThdRelease+0x5c>
      chHeapFree(chThdGetWorkingAreaX(tp));
    1762:	69e0      	ldr	r0, [r4, #28]
    1764:	f000 facc 	bl	1d00 <chHeapFree>
      break;
    1768:	e7cf      	b.n	170a <chThdRelease+0x3a>
    176a:	46c0      	nop			; (mov r8, r8)
    176c:	00ff00ff 	.word	0x00ff00ff
    1770:	200000d8 	.word	0x200000d8
    1774:	00007c28 	.word	0x00007c28
    1778:	00007bd8 	.word	0x00007bd8
    177c:	00000000 	.word	0x00000000

00001780 <chThdExitS>:
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
    1780:	4b11      	ldr	r3, [pc, #68]	; (17c8 <chThdExitS+0x48>)
void chThdExitS(msg_t msg) {
    1782:	b570      	push	{r4, r5, r6, lr}
  thread_t *tp = currp;
    1784:	699c      	ldr	r4, [r3, #24]
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    1786:	0025      	movs	r5, r4
  tp->u.exitcode = msg;
    1788:	6260      	str	r0, [r4, #36]	; 0x24
  return (bool)(tlp->next != (thread_t *)tlp);
    178a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
    178c:	3528      	adds	r5, #40	; 0x28
    178e:	42a8      	cmp	r0, r5
    1790:	d006      	beq.n	17a0 <chThdExitS+0x20>
  tlp->next = tp->queue.next;
    1792:	6803      	ldr	r3, [r0, #0]
    1794:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
    1796:	f7ff fd5b 	bl	1250 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
    179a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
    179c:	42a8      	cmp	r0, r5
    179e:	d1f8      	bne.n	1792 <chThdExitS+0x12>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
    17a0:	2322      	movs	r3, #34	; 0x22
    17a2:	5ce3      	ldrb	r3, [r4, r3]
    17a4:	2b00      	cmp	r3, #0
    17a6:	d108      	bne.n	17ba <chThdExitS+0x3a>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    17a8:	3321      	adds	r3, #33	; 0x21
  if ((tp->refs == (trefs_t)0) &&
    17aa:	5ce3      	ldrb	r3, [r4, r3]
    17ac:	079b      	lsls	r3, r3, #30
    17ae:	d104      	bne.n	17ba <chThdExitS+0x3a>
    REG_REMOVE(tp);
    17b0:	6922      	ldr	r2, [r4, #16]
    17b2:	6963      	ldr	r3, [r4, #20]
    17b4:	611a      	str	r2, [r3, #16]
    17b6:	6922      	ldr	r2, [r4, #16]
    17b8:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
    17ba:	200f      	movs	r0, #15
    17bc:	f7ff fdc8 	bl	1350 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
    17c0:	4802      	ldr	r0, [pc, #8]	; (17cc <chThdExitS+0x4c>)
    17c2:	f7ff fbbd 	bl	f40 <chSysHalt>
}
    17c6:	bd70      	pop	{r4, r5, r6, pc}
    17c8:	200000d8 	.word	0x200000d8
    17cc:	00007c38 	.word	0x00007c38

000017d0 <chThdExit>:
void chThdExit(msg_t msg) {
    17d0:	b510      	push	{r4, lr}
    17d2:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
    17d4:	b672      	cpsid	i
  _dbg_check_lock();
    17d6:	f7ff fc03 	bl	fe0 <_dbg_check_lock>
  chThdExitS(msg);
    17da:	0020      	movs	r0, r4
    17dc:	f7ff ffd0 	bl	1780 <chThdExitS>
}
    17e0:	bd10      	pop	{r4, pc}
    17e2:	46c0      	nop			; (mov r8, r8)
	...

000017f0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
    17f0:	b510      	push	{r4, lr}
    17f2:	0004      	movs	r4, r0
    17f4:	b672      	cpsid	i
    17f6:	f7ff fbf3 	bl	fe0 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
    17fa:	2c00      	cmp	r4, #0
    17fc:	d102      	bne.n	1804 <chThdSleep+0x14>
    17fe:	480c      	ldr	r0, [pc, #48]	; (1830 <chThdSleep+0x40>)
    1800:	f7ff fb9e 	bl	f40 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    1804:	0021      	movs	r1, r4
    1806:	2008      	movs	r0, #8
    1808:	f7ff fdca 	bl	13a0 <chSchGoSleepTimeoutS>
  _dbg_check_unlock();
    180c:	f7ff fc00 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1810:	4b08      	ldr	r3, [pc, #32]	; (1834 <chThdSleep+0x44>)
    1812:	681a      	ldr	r2, [r3, #0]
    1814:	429a      	cmp	r2, r3
    1816:	d004      	beq.n	1822 <chThdSleep+0x32>
    1818:	699b      	ldr	r3, [r3, #24]
    181a:	6899      	ldr	r1, [r3, #8]
    181c:	6893      	ldr	r3, [r2, #8]
    181e:	4299      	cmp	r1, r3
    1820:	d301      	bcc.n	1826 <chThdSleep+0x36>
  __ASM volatile ("cpsie i" : : : "memory");
    1822:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
    1824:	bd10      	pop	{r4, pc}
    1826:	4804      	ldr	r0, [pc, #16]	; (1838 <chThdSleep+0x48>)
    1828:	f7ff fb8a 	bl	f40 <chSysHalt>
    182c:	e7f9      	b.n	1822 <chThdSleep+0x32>
    182e:	46c0      	nop			; (mov r8, r8)
    1830:	00007be4 	.word	0x00007be4
    1834:	200000d8 	.word	0x200000d8
    1838:	00007bd8 	.word	0x00007bd8
    183c:	00000000 	.word	0x00000000

00001840 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
    1840:	b570      	push	{r4, r5, r6, lr}
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
    1842:	6803      	ldr	r3, [r0, #0]
  return ch.rlist.current;
    1844:	4d07      	ldr	r5, [pc, #28]	; (1864 <chThdSuspendS+0x24>)
msg_t chThdSuspendS(thread_reference_t *trp) {
    1846:	0004      	movs	r4, r0
    1848:	69ae      	ldr	r6, [r5, #24]
  chDbgAssert(*trp == NULL, "not NULL");
    184a:	2b00      	cmp	r3, #0
    184c:	d002      	beq.n	1854 <chThdSuspendS+0x14>
    184e:	4806      	ldr	r0, [pc, #24]	; (1868 <chThdSuspendS+0x28>)
    1850:	f7ff fb76 	bl	f40 <chSysHalt>

  *trp = tp;
    1854:	6026      	str	r6, [r4, #0]
  tp->u.wttrp = trp;
  chSchGoSleepS(CH_STATE_SUSPENDED);
    1856:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
    1858:	6274      	str	r4, [r6, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
    185a:	f7ff fd79 	bl	1350 <chSchGoSleepS>

  return chThdGetSelfX()->u.rdymsg;
    185e:	69ab      	ldr	r3, [r5, #24]
    1860:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
    1862:	bd70      	pop	{r4, r5, r6, pc}
    1864:	200000d8 	.word	0x200000d8
    1868:	00007c44 	.word	0x00007c44
    186c:	00000000 	.word	0x00000000

00001870 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    1870:	b570      	push	{r4, r5, r6, lr}

  if (*trp != NULL) {
    1872:	6804      	ldr	r4, [r0, #0]
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    1874:	0005      	movs	r5, r0
    1876:	000e      	movs	r6, r1
  if (*trp != NULL) {
    1878:	2c00      	cmp	r4, #0
    187a:	d009      	beq.n	1890 <chThdResumeI+0x20>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
    187c:	2320      	movs	r3, #32
    187e:	5ce3      	ldrb	r3, [r4, r3]
    1880:	2b03      	cmp	r3, #3
    1882:	d106      	bne.n	1892 <chThdResumeI+0x22>

    *trp = NULL;
    1884:	2300      	movs	r3, #0
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
    1886:	0020      	movs	r0, r4
    *trp = NULL;
    1888:	602b      	str	r3, [r5, #0]
    tp->u.rdymsg = msg;
    188a:	6266      	str	r6, [r4, #36]	; 0x24
    (void) chSchReadyI(tp);
    188c:	f7ff fce0 	bl	1250 <chSchReadyI>
  }
}
    1890:	bd70      	pop	{r4, r5, r6, pc}
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
    1892:	4802      	ldr	r0, [pc, #8]	; (189c <chThdResumeI+0x2c>)
    1894:	f7ff fb54 	bl	f40 <chSysHalt>
    1898:	e7f4      	b.n	1884 <chThdResumeI+0x14>
    189a:	46c0      	nop			; (mov r8, r8)
    189c:	00007c54 	.word	0x00007c54

000018a0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
    18a0:	b510      	push	{r4, lr}

  if (TIME_IMMEDIATE == timeout) {
    18a2:	2900      	cmp	r1, #0
    18a4:	d00a      	beq.n	18bc <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
    18a6:	4b07      	ldr	r3, [pc, #28]	; (18c4 <chThdEnqueueTimeoutS+0x24>)
  tp->queue.prev             = tqp->prev;
    18a8:	6842      	ldr	r2, [r0, #4]
    18aa:	699b      	ldr	r3, [r3, #24]
  tp->queue.next             = (thread_t *)tqp;
    18ac:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
    18ae:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
    18b0:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
    18b2:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    18b4:	2004      	movs	r0, #4
    18b6:	f7ff fd73 	bl	13a0 <chSchGoSleepTimeoutS>
}
    18ba:	bd10      	pop	{r4, pc}
    return MSG_TIMEOUT;
    18bc:	2001      	movs	r0, #1
    18be:	4240      	negs	r0, r0
    18c0:	e7fb      	b.n	18ba <chThdEnqueueTimeoutS+0x1a>
    18c2:	46c0      	nop			; (mov r8, r8)
    18c4:	200000d8 	.word	0x200000d8
	...

000018d0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    18d0:	b570      	push	{r4, r5, r6, lr}
  return (bool)(tqp->next != (const thread_t *)tqp);
    18d2:	6804      	ldr	r4, [r0, #0]
    18d4:	000d      	movs	r5, r1

  if (queue_notempty(tqp)) {
    18d6:	42a0      	cmp	r0, r4
    18d8:	d00d      	beq.n	18f6 <chThdDequeueNextI+0x26>
  tqp->next             = tp->queue.next;
    18da:	6823      	ldr	r3, [r4, #0]
    18dc:	6003      	str	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
    18de:	6058      	str	r0, [r3, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
    18e0:	2320      	movs	r3, #32
    18e2:	5ce3      	ldrb	r3, [r4, r3]
    18e4:	2b04      	cmp	r3, #4
    18e6:	d002      	beq.n	18ee <chThdDequeueNextI+0x1e>
    18e8:	4803      	ldr	r0, [pc, #12]	; (18f8 <chThdDequeueNextI+0x28>)
    18ea:	f7ff fb29 	bl	f40 <chSysHalt>

  tp->u.rdymsg = msg;
    18ee:	6265      	str	r5, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
    18f0:	0020      	movs	r0, r4
    18f2:	f7ff fcad 	bl	1250 <chSchReadyI>
    chThdDoDequeueNextI(tqp, msg);
  }
}
    18f6:	bd70      	pop	{r4, r5, r6, pc}
    18f8:	00007bf0 	.word	0x00007bf0
    18fc:	00000000 	.word	0x00000000

00001900 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
    1900:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    1902:	b672      	cpsid	i
  _dbg_check_lock();
    1904:	f7ff fb6c 	bl	fe0 <_dbg_check_lock>
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
    1908:	2222      	movs	r2, #34	; 0x22
  tp = ch.rlist.newer;
    190a:	4c0b      	ldr	r4, [pc, #44]	; (1938 <chRegFirstThread+0x38>)
    190c:	6925      	ldr	r5, [r4, #16]
  tp->refs++;
    190e:	5cab      	ldrb	r3, [r5, r2]
    1910:	3301      	adds	r3, #1
    1912:	54ab      	strb	r3, [r5, r2]
  _dbg_check_unlock();
    1914:	f7ff fb7c 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1918:	6823      	ldr	r3, [r4, #0]
    191a:	42a3      	cmp	r3, r4
    191c:	d004      	beq.n	1928 <chRegFirstThread+0x28>
    191e:	69a2      	ldr	r2, [r4, #24]
    1920:	689b      	ldr	r3, [r3, #8]
    1922:	6892      	ldr	r2, [r2, #8]
    1924:	429a      	cmp	r2, r3
    1926:	d302      	bcc.n	192e <chRegFirstThread+0x2e>
  __ASM volatile ("cpsie i" : : : "memory");
    1928:	b662      	cpsie	i
#endif
  chSysUnlock();

  return tp;
}
    192a:	0028      	movs	r0, r5
    192c:	bd70      	pop	{r4, r5, r6, pc}
    192e:	4803      	ldr	r0, [pc, #12]	; (193c <chRegFirstThread+0x3c>)
    1930:	f7ff fb06 	bl	f40 <chSysHalt>
    1934:	e7f8      	b.n	1928 <chRegFirstThread+0x28>
    1936:	46c0      	nop			; (mov r8, r8)
    1938:	200000d8 	.word	0x200000d8
    193c:	00007c64 	.word	0x00007c64

00001940 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
    1940:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1942:	0006      	movs	r6, r0
  __ASM volatile ("cpsid i" : : : "memory");
    1944:	b672      	cpsid	i
  _dbg_check_lock();
    1946:	f7ff fb4b 	bl	fe0 <_dbg_check_lock>
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
    194a:	6934      	ldr	r4, [r6, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
    194c:	4d12      	ldr	r5, [pc, #72]	; (1998 <chRegNextThread+0x58>)
    194e:	42ac      	cmp	r4, r5
    1950:	d01f      	beq.n	1992 <chRegNextThread+0x52>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    1952:	2722      	movs	r7, #34	; 0x22
    1954:	5de3      	ldrb	r3, [r4, r7]
    1956:	2bff      	cmp	r3, #255	; 0xff
    1958:	d016      	beq.n	1988 <chRegNextThread+0x48>
    ntp->refs++;
    195a:	2222      	movs	r2, #34	; 0x22
    195c:	3301      	adds	r3, #1
    195e:	54a3      	strb	r3, [r4, r2]
  _dbg_check_unlock();
    1960:	f7ff fb56 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1964:	682b      	ldr	r3, [r5, #0]
    1966:	42ab      	cmp	r3, r5
    1968:	d004      	beq.n	1974 <chRegNextThread+0x34>
    196a:	69aa      	ldr	r2, [r5, #24]
    196c:	689b      	ldr	r3, [r3, #8]
    196e:	6892      	ldr	r2, [r2, #8]
    1970:	429a      	cmp	r2, r3
    1972:	d305      	bcc.n	1980 <chRegNextThread+0x40>
  __ASM volatile ("cpsie i" : : : "memory");
    1974:	b662      	cpsie	i
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
    1976:	0030      	movs	r0, r6
    1978:	f7ff feaa 	bl	16d0 <chThdRelease>
#endif

  return ntp;
}
    197c:	0020      	movs	r0, r4
    197e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1980:	4806      	ldr	r0, [pc, #24]	; (199c <chRegNextThread+0x5c>)
    1982:	f7ff fadd 	bl	f40 <chSysHalt>
    1986:	e7f5      	b.n	1974 <chRegNextThread+0x34>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    1988:	4805      	ldr	r0, [pc, #20]	; (19a0 <chRegNextThread+0x60>)
    198a:	f7ff fad9 	bl	f40 <chSysHalt>
    198e:	5de3      	ldrb	r3, [r4, r7]
    1990:	e7e3      	b.n	195a <chRegNextThread+0x1a>
    ntp = NULL;
    1992:	2400      	movs	r4, #0
    1994:	e7e4      	b.n	1960 <chRegNextThread+0x20>
    1996:	46c0      	nop			; (mov r8, r8)
    1998:	200000d8 	.word	0x200000d8
    199c:	00007c64 	.word	0x00007c64
    19a0:	00007c70 	.word	0x00007c70
	...

000019b0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
    19b0:	b510      	push	{r4, lr}
    19b2:	0004      	movs	r4, r0
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
    19b4:	f7ff ffa4 	bl	1900 <chRegFirstThread>
    19b8:	e003      	b.n	19c2 <chRegFindThreadByWorkingArea+0x12>
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
    19ba:	f7ff ffc1 	bl	1940 <chRegNextThread>
  } while (ctp != NULL);
    19be:	2800      	cmp	r0, #0
    19c0:	d002      	beq.n	19c8 <chRegFindThreadByWorkingArea+0x18>
    if (chThdGetWorkingAreaX(ctp) == wa) {
    19c2:	69c3      	ldr	r3, [r0, #28]
    19c4:	429c      	cmp	r4, r3
    19c6:	d1f8      	bne.n	19ba <chRegFindThreadByWorkingArea+0xa>

  return NULL;
}
    19c8:	bd10      	pop	{r4, pc}
    19ca:	46c0      	nop			; (mov r8, r8)
    19cc:	0000      	movs	r0, r0
	...

000019d0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
    19d0:	b510      	push	{r4, lr}
    19d2:	1e04      	subs	r4, r0, #0

  chDbgCheck(mp != NULL);
    19d4:	d004      	beq.n	19e0 <chMtxObjectInit+0x10>

  queue_init(&mp->queue);
  mp->owner = NULL;
    19d6:	2300      	movs	r3, #0
  tqp->next = (thread_t *)tqp;
    19d8:	6024      	str	r4, [r4, #0]
  tqp->prev = (thread_t *)tqp;
    19da:	6064      	str	r4, [r4, #4]
    19dc:	60a3      	str	r3, [r4, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
    19de:	bd10      	pop	{r4, pc}
  chDbgCheck(mp != NULL);
    19e0:	4801      	ldr	r0, [pc, #4]	; (19e8 <chMtxObjectInit+0x18>)
    19e2:	f7ff faad 	bl	f40 <chSysHalt>
    19e6:	e7f6      	b.n	19d6 <chMtxObjectInit+0x6>
    19e8:	00007ca4 	.word	0x00007ca4
    19ec:	00000000 	.word	0x00000000

000019f0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
    19f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
    19f2:	4b43      	ldr	r3, [pc, #268]	; (1b00 <chMtxLockS+0x110>)
void chMtxLockS(mutex_t *mp) {
    19f4:	0004      	movs	r4, r0
  thread_t *ctp = currp;
    19f6:	699d      	ldr	r5, [r3, #24]

  chDbgCheckClassS();
    19f8:	f7ff fb9a 	bl	1130 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
    19fc:	2c00      	cmp	r4, #0
    19fe:	d100      	bne.n	1a02 <chMtxLockS+0x12>
    1a00:	e070      	b.n	1ae4 <chMtxLockS+0xf4>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
    1a02:	68a0      	ldr	r0, [r4, #8]
    1a04:	2800      	cmp	r0, #0
    1a06:	d04c      	beq.n	1aa2 <chMtxLockS+0xb2>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
    1a08:	68aa      	ldr	r2, [r5, #8]
    1a0a:	6883      	ldr	r3, [r0, #8]
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
    1a0c:	2620      	movs	r6, #32
      while (tp->prio < ctp->prio) {
    1a0e:	429a      	cmp	r2, r3
    1a10:	d907      	bls.n	1a22 <chMtxLockS+0x32>
        tp->prio = ctp->prio;
    1a12:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
    1a14:	5d83      	ldrb	r3, [r0, r6]
    1a16:	2b06      	cmp	r3, #6
    1a18:	d048      	beq.n	1aac <chMtxLockS+0xbc>
    1a1a:	2b07      	cmp	r3, #7
    1a1c:	d021      	beq.n	1a62 <chMtxLockS+0x72>
    1a1e:	2b00      	cmp	r3, #0
    1a20:	d033      	beq.n	1a8a <chMtxLockS+0x9a>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
    1a22:	0022      	movs	r2, r4
    1a24:	0023      	movs	r3, r4
    1a26:	e003      	b.n	1a30 <chMtxLockS+0x40>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1a28:	6899      	ldr	r1, [r3, #8]
    1a2a:	68a8      	ldr	r0, [r5, #8]
    1a2c:	4281      	cmp	r1, r0
    1a2e:	d336      	bcc.n	1a9e <chMtxLockS+0xae>
    cp = cp->queue.next;
    1a30:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1a32:	429c      	cmp	r4, r3
    1a34:	d1f8      	bne.n	1a28 <chMtxLockS+0x38>
  tp->queue.prev             = cp->queue.prev;
    1a36:	6853      	ldr	r3, [r2, #4]
  tp->queue.next             = cp;
    1a38:	602a      	str	r2, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
    1a3a:	606b      	str	r3, [r5, #4]
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
    1a3c:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
    1a3e:	601d      	str	r5, [r3, #0]
  cp->queue.prev             = tp;
    1a40:	6055      	str	r5, [r2, #4]
      ctp->u.wtmtxp = mp;
    1a42:	626c      	str	r4, [r5, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
    1a44:	f7ff fc84 	bl	1350 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
    1a48:	68a3      	ldr	r3, [r4, #8]
    1a4a:	42ab      	cmp	r3, r5
    1a4c:	d002      	beq.n	1a54 <chMtxLockS+0x64>
    1a4e:	482d      	ldr	r0, [pc, #180]	; (1b04 <chMtxLockS+0x114>)
    1a50:	f7ff fa76 	bl	f40 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
    1a54:	6bab      	ldr	r3, [r5, #56]	; 0x38
    1a56:	42a3      	cmp	r3, r4
    1a58:	d002      	beq.n	1a60 <chMtxLockS+0x70>
    1a5a:	482a      	ldr	r0, [pc, #168]	; (1b04 <chMtxLockS+0x114>)
    1a5c:	f7ff fa70 	bl	f40 <chSysHalt>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
    1a60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  tp->queue.prev->queue.next = tp->queue.next;
    1a62:	6843      	ldr	r3, [r0, #4]
    1a64:	6801      	ldr	r1, [r0, #0]
    1a66:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
    1a68:	6801      	ldr	r1, [r0, #0]
    1a6a:	604b      	str	r3, [r1, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
    1a6c:	6a41      	ldr	r1, [r0, #36]	; 0x24
    1a6e:	000b      	movs	r3, r1
    1a70:	e002      	b.n	1a78 <chMtxLockS+0x88>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1a72:	689e      	ldr	r6, [r3, #8]
    1a74:	4296      	cmp	r6, r2
    1a76:	d33b      	bcc.n	1af0 <chMtxLockS+0x100>
    cp = cp->queue.next;
    1a78:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1a7a:	4299      	cmp	r1, r3
    1a7c:	d1f9      	bne.n	1a72 <chMtxLockS+0x82>
  tp->queue.prev             = cp->queue.prev;
    1a7e:	684b      	ldr	r3, [r1, #4]
  tp->queue.next             = cp;
    1a80:	6001      	str	r1, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
    1a82:	6043      	str	r3, [r0, #4]
  tp->queue.prev->queue.next = tp;
    1a84:	6018      	str	r0, [r3, #0]
  cp->queue.prev             = tp;
    1a86:	6048      	str	r0, [r1, #4]
    1a88:	e7cb      	b.n	1a22 <chMtxLockS+0x32>
          tp->state = CH_STATE_CURRENT;
    1a8a:	2301      	movs	r3, #1
    1a8c:	5583      	strb	r3, [r0, r6]
  tp->queue.prev->queue.next = tp->queue.next;
    1a8e:	6843      	ldr	r3, [r0, #4]
    1a90:	6802      	ldr	r2, [r0, #0]
    1a92:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
    1a94:	6802      	ldr	r2, [r0, #0]
    1a96:	6053      	str	r3, [r2, #4]
          (void) chSchReadyI(queue_dequeue(tp));
    1a98:	f7ff fbda 	bl	1250 <chSchReadyI>
          break;
    1a9c:	e7c1      	b.n	1a22 <chMtxLockS+0x32>
    cp = cp->queue.next;
    1a9e:	001a      	movs	r2, r3
    1aa0:	e7c9      	b.n	1a36 <chMtxLockS+0x46>
    mp->next = ctp->mtxlist;
    1aa2:	6bab      	ldr	r3, [r5, #56]	; 0x38
    mp->owner = ctp;
    1aa4:	60a5      	str	r5, [r4, #8]
    mp->next = ctp->mtxlist;
    1aa6:	60e3      	str	r3, [r4, #12]
    ctp->mtxlist = mp;
    1aa8:	63ac      	str	r4, [r5, #56]	; 0x38
}
    1aaa:	e7d9      	b.n	1a60 <chMtxLockS+0x70>
  tp->queue.prev->queue.next = tp->queue.next;
    1aac:	6843      	ldr	r3, [r0, #4]
    1aae:	6801      	ldr	r1, [r0, #0]
    1ab0:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
    1ab2:	6801      	ldr	r1, [r0, #0]
    1ab4:	604b      	str	r3, [r1, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
    1ab6:	6a41      	ldr	r1, [r0, #36]	; 0x24
    1ab8:	468c      	mov	ip, r1
    1aba:	000b      	movs	r3, r1
    1abc:	e002      	b.n	1ac4 <chMtxLockS+0xd4>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1abe:	689f      	ldr	r7, [r3, #8]
    1ac0:	4297      	cmp	r7, r2
    1ac2:	d313      	bcc.n	1aec <chMtxLockS+0xfc>
    cp = cp->queue.next;
    1ac4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
    1ac6:	4299      	cmp	r1, r3
    1ac8:	d1f9      	bne.n	1abe <chMtxLockS+0xce>
  tp->queue.next             = cp;
    1aca:	4663      	mov	r3, ip
    1acc:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
    1ace:	685b      	ldr	r3, [r3, #4]
      while (tp->prio < ctp->prio) {
    1ad0:	68aa      	ldr	r2, [r5, #8]
    1ad2:	6043      	str	r3, [r0, #4]
  tp->queue.prev->queue.next = tp;
    1ad4:	6018      	str	r0, [r3, #0]
  cp->queue.prev             = tp;
    1ad6:	4663      	mov	r3, ip
    1ad8:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
    1ada:	6888      	ldr	r0, [r1, #8]
      while (tp->prio < ctp->prio) {
    1adc:	6883      	ldr	r3, [r0, #8]
    1ade:	4293      	cmp	r3, r2
    1ae0:	d397      	bcc.n	1a12 <chMtxLockS+0x22>
    1ae2:	e79e      	b.n	1a22 <chMtxLockS+0x32>
  chDbgCheck(mp != NULL);
    1ae4:	4807      	ldr	r0, [pc, #28]	; (1b04 <chMtxLockS+0x114>)
    1ae6:	f7ff fa2b 	bl	f40 <chSysHalt>
    1aea:	e78a      	b.n	1a02 <chMtxLockS+0x12>
    cp = cp->queue.next;
    1aec:	469c      	mov	ip, r3
    1aee:	e7ec      	b.n	1aca <chMtxLockS+0xda>
    1af0:	0019      	movs	r1, r3
  tp->queue.prev             = cp->queue.prev;
    1af2:	684b      	ldr	r3, [r1, #4]
  tp->queue.next             = cp;
    1af4:	6001      	str	r1, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
    1af6:	6043      	str	r3, [r0, #4]
  tp->queue.prev->queue.next = tp;
    1af8:	6018      	str	r0, [r3, #0]
  cp->queue.prev             = tp;
    1afa:	6048      	str	r0, [r1, #4]
    1afc:	e791      	b.n	1a22 <chMtxLockS+0x32>
    1afe:	46c0      	nop			; (mov r8, r8)
    1b00:	200000d8 	.word	0x200000d8
    1b04:	00007cb4 	.word	0x00007cb4
	...

00001b10 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
    1b10:	b510      	push	{r4, lr}
    1b12:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
    1b14:	b672      	cpsid	i
  _dbg_check_lock();
    1b16:	f7ff fa63 	bl	fe0 <_dbg_check_lock>
  chMtxLockS(mp);
    1b1a:	0020      	movs	r0, r4
    1b1c:	f7ff ff68 	bl	19f0 <chMtxLockS>
  _dbg_check_unlock();
    1b20:	f7ff fa76 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1b24:	4b07      	ldr	r3, [pc, #28]	; (1b44 <chMtxLock+0x34>)
    1b26:	681a      	ldr	r2, [r3, #0]
    1b28:	429a      	cmp	r2, r3
    1b2a:	d004      	beq.n	1b36 <chMtxLock+0x26>
    1b2c:	699b      	ldr	r3, [r3, #24]
    1b2e:	6899      	ldr	r1, [r3, #8]
    1b30:	6893      	ldr	r3, [r2, #8]
    1b32:	4299      	cmp	r1, r3
    1b34:	d301      	bcc.n	1b3a <chMtxLock+0x2a>
  __ASM volatile ("cpsie i" : : : "memory");
    1b36:	b662      	cpsie	i
}
    1b38:	bd10      	pop	{r4, pc}
    1b3a:	4803      	ldr	r0, [pc, #12]	; (1b48 <chMtxLock+0x38>)
    1b3c:	f7ff fa00 	bl	f40 <chSysHalt>
    1b40:	e7f9      	b.n	1b36 <chMtxLock+0x26>
    1b42:	46c0      	nop			; (mov r8, r8)
    1b44:	200000d8 	.word	0x200000d8
    1b48:	00007c98 	.word	0x00007c98
    1b4c:	00000000 	.word	0x00000000

00001b50 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
    1b50:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b52:	46c6      	mov	lr, r8
  thread_t *ctp = currp;
    1b54:	4b2d      	ldr	r3, [pc, #180]	; (1c0c <chMtxUnlock+0xbc>)
void chMtxUnlock(mutex_t *mp) {
    1b56:	b500      	push	{lr}
    1b58:	1e05      	subs	r5, r0, #0
  thread_t *ctp = currp;
    1b5a:	4698      	mov	r8, r3
    1b5c:	699e      	ldr	r6, [r3, #24]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
    1b5e:	d051      	beq.n	1c04 <chMtxUnlock+0xb4>
  __ASM volatile ("cpsid i" : : : "memory");
    1b60:	b672      	cpsid	i
  _dbg_check_lock();
    1b62:	f7ff fa3d 	bl	fe0 <_dbg_check_lock>

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
    1b66:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    1b68:	2b00      	cmp	r3, #0
    1b6a:	d046      	beq.n	1bfa <chMtxUnlock+0xaa>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
    1b6c:	689a      	ldr	r2, [r3, #8]
    1b6e:	42b2      	cmp	r2, r6
    1b70:	d003      	beq.n	1b7a <chMtxUnlock+0x2a>
    1b72:	4827      	ldr	r0, [pc, #156]	; (1c10 <chMtxUnlock+0xc0>)
    1b74:	f7ff f9e4 	bl	f40 <chSysHalt>
    1b78:	6bb3      	ldr	r3, [r6, #56]	; 0x38
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
    1b7a:	429d      	cmp	r5, r3
    1b7c:	d002      	beq.n	1b84 <chMtxUnlock+0x34>
    1b7e:	4824      	ldr	r0, [pc, #144]	; (1c10 <chMtxUnlock+0xc0>)
    1b80:	f7ff f9de 	bl	f40 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
    1b84:	68eb      	ldr	r3, [r5, #12]
    1b86:	63b3      	str	r3, [r6, #56]	; 0x38
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
    1b88:	f7ff fad2 	bl	1130 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
    1b8c:	6828      	ldr	r0, [r5, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1b8e:	4285      	cmp	r5, r0
    1b90:	d030      	beq.n	1bf4 <chMtxUnlock+0xa4>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
    1b92:	6bb4      	ldr	r4, [r6, #56]	; 0x38
      tprio_t newprio = ctp->realprio;
    1b94:	6bf7      	ldr	r7, [r6, #60]	; 0x3c
      while (lmp != NULL) {
    1b96:	2c00      	cmp	r4, #0
    1b98:	d00c      	beq.n	1bb4 <chMtxUnlock+0x64>
    1b9a:	f7ff fac9 	bl	1130 <chDbgCheckClassS>
    1b9e:	6823      	ldr	r3, [r4, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    1ba0:	429c      	cmp	r4, r3
    1ba2:	d003      	beq.n	1bac <chMtxUnlock+0x5c>
    1ba4:	689b      	ldr	r3, [r3, #8]
    1ba6:	429f      	cmp	r7, r3
    1ba8:	d200      	bcs.n	1bac <chMtxUnlock+0x5c>
    1baa:	001f      	movs	r7, r3
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
    1bac:	68e4      	ldr	r4, [r4, #12]
      while (lmp != NULL) {
    1bae:	2c00      	cmp	r4, #0
    1bb0:	d1f3      	bne.n	1b9a <chMtxUnlock+0x4a>
    1bb2:	6828      	ldr	r0, [r5, #0]
  tqp->next             = tp->queue.next;
    1bb4:	6803      	ldr	r3, [r0, #0]
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
    1bb6:	60b7      	str	r7, [r6, #8]
    1bb8:	602b      	str	r3, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
    1bba:	605d      	str	r5, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
    1bbc:	6b83      	ldr	r3, [r0, #56]	; 0x38
      mp->owner = tp;
    1bbe:	60a8      	str	r0, [r5, #8]
      mp->next = tp->mtxlist;
    1bc0:	60eb      	str	r3, [r5, #12]
      tp->mtxlist = mp;
    1bc2:	6385      	str	r5, [r0, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
    1bc4:	f7ff fb44 	bl	1250 <chSchReadyI>
      chSchRescheduleS();
    1bc8:	f7ff fc8a 	bl	14e0 <chSchRescheduleS>
  _dbg_check_unlock();
    1bcc:	f7ff fa20 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1bd0:	4643      	mov	r3, r8
    1bd2:	681b      	ldr	r3, [r3, #0]
    1bd4:	4543      	cmp	r3, r8
    1bd6:	d005      	beq.n	1be4 <chMtxUnlock+0x94>
    1bd8:	4642      	mov	r2, r8
    1bda:	6992      	ldr	r2, [r2, #24]
    1bdc:	689b      	ldr	r3, [r3, #8]
    1bde:	6892      	ldr	r2, [r2, #8]
    1be0:	429a      	cmp	r2, r3
    1be2:	d303      	bcc.n	1bec <chMtxUnlock+0x9c>
  __ASM volatile ("cpsie i" : : : "memory");
    1be4:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
    1be6:	bc04      	pop	{r2}
    1be8:	4690      	mov	r8, r2
    1bea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1bec:	4809      	ldr	r0, [pc, #36]	; (1c14 <chMtxUnlock+0xc4>)
    1bee:	f7ff f9a7 	bl	f40 <chSysHalt>
    1bf2:	e7f7      	b.n	1be4 <chMtxUnlock+0x94>
      mp->owner = NULL;
    1bf4:	2300      	movs	r3, #0
    1bf6:	60ab      	str	r3, [r5, #8]
    1bf8:	e7e8      	b.n	1bcc <chMtxUnlock+0x7c>
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
    1bfa:	4805      	ldr	r0, [pc, #20]	; (1c10 <chMtxUnlock+0xc0>)
    1bfc:	f7ff f9a0 	bl	f40 <chSysHalt>
    1c00:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    1c02:	e7b3      	b.n	1b6c <chMtxUnlock+0x1c>
  chDbgCheck(mp != NULL);
    1c04:	4802      	ldr	r0, [pc, #8]	; (1c10 <chMtxUnlock+0xc0>)
    1c06:	f7ff f99b 	bl	f40 <chSysHalt>
    1c0a:	e7a9      	b.n	1b60 <chMtxUnlock+0x10>
    1c0c:	200000d8 	.word	0x200000d8
    1c10:	00007cc0 	.word	0x00007cc0
    1c14:	00007c98 	.word	0x00007c98
	...

00001c20 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
    1c20:	4b03      	ldr	r3, [pc, #12]	; (1c30 <_core_init+0x10>)
    1c22:	4a04      	ldr	r2, [pc, #16]	; (1c34 <_core_init+0x14>)
    1c24:	601a      	str	r2, [r3, #0]
  endmem  = __heap_end__;
    1c26:	4b04      	ldr	r3, [pc, #16]	; (1c38 <_core_init+0x18>)
    1c28:	4a04      	ldr	r2, [pc, #16]	; (1c3c <_core_init+0x1c>)
    1c2a:	601a      	str	r2, [r3, #0]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  nextmem = &static_heap[0];
  endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
    1c2c:	4770      	bx	lr
    1c2e:	46c0      	nop			; (mov r8, r8)
    1c30:	20000158 	.word	0x20000158
    1c34:	20000ce0 	.word	0x20000ce0
    1c38:	20000154 	.word	0x20000154
    1c3c:	20001800 	.word	0x20001800

00001c40 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    1c40:	b570      	push	{r4, r5, r6, lr}
    1c42:	000d      	movs	r5, r1
    1c44:	0004      	movs	r4, r0
  uint8_t *p;

  chDbgCheckClassI();
    1c46:	f7ff fa5b 	bl	1100 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
    1c4a:	2d00      	cmp	r5, #0
    1c4c:	d013      	beq.n	1c76 <chCoreAllocAlignedI+0x36>
    1c4e:	1e6b      	subs	r3, r5, #1
    1c50:	421d      	tst	r5, r3
    1c52:	d110      	bne.n	1c76 <chCoreAllocAlignedI+0x36>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    1c54:	490b      	ldr	r1, [pc, #44]	; (1c84 <chCoreAllocAlignedI+0x44>)
  size = MEM_ALIGN_NEXT(size, align);
    1c56:	1e63      	subs	r3, r4, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    1c58:	680a      	ldr	r2, [r1, #0]
  size = MEM_ALIGN_NEXT(size, align);
    1c5a:	4268      	negs	r0, r5
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    1c5c:	3a01      	subs	r2, #1
  size = MEM_ALIGN_NEXT(size, align);
    1c5e:	195b      	adds	r3, r3, r5
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    1c60:	1955      	adds	r5, r2, r5

  if (((size_t)endmem - (size_t)p) < size) {
    1c62:	4a09      	ldr	r2, [pc, #36]	; (1c88 <chCoreAllocAlignedI+0x48>)
  size = MEM_ALIGN_NEXT(size, align);
    1c64:	4003      	ands	r3, r0
  if (((size_t)endmem - (size_t)p) < size) {
    1c66:	6812      	ldr	r2, [r2, #0]
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    1c68:	4028      	ands	r0, r5
  if (((size_t)endmem - (size_t)p) < size) {
    1c6a:	1a12      	subs	r2, r2, r0
    1c6c:	429a      	cmp	r2, r3
    1c6e:	d306      	bcc.n	1c7e <chCoreAllocAlignedI+0x3e>
    return NULL;
  }
  nextmem = p + size;
    1c70:	18c3      	adds	r3, r0, r3
    1c72:	600b      	str	r3, [r1, #0]

  return p;
}
    1c74:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
    1c76:	4805      	ldr	r0, [pc, #20]	; (1c8c <chCoreAllocAlignedI+0x4c>)
    1c78:	f7ff f962 	bl	f40 <chSysHalt>
    1c7c:	e7ea      	b.n	1c54 <chCoreAllocAlignedI+0x14>
    return NULL;
    1c7e:	2000      	movs	r0, #0
    1c80:	e7f8      	b.n	1c74 <chCoreAllocAlignedI+0x34>
    1c82:	46c0      	nop			; (mov r8, r8)
    1c84:	20000158 	.word	0x20000158
    1c88:	20000154 	.word	0x20000154
    1c8c:	00007cd8 	.word	0x00007cd8

00001c90 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    1c90:	b570      	push	{r4, r5, r6, lr}
    1c92:	0004      	movs	r4, r0
    1c94:	000d      	movs	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
    1c96:	b672      	cpsid	i
  _dbg_check_lock();
    1c98:	f7ff f9a2 	bl	fe0 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocAlignedI(size, align);
    1c9c:	0029      	movs	r1, r5
    1c9e:	0020      	movs	r0, r4
    1ca0:	f7ff ffce 	bl	1c40 <chCoreAllocAlignedI>
    1ca4:	0004      	movs	r4, r0
  _dbg_check_unlock();
    1ca6:	f7ff f9b3 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1caa:	4b08      	ldr	r3, [pc, #32]	; (1ccc <chCoreAllocAligned+0x3c>)
    1cac:	681a      	ldr	r2, [r3, #0]
    1cae:	429a      	cmp	r2, r3
    1cb0:	d004      	beq.n	1cbc <chCoreAllocAligned+0x2c>
    1cb2:	699b      	ldr	r3, [r3, #24]
    1cb4:	6899      	ldr	r1, [r3, #8]
    1cb6:	6893      	ldr	r3, [r2, #8]
    1cb8:	4299      	cmp	r1, r3
    1cba:	d302      	bcc.n	1cc2 <chCoreAllocAligned+0x32>
  __ASM volatile ("cpsie i" : : : "memory");
    1cbc:	b662      	cpsie	i
  chSysUnlock();

  return p;
}
    1cbe:	0020      	movs	r0, r4
    1cc0:	bd70      	pop	{r4, r5, r6, pc}
    1cc2:	4803      	ldr	r0, [pc, #12]	; (1cd0 <chCoreAllocAligned+0x40>)
    1cc4:	f7ff f93c 	bl	f40 <chSysHalt>
    1cc8:	e7f8      	b.n	1cbc <chCoreAllocAligned+0x2c>
    1cca:	46c0      	nop			; (mov r8, r8)
    1ccc:	200000d8 	.word	0x200000d8
    1cd0:	00007ccc 	.word	0x00007ccc
	...

00001ce0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    1ce0:	4805      	ldr	r0, [pc, #20]	; (1cf8 <_heap_init+0x18>)
    1ce2:	4b06      	ldr	r3, [pc, #24]	; (1cfc <_heap_init+0x1c>)
void _heap_init(void) {
    1ce4:	b510      	push	{r4, lr}
  default_heap.provider = chCoreAllocAligned;
    1ce6:	6003      	str	r3, [r0, #0]
  H_NEXT(&default_heap.header) = NULL;
    1ce8:	2300      	movs	r3, #0
    1cea:	6083      	str	r3, [r0, #8]
  H_PAGES(&default_heap.header) = 0;
    1cec:	60c3      	str	r3, [r0, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
    1cee:	3010      	adds	r0, #16
    1cf0:	f7ff fe6e 	bl	19d0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
    1cf4:	bd10      	pop	{r4, pc}
    1cf6:	46c0      	nop			; (mov r8, r8)
    1cf8:	20000160 	.word	0x20000160
    1cfc:	00001c91 	.word	0x00001c91

00001d00 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
    1d00:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d02:	46c6      	mov	lr, r8
    1d04:	0005      	movs	r5, r0
    1d06:	b500      	push	{lr}
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
    1d08:	2800      	cmp	r0, #0
    1d0a:	d038      	beq.n	1d7e <chHeapFree+0x7e>
    1d0c:	0743      	lsls	r3, r0, #29
    1d0e:	d136      	bne.n	1d7e <chHeapFree+0x7e>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
    1d10:	3d08      	subs	r5, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
    1d12:	682f      	ldr	r7, [r5, #0]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
    1d14:	686b      	ldr	r3, [r5, #4]
  qp = &heapp->header;
    1d16:	003e      	movs	r6, r7
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
    1d18:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
    1d1a:	08db      	lsrs	r3, r3, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
    1d1c:	3710      	adds	r7, #16
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
    1d1e:	606b      	str	r3, [r5, #4]
  H_LOCK(heapp);
    1d20:	0038      	movs	r0, r7
    1d22:	f7ff fef5 	bl	1b10 <chMtxLock>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
    1d26:	4b23      	ldr	r3, [pc, #140]	; (1db4 <chHeapFree+0xb4>)
  qp = &heapp->header;
    1d28:	3608      	adds	r6, #8
    1d2a:	0034      	movs	r4, r6
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
    1d2c:	4698      	mov	r8, r3
    1d2e:	42ac      	cmp	r4, r5
    1d30:	d805      	bhi.n	1d3e <chHeapFree+0x3e>
    1d32:	6863      	ldr	r3, [r4, #4]
    1d34:	3301      	adds	r3, #1
    1d36:	00db      	lsls	r3, r3, #3
    1d38:	18e3      	adds	r3, r4, r3
    1d3a:	429d      	cmp	r5, r3
    1d3c:	d323      	bcc.n	1d86 <chHeapFree+0x86>
    1d3e:	6823      	ldr	r3, [r4, #0]

    if (((qp == &heapp->header) || (hp > qp)) &&
    1d40:	42b4      	cmp	r4, r6
    1d42:	d001      	beq.n	1d48 <chHeapFree+0x48>
    1d44:	42ac      	cmp	r4, r5
    1d46:	d203      	bcs.n	1d50 <chHeapFree+0x50>
    1d48:	2b00      	cmp	r3, #0
    1d4a:	d003      	beq.n	1d54 <chHeapFree+0x54>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
    1d4c:	429d      	cmp	r5, r3
    1d4e:	d301      	bcc.n	1d54 <chHeapFree+0x54>
void chHeapFree(void *p) {
    1d50:	001c      	movs	r4, r3
    1d52:	e7ec      	b.n	1d2e <chHeapFree+0x2e>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
    1d54:	602b      	str	r3, [r5, #0]
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
    1d56:	686b      	ldr	r3, [r5, #4]
      H_NEXT(qp) = hp;
    1d58:	6025      	str	r5, [r4, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
    1d5a:	1c5a      	adds	r2, r3, #1
    1d5c:	00d3      	lsls	r3, r2, #3
    1d5e:	6829      	ldr	r1, [r5, #0]
    1d60:	18eb      	adds	r3, r5, r3
    1d62:	428b      	cmp	r3, r1
    1d64:	d013      	beq.n	1d8e <chHeapFree+0x8e>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
    1d66:	6862      	ldr	r2, [r4, #4]
    1d68:	1c53      	adds	r3, r2, #1
    1d6a:	00db      	lsls	r3, r3, #3
    1d6c:	18e3      	adds	r3, r4, r3
    1d6e:	429d      	cmp	r5, r3
    1d70:	d019      	beq.n	1da6 <chHeapFree+0xa6>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
    1d72:	0038      	movs	r0, r7
    1d74:	f7ff feec 	bl	1b50 <chMtxUnlock>

  return;
}
    1d78:	bc04      	pop	{r2}
    1d7a:	4690      	mov	r8, r2
    1d7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
    1d7e:	480d      	ldr	r0, [pc, #52]	; (1db4 <chHeapFree+0xb4>)
    1d80:	f7ff f8de 	bl	f40 <chSysHalt>
    1d84:	e7c4      	b.n	1d10 <chHeapFree+0x10>
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
    1d86:	4640      	mov	r0, r8
    1d88:	f7ff f8da 	bl	f40 <chSysHalt>
    1d8c:	e7d7      	b.n	1d3e <chHeapFree+0x3e>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
    1d8e:	6859      	ldr	r1, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
    1d90:	681b      	ldr	r3, [r3, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
    1d92:	468c      	mov	ip, r1
    1d94:	4462      	add	r2, ip
    1d96:	606a      	str	r2, [r5, #4]
      if ((H_LIMIT(qp) == hp)) {
    1d98:	6862      	ldr	r2, [r4, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
    1d9a:	602b      	str	r3, [r5, #0]
      if ((H_LIMIT(qp) == hp)) {
    1d9c:	1c53      	adds	r3, r2, #1
    1d9e:	00db      	lsls	r3, r3, #3
    1da0:	18e3      	adds	r3, r4, r3
    1da2:	429d      	cmp	r5, r3
    1da4:	d1e5      	bne.n	1d72 <chHeapFree+0x72>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
    1da6:	686b      	ldr	r3, [r5, #4]
    1da8:	3301      	adds	r3, #1
    1daa:	189a      	adds	r2, r3, r2
        H_NEXT(qp) = H_NEXT(hp);
    1dac:	682b      	ldr	r3, [r5, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
    1dae:	6062      	str	r2, [r4, #4]
        H_NEXT(qp) = H_NEXT(hp);
    1db0:	6023      	str	r3, [r4, #0]
    1db2:	e7de      	b.n	1d72 <chHeapFree+0x72>
    1db4:	00007cec 	.word	0x00007cec
	...

00001dc0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
    1dc0:	b570      	push	{r4, r5, r6, lr}
    1dc2:	0004      	movs	r4, r0
    1dc4:	000d      	movs	r5, r1
  struct pool_header *php = objp;

  chDbgCheckClassI();
    1dc6:	f7ff f99b 	bl	1100 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
    1dca:	2c00      	cmp	r4, #0
    1dcc:	d005      	beq.n	1dda <chPoolFreeI+0x1a>
    1dce:	2d00      	cmp	r5, #0
    1dd0:	d003      	beq.n	1dda <chPoolFreeI+0x1a>

  php->next = mp->next;
    1dd2:	6823      	ldr	r3, [r4, #0]
    1dd4:	602b      	str	r3, [r5, #0]
  mp->next = php;
    1dd6:	6025      	str	r5, [r4, #0]
}
    1dd8:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck((mp != NULL) && (objp != NULL));
    1dda:	4802      	ldr	r0, [pc, #8]	; (1de4 <chPoolFreeI+0x24>)
    1ddc:	f7ff f8b0 	bl	f40 <chSysHalt>
    1de0:	e7f7      	b.n	1dd2 <chPoolFreeI+0x12>
    1de2:	46c0      	nop			; (mov r8, r8)
    1de4:	00007d04 	.word	0x00007d04
	...

00001df0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
    1df0:	b570      	push	{r4, r5, r6, lr}
    1df2:	0004      	movs	r4, r0
    1df4:	000d      	movs	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
    1df6:	b672      	cpsid	i
  _dbg_check_lock();
    1df8:	f7ff f8f2 	bl	fe0 <_dbg_check_lock>

  chSysLock();
  chPoolFreeI(mp, objp);
    1dfc:	0029      	movs	r1, r5
    1dfe:	0020      	movs	r0, r4
    1e00:	f7ff ffde 	bl	1dc0 <chPoolFreeI>
  _dbg_check_unlock();
    1e04:	f7ff f904 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    1e08:	4b07      	ldr	r3, [pc, #28]	; (1e28 <chPoolFree+0x38>)
    1e0a:	681a      	ldr	r2, [r3, #0]
    1e0c:	429a      	cmp	r2, r3
    1e0e:	d004      	beq.n	1e1a <chPoolFree+0x2a>
    1e10:	699b      	ldr	r3, [r3, #24]
    1e12:	6899      	ldr	r1, [r3, #8]
    1e14:	6893      	ldr	r3, [r2, #8]
    1e16:	4299      	cmp	r1, r3
    1e18:	d301      	bcc.n	1e1e <chPoolFree+0x2e>
  __ASM volatile ("cpsie i" : : : "memory");
    1e1a:	b662      	cpsie	i
  chSysUnlock();
}
    1e1c:	bd70      	pop	{r4, r5, r6, pc}
    1e1e:	4803      	ldr	r0, [pc, #12]	; (1e2c <chPoolFree+0x3c>)
    1e20:	f7ff f88e 	bl	f40 <chSysHalt>
    1e24:	e7f9      	b.n	1e1a <chPoolFree+0x2a>
    1e26:	46c0      	nop			; (mov r8, r8)
    1e28:	200000d8 	.word	0x200000d8
    1e2c:	00007cf8 	.word	0x00007cf8

00001e30 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
    1e30:	b580      	push	{r7, lr}
    1e32:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    1e34:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
    1e38:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    1e3a:	f383 8809 	msr	PSP, r3
  __ASM volatile ("cpsie i" : : : "memory");
    1e3e:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
    1e40:	46bd      	mov	sp, r7
    1e42:	bd80      	pop	{r7, pc}
	...

00001e50 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
    1e50:	b5b0      	push	{r4, r5, r7, lr}
    1e52:	af00      	add	r7, sp, #0

  if (lr != (regarm_t)0xFFFFFFF1U) {
    1e54:	300f      	adds	r0, #15
    1e56:	d00e      	beq.n	1e76 <_port_irq_epilogue+0x26>
  __ASM volatile ("cpsid i" : : : "memory");
    1e58:	b672      	cpsid	i
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
    1e5a:	f3ef 8409 	mrs	r4, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
    1e5e:	3c20      	subs	r4, #32
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    1e60:	f384 8809 	msr	PSP, r4

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
    1e64:	2380      	movs	r3, #128	; 0x80
    1e66:	045b      	lsls	r3, r3, #17
    1e68:	61e3      	str	r3, [r4, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
    1e6a:	f7ff fb01 	bl	1470 <chSchIsPreemptionRequired>
    1e6e:	2800      	cmp	r0, #0
    1e70:	d103      	bne.n	1e7a <_port_irq_epilogue+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    1e72:	4b03      	ldr	r3, [pc, #12]	; (1e80 <_port_irq_epilogue+0x30>)
    1e74:	61a3      	str	r3, [r4, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
    1e76:	46bd      	mov	sp, r7
    1e78:	bdb0      	pop	{r4, r5, r7, pc}
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    1e7a:	4b02      	ldr	r3, [pc, #8]	; (1e84 <_port_irq_epilogue+0x34>)
    1e7c:	61a3      	str	r3, [r4, #24]
    1e7e:	e7fa      	b.n	1e76 <_port_irq_epilogue+0x26>
    1e80:	0000051c 	.word	0x0000051c
    1e84:	00000511 	.word	0x00000511
	...

00001e90 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
    1e90:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
    1e92:	f000 fd9d 	bl	29d0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    1e96:	4805      	ldr	r0, [pc, #20]	; (1eac <halInit+0x1c>)
    1e98:	f000 fec2 	bl	2c20 <_pal_lld_init>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
    1e9c:	f000 f960 	bl	2160 <usbInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    1ea0:	f001 fb26 	bl	34f0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    1ea4:	f000 f804 	bl	1eb0 <stInit>
#endif
}
    1ea8:	bd10      	pop	{r4, pc}
    1eaa:	46c0      	nop			; (mov r8, r8)
    1eac:	00007ef0 	.word	0x00007ef0

00001eb0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
    1eb0:	b510      	push	{r4, lr}

  st_lld_init();
    1eb2:	f000 feed 	bl	2c90 <st_lld_init>
}
    1eb6:	bd10      	pop	{r4, pc}
	...

00001ec0 <obqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, bool suspended, uint8_t *bp,
                   size_t size, size_t n, bqnotify_t onfy, void *link) {
    1ec0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1ec2:	46c6      	mov	lr, r8
    1ec4:	b500      	push	{lr}
    1ec6:	0004      	movs	r4, r0
    1ec8:	4688      	mov	r8, r1
    1eca:	0015      	movs	r5, r2
    1ecc:	001f      	movs	r7, r3
    1ece:	9e06      	ldr	r6, [sp, #24]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));
    1ed0:	2800      	cmp	r0, #0
    1ed2:	d01c      	beq.n	1f0e <obqObjectInit+0x4e>
    1ed4:	2a00      	cmp	r2, #0
    1ed6:	d01a      	beq.n	1f0e <obqObjectInit+0x4e>
    1ed8:	2b01      	cmp	r3, #1
    1eda:	d918      	bls.n	1f0e <obqObjectInit+0x4e>

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
    1edc:	4643      	mov	r3, r8
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
    1ede:	0032      	movs	r2, r6
  obqp->suspended = suspended;
    1ee0:	7223      	strb	r3, [r4, #8]
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
    1ee2:	2300      	movs	r3, #0
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
    1ee4:	3704      	adds	r7, #4
    1ee6:	437a      	muls	r2, r7
  obqp->ptr       = NULL;
    1ee8:	62a3      	str	r3, [r4, #40]	; 0x28
  obqp->top       = NULL;
    1eea:	62e3      	str	r3, [r4, #44]	; 0x2c
  obqp->notify    = onfy;
    1eec:	9b07      	ldr	r3, [sp, #28]
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
    1eee:	18aa      	adds	r2, r5, r2
  obqp->notify    = onfy;
    1ef0:	6323      	str	r3, [r4, #48]	; 0x30
  obqp->link      = link;
    1ef2:	9b08      	ldr	r3, [sp, #32]
  obqp->bcounter  = n;
    1ef4:	60e6      	str	r6, [r4, #12]
  obqp->brdptr    = bp;
    1ef6:	6165      	str	r5, [r4, #20]
  obqp->bwrptr    = bp;
    1ef8:	6125      	str	r5, [r4, #16]
  obqp->bsize     = size + sizeof (size_t);
    1efa:	61e7      	str	r7, [r4, #28]
  obqp->bn        = n;
    1efc:	6226      	str	r6, [r4, #32]
  obqp->buffers   = bp;
    1efe:	6265      	str	r5, [r4, #36]	; 0x24
  tqp->next = (thread_t *)tqp;
    1f00:	6024      	str	r4, [r4, #0]
  tqp->prev = (thread_t *)tqp;
    1f02:	6064      	str	r4, [r4, #4]
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
    1f04:	61a2      	str	r2, [r4, #24]
  obqp->link      = link;
    1f06:	6363      	str	r3, [r4, #52]	; 0x34
}
    1f08:	bc04      	pop	{r2}
    1f0a:	4690      	mov	r8, r2
    1f0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));
    1f0e:	4802      	ldr	r0, [pc, #8]	; (1f18 <obqObjectInit+0x58>)
    1f10:	f7ff f816 	bl	f40 <chSysHalt>
    1f14:	e7e2      	b.n	1edc <obqObjectInit+0x1c>
    1f16:	46c0      	nop			; (mov r8, r8)
    1f18:	00007d1c 	.word	0x00007d1c
    1f1c:	00000000 	.word	0x00000000

00001f20 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
    1f20:	b570      	push	{r4, r5, r6, lr}
    1f22:	0004      	movs	r4, r0
    1f24:	000d      	movs	r5, r1

  osalDbgCheckClassI();
    1f26:	f7ff f8eb 	bl	1100 <chDbgCheckClassI>

  if (obqIsEmptyI(obqp)) {
    1f2a:	6960      	ldr	r0, [r4, #20]
    1f2c:	6923      	ldr	r3, [r4, #16]
    1f2e:	4283      	cmp	r3, r0
    1f30:	d002      	beq.n	1f38 <obqGetFullBufferI+0x18>
    return NULL;
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
    1f32:	c808      	ldmia	r0!, {r3}
    1f34:	602b      	str	r3, [r5, #0]

  return obqp->brdptr + sizeof (size_t);
}
    1f36:	bd70      	pop	{r4, r5, r6, pc}
  if (obqIsEmptyI(obqp)) {
    1f38:	68e3      	ldr	r3, [r4, #12]
    1f3a:	2b00      	cmp	r3, #0
    1f3c:	d0f9      	beq.n	1f32 <obqGetFullBufferI+0x12>
    return NULL;
    1f3e:	2000      	movs	r0, #0
    1f40:	e7f9      	b.n	1f36 <obqGetFullBufferI+0x16>
    1f42:	46c0      	nop			; (mov r8, r8)
	...

00001f50 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
    1f50:	b510      	push	{r4, lr}
    1f52:	0004      	movs	r4, r0

  osalDbgCheckClassI();
    1f54:	f7ff f8d4 	bl	1100 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
    1f58:	6963      	ldr	r3, [r4, #20]
    1f5a:	6922      	ldr	r2, [r4, #16]
    1f5c:	429a      	cmp	r2, r3
    1f5e:	d010      	beq.n	1f82 <obqReleaseEmptyBufferI+0x32>

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
    1f60:	68e2      	ldr	r2, [r4, #12]
    1f62:	3201      	adds	r2, #1
    1f64:	60e2      	str	r2, [r4, #12]
  obqp->brdptr += obqp->bsize;
    1f66:	69e2      	ldr	r2, [r4, #28]
    1f68:	4694      	mov	ip, r2
  if (obqp->brdptr >= obqp->btop) {
    1f6a:	69a2      	ldr	r2, [r4, #24]
  obqp->brdptr += obqp->bsize;
    1f6c:	4463      	add	r3, ip
    1f6e:	6163      	str	r3, [r4, #20]
  if (obqp->brdptr >= obqp->btop) {
    1f70:	4293      	cmp	r3, r2
    1f72:	d301      	bcc.n	1f78 <obqReleaseEmptyBufferI+0x28>
    obqp->brdptr = obqp->buffers;
    1f74:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1f76:	6163      	str	r3, [r4, #20]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
    1f78:	2100      	movs	r1, #0
    1f7a:	0020      	movs	r0, r4
    1f7c:	f7ff fca8 	bl	18d0 <chThdDequeueNextI>
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
}
    1f80:	bd10      	pop	{r4, pc}
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
    1f82:	68e2      	ldr	r2, [r4, #12]
    1f84:	2a00      	cmp	r2, #0
    1f86:	d0eb      	beq.n	1f60 <obqReleaseEmptyBufferI+0x10>
    1f88:	4802      	ldr	r0, [pc, #8]	; (1f94 <obqReleaseEmptyBufferI+0x44>)
    1f8a:	f7fe ffd9 	bl	f40 <chSysHalt>
    1f8e:	6963      	ldr	r3, [r4, #20]
    1f90:	e7e6      	b.n	1f60 <obqReleaseEmptyBufferI+0x10>
    1f92:	46c0      	nop			; (mov r8, r8)
    1f94:	00007d2c 	.word	0x00007d2c
	...

00001fa0 <obqGetEmptyBufferTimeoutS>:
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                systime_t timeout) {
    1fa0:	b570      	push	{r4, r5, r6, lr}
    1fa2:	0004      	movs	r4, r0
    1fa4:	000d      	movs	r5, r1

  osalDbgCheckClassS();
    1fa6:	f7ff f8c3 	bl	1130 <chDbgCheckClassS>

  while (obqIsFullI(obqp)) {
    1faa:	e008      	b.n	1fbe <obqGetEmptyBufferTimeoutS+0x1e>
    if (obqp->suspended) {
    1fac:	7a23      	ldrb	r3, [r4, #8]
    1fae:	2b00      	cmp	r3, #0
    1fb0:	d114      	bne.n	1fdc <obqGetEmptyBufferTimeoutS+0x3c>
  return chThdEnqueueTimeoutS(tqp, time);
    1fb2:	0029      	movs	r1, r5
    1fb4:	0020      	movs	r0, r4
    1fb6:	f7ff fc73 	bl	18a0 <chThdEnqueueTimeoutS>
      return MSG_RESET;
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
    if (msg < MSG_OK) {
    1fba:	2800      	cmp	r0, #0
    1fbc:	db0d      	blt.n	1fda <obqGetEmptyBufferTimeoutS+0x3a>
  while (obqIsFullI(obqp)) {
    1fbe:	68e3      	ldr	r3, [r4, #12]
    1fc0:	2b00      	cmp	r3, #0
    1fc2:	d0f3      	beq.n	1fac <obqGetEmptyBufferTimeoutS+0xc>
      return msg;
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
    1fc4:	68e3      	ldr	r3, [r4, #12]
    1fc6:	2b00      	cmp	r3, #0
    1fc8:	d00b      	beq.n	1fe2 <obqGetEmptyBufferTimeoutS+0x42>

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
    1fca:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
    1fcc:	2000      	movs	r0, #0
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
    1fce:	1d1a      	adds	r2, r3, #4
    1fd0:	62a2      	str	r2, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
    1fd2:	69e2      	ldr	r2, [r4, #28]
    1fd4:	4694      	mov	ip, r2
    1fd6:	4463      	add	r3, ip
    1fd8:	62e3      	str	r3, [r4, #44]	; 0x2c

  return MSG_OK;
}
    1fda:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
    1fdc:	2002      	movs	r0, #2
    1fde:	4240      	negs	r0, r0
    1fe0:	e7fb      	b.n	1fda <obqGetEmptyBufferTimeoutS+0x3a>
  osalDbgAssert(!obqIsFullI(obqp), "still full");
    1fe2:	4802      	ldr	r0, [pc, #8]	; (1fec <obqGetEmptyBufferTimeoutS+0x4c>)
    1fe4:	f7fe ffac 	bl	f40 <chSysHalt>
    1fe8:	e7ef      	b.n	1fca <obqGetEmptyBufferTimeoutS+0x2a>
    1fea:	46c0      	nop			; (mov r8, r8)
    1fec:	00007d44 	.word	0x00007d44

00001ff0 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
    1ff0:	b570      	push	{r4, r5, r6, lr}
    1ff2:	000d      	movs	r5, r1
    1ff4:	0004      	movs	r4, r0

  osalDbgCheckClassS();
    1ff6:	f7ff f89b 	bl	1130 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
    1ffa:	2d00      	cmp	r5, #0
    1ffc:	d01c      	beq.n	2038 <__ram0_size__+0x38>
    1ffe:	69e3      	ldr	r3, [r4, #28]
    2000:	3b04      	subs	r3, #4
    2002:	42ab      	cmp	r3, r5
    2004:	d318      	bcc.n	2038 <__ram0_size__+0x38>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
    2006:	68e3      	ldr	r3, [r4, #12]
    2008:	2b00      	cmp	r3, #0
    200a:	d01b      	beq.n	2044 <__ram0_size__+0x44>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
    200c:	6923      	ldr	r3, [r4, #16]
    200e:	601d      	str	r5, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
    2010:	68e2      	ldr	r2, [r4, #12]
    2012:	3a01      	subs	r2, #1
    2014:	60e2      	str	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
    2016:	69e2      	ldr	r2, [r4, #28]
    2018:	4694      	mov	ip, r2
  if (obqp->bwrptr >= obqp->btop) {
    201a:	69a2      	ldr	r2, [r4, #24]
  obqp->bwrptr += obqp->bsize;
    201c:	4463      	add	r3, ip
    201e:	6123      	str	r3, [r4, #16]
  if (obqp->bwrptr >= obqp->btop) {
    2020:	4293      	cmp	r3, r2
    2022:	d301      	bcc.n	2028 <__ram0_size__+0x28>
    obqp->bwrptr = obqp->buffers;
    2024:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2026:	6123      	str	r3, [r4, #16]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
    2028:	2300      	movs	r3, #0
    202a:	62a3      	str	r3, [r4, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
    202c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    202e:	2b00      	cmp	r3, #0
    2030:	d001      	beq.n	2036 <__ram0_size__+0x36>
    obqp->notify(obqp);
    2032:	0020      	movs	r0, r4
    2034:	4798      	blx	r3
  }
}
    2036:	bd70      	pop	{r4, r5, r6, pc}
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
    2038:	4804      	ldr	r0, [pc, #16]	; (204c <__ram0_size__+0x4c>)
    203a:	f7fe ff81 	bl	f40 <chSysHalt>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
    203e:	68e3      	ldr	r3, [r4, #12]
    2040:	2b00      	cmp	r3, #0
    2042:	d1e3      	bne.n	200c <__ram0_size__+0xc>
    2044:	4801      	ldr	r0, [pc, #4]	; (204c <__ram0_size__+0x4c>)
    2046:	f7fe ff7b 	bl	f40 <chSysHalt>
    204a:	e7df      	b.n	200c <__ram0_size__+0xc>
    204c:	00007d60 	.word	0x00007d60

00002050 <obqPutTimeout>:
 *                      suspended state.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
    2050:	b570      	push	{r4, r5, r6, lr}
    2052:	0004      	movs	r4, r0
    2054:	000e      	movs	r6, r1
    2056:	0015      	movs	r5, r2
  __ASM volatile ("cpsid i" : : : "memory");
    2058:	b672      	cpsid	i
  _dbg_check_lock();
    205a:	f7fe ffc1 	bl	fe0 <_dbg_check_lock>
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
    205e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2060:	2b00      	cmp	r3, #0
    2062:	d01f      	beq.n	20a4 <obqPutTimeout+0x54>
      return msg;
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
    2064:	701e      	strb	r6, [r3, #0]
  obqp->ptr++;
    2066:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
    2068:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  obqp->ptr++;
    206a:	3301      	adds	r3, #1
    206c:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
    206e:	4293      	cmp	r3, r2
    2070:	d212      	bcs.n	2098 <obqPutTimeout+0x48>
  _dbg_check_unlock();
    2072:	f7fe ffcd 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    2076:	4b17      	ldr	r3, [pc, #92]	; (20d4 <obqPutTimeout+0x84>)
    2078:	681a      	ldr	r2, [r3, #0]
    207a:	429a      	cmp	r2, r3
    207c:	d004      	beq.n	2088 <obqPutTimeout+0x38>
    207e:	699b      	ldr	r3, [r3, #24]
    2080:	6899      	ldr	r1, [r3, #8]
    2082:	6893      	ldr	r3, [r2, #8]
    2084:	4299      	cmp	r1, r3
    2086:	d303      	bcc.n	2090 <obqPutTimeout+0x40>
  __ASM volatile ("cpsie i" : : : "memory");
    2088:	b662      	cpsie	i
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  }

  osalSysUnlock();
  return MSG_OK;
    208a:	2500      	movs	r5, #0
}
    208c:	0028      	movs	r0, r5
    208e:	bd70      	pop	{r4, r5, r6, pc}
    2090:	4811      	ldr	r0, [pc, #68]	; (20d8 <obqPutTimeout+0x88>)
    2092:	f7fe ff55 	bl	f40 <chSysHalt>
    2096:	e7f7      	b.n	2088 <obqPutTimeout+0x38>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
    2098:	69e3      	ldr	r3, [r4, #28]
    209a:	0020      	movs	r0, r4
    209c:	1f19      	subs	r1, r3, #4
    209e:	f7ff ffa7 	bl	1ff0 <obqPostFullBufferS>
    20a2:	e7e6      	b.n	2072 <obqPutTimeout+0x22>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
    20a4:	0029      	movs	r1, r5
    20a6:	0020      	movs	r0, r4
    20a8:	f7ff ff7a 	bl	1fa0 <obqGetEmptyBufferTimeoutS>
    20ac:	1e05      	subs	r5, r0, #0
    if (msg != MSG_OK) {
    20ae:	d101      	bne.n	20b4 <obqPutTimeout+0x64>
    20b0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    20b2:	e7d7      	b.n	2064 <obqPutTimeout+0x14>
  _dbg_check_unlock();
    20b4:	f7fe ffac 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    20b8:	4b06      	ldr	r3, [pc, #24]	; (20d4 <obqPutTimeout+0x84>)
    20ba:	681a      	ldr	r2, [r3, #0]
    20bc:	429a      	cmp	r2, r3
    20be:	d007      	beq.n	20d0 <obqPutTimeout+0x80>
    20c0:	699b      	ldr	r3, [r3, #24]
    20c2:	6899      	ldr	r1, [r3, #8]
    20c4:	6893      	ldr	r3, [r2, #8]
    20c6:	4299      	cmp	r1, r3
    20c8:	d202      	bcs.n	20d0 <obqPutTimeout+0x80>
    20ca:	4803      	ldr	r0, [pc, #12]	; (20d8 <obqPutTimeout+0x88>)
    20cc:	f7fe ff38 	bl	f40 <chSysHalt>
    20d0:	b662      	cpsie	i
    20d2:	e7db      	b.n	208c <obqPutTimeout+0x3c>
    20d4:	200000d8 	.word	0x200000d8
    20d8:	00007d10 	.word	0x00007d10
    20dc:	00000000 	.word	0x00000000

000020e0 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
    20e0:	b510      	push	{r4, lr}
    20e2:	0004      	movs	r4, r0

  osalDbgCheckClassI();
    20e4:	f7ff f80c 	bl	1100 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
    20e8:	6923      	ldr	r3, [r4, #16]
    20ea:	6962      	ldr	r2, [r4, #20]
      obqp->ptr = NULL;

      return true;
    }
  }
  return false;
    20ec:	2000      	movs	r0, #0
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
    20ee:	4293      	cmp	r3, r2
    20f0:	d000      	beq.n	20f4 <obqTryFlushI+0x14>
}
    20f2:	bd10      	pop	{r4, pc}
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
    20f4:	68e2      	ldr	r2, [r4, #12]
    20f6:	2a00      	cmp	r2, #0
    20f8:	d0fb      	beq.n	20f2 <obqTryFlushI+0x12>
    20fa:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    20fc:	2a00      	cmp	r2, #0
    20fe:	d0f8      	beq.n	20f2 <obqTryFlushI+0x12>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
    2100:	3a04      	subs	r2, #4
    2102:	1ad2      	subs	r2, r2, r3
    if (size > 0U) {
    2104:	d0f5      	beq.n	20f2 <obqTryFlushI+0x12>
      *((size_t *)obqp->bwrptr) = size;
    2106:	601a      	str	r2, [r3, #0]
      obqp->bcounter--;
    2108:	68e2      	ldr	r2, [r4, #12]
    210a:	3a01      	subs	r2, #1
    210c:	60e2      	str	r2, [r4, #12]
      obqp->bwrptr += obqp->bsize;
    210e:	69e2      	ldr	r2, [r4, #28]
    2110:	4694      	mov	ip, r2
      if (obqp->bwrptr >= obqp->btop) {
    2112:	69a2      	ldr	r2, [r4, #24]
      obqp->bwrptr += obqp->bsize;
    2114:	4463      	add	r3, ip
    2116:	6123      	str	r3, [r4, #16]
      if (obqp->bwrptr >= obqp->btop) {
    2118:	4293      	cmp	r3, r2
    211a:	d301      	bcc.n	2120 <obqTryFlushI+0x40>
        obqp->bwrptr = obqp->buffers;
    211c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    211e:	6123      	str	r3, [r4, #16]
      obqp->ptr = NULL;
    2120:	2300      	movs	r3, #0
      return true;
    2122:	2001      	movs	r0, #1
      obqp->ptr = NULL;
    2124:	62a3      	str	r3, [r4, #40]	; 0x28
      return true;
    2126:	e7e4      	b.n	20f2 <obqTryFlushI+0x12>
	...

00002130 <set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
    2130:	23d6      	movs	r3, #214	; 0xd6
static void set_address(USBDriver *usbp) {
    2132:	b510      	push	{r4, lr}
    2134:	0004      	movs	r4, r0
  usbp->address = usbp->setup[2];
    2136:	5cc2      	ldrb	r2, [r0, r3]
    2138:	3308      	adds	r3, #8
    213a:	54c2      	strb	r2, [r0, r3]
  usb_lld_set_address(usbp);
    213c:	f001 f838 	bl	31b0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
    2140:	6863      	ldr	r3, [r4, #4]
    2142:	681b      	ldr	r3, [r3, #0]
    2144:	2b00      	cmp	r3, #0
    2146:	d002      	beq.n	214e <set_address+0x1e>
    2148:	2101      	movs	r1, #1
    214a:	0020      	movs	r0, r4
    214c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
    214e:	2303      	movs	r3, #3
    2150:	7023      	strb	r3, [r4, #0]
}
    2152:	bd10      	pop	{r4, pc}
	...

00002160 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
    2160:	b510      	push	{r4, lr}

  usb_lld_init();
    2162:	f000 ffb5 	bl	30d0 <usb_lld_init>
}
    2166:	bd10      	pop	{r4, pc}
	...

00002170 <usbObjectInit>:
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
    2170:	2301      	movs	r3, #1
    2172:	7003      	strb	r3, [r0, #0]
  usbp->config       = NULL;
    2174:	2300      	movs	r3, #0
    2176:	0001      	movs	r1, r0
    2178:	6043      	str	r3, [r0, #4]
    217a:	0003      	movs	r3, r0
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
    217c:	2200      	movs	r2, #0
    217e:	334c      	adds	r3, #76	; 0x4c
    2180:	3188      	adds	r1, #136	; 0x88
    2182:	601a      	str	r2, [r3, #0]
    usbp->out_params[i] = NULL;
    2184:	63da      	str	r2, [r3, #60]	; 0x3c
    2186:	3304      	adds	r3, #4
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    2188:	428b      	cmp	r3, r1
    218a:	d1fa      	bne.n	2182 <usbObjectInit+0x12>
  }
  usbp->transmitting = 0;
    218c:	6082      	str	r2, [r0, #8]
  usbp->receiving    = 0;
}
    218e:	4770      	bx	lr

00002190 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
    2190:	b570      	push	{r4, r5, r6, lr}
    2192:	0004      	movs	r4, r0
    2194:	000d      	movs	r5, r1
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));
    2196:	2800      	cmp	r0, #0
    2198:	d02a      	beq.n	21f0 <usbStart+0x60>
    219a:	2900      	cmp	r1, #0
    219c:	d028      	beq.n	21f0 <usbStart+0x60>
  __ASM volatile ("cpsid i" : : : "memory");
    219e:	b672      	cpsid	i
  _dbg_check_lock();
    21a0:	f7fe ff1e 	bl	fe0 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
    21a4:	7823      	ldrb	r3, [r4, #0]
    21a6:	3b01      	subs	r3, #1
    21a8:	2b01      	cmp	r3, #1
    21aa:	d902      	bls.n	21b2 <usbStart+0x22>
    21ac:	4812      	ldr	r0, [pc, #72]	; (21f8 <usbStart+0x68>)
    21ae:	f7fe fec7 	bl	f40 <chSysHalt>
    21b2:	0023      	movs	r3, r4
    21b4:	0021      	movs	r1, r4
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
    21b6:	2200      	movs	r2, #0
  usbp->config = config;
    21b8:	6065      	str	r5, [r4, #4]
    21ba:	330c      	adds	r3, #12
    21bc:	314c      	adds	r1, #76	; 0x4c
    usbp->epc[i] = NULL;
    21be:	c304      	stmia	r3!, {r2}
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    21c0:	428b      	cmp	r3, r1
    21c2:	d1fc      	bne.n	21be <usbStart+0x2e>
  }
  usb_lld_start(usbp);
    21c4:	0020      	movs	r0, r4
    21c6:	f000 ff9b 	bl	3100 <usb_lld_start>
  usbp->state = USB_READY;
    21ca:	2302      	movs	r3, #2
    21cc:	7023      	strb	r3, [r4, #0]
  _dbg_check_unlock();
    21ce:	f7fe ff1f 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    21d2:	4b0a      	ldr	r3, [pc, #40]	; (21fc <usbStart+0x6c>)
    21d4:	681a      	ldr	r2, [r3, #0]
    21d6:	429a      	cmp	r2, r3
    21d8:	d004      	beq.n	21e4 <usbStart+0x54>
    21da:	699b      	ldr	r3, [r3, #24]
    21dc:	6899      	ldr	r1, [r3, #8]
    21de:	6893      	ldr	r3, [r2, #8]
    21e0:	4299      	cmp	r1, r3
    21e2:	d301      	bcc.n	21e8 <usbStart+0x58>
  __ASM volatile ("cpsie i" : : : "memory");
    21e4:	b662      	cpsie	i
  osalSysUnlock();
}
    21e6:	bd70      	pop	{r4, r5, r6, pc}
    21e8:	4805      	ldr	r0, [pc, #20]	; (2200 <usbStart+0x70>)
    21ea:	f7fe fea9 	bl	f40 <chSysHalt>
    21ee:	e7f9      	b.n	21e4 <usbStart+0x54>
  osalDbgCheck((usbp != NULL) && (config != NULL));
    21f0:	4801      	ldr	r0, [pc, #4]	; (21f8 <usbStart+0x68>)
    21f2:	f7fe fea5 	bl	f40 <chSysHalt>
    21f6:	e7d2      	b.n	219e <usbStart+0xe>
    21f8:	00007db8 	.word	0x00007db8
    21fc:	200000d8 	.word	0x200000d8
    2200:	00007dac 	.word	0x00007dac
	...

00002210 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
    2210:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2212:	0004      	movs	r4, r0
    2214:	000f      	movs	r7, r1
    2216:	0016      	movs	r6, r2

  osalDbgCheckClassI();
    2218:	f7fe ff72 	bl	1100 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
    221c:	2c00      	cmp	r4, #0
    221e:	d023      	beq.n	2268 <usbInitEndpointI+0x58>
    2220:	2e00      	cmp	r6, #0
    2222:	d021      	beq.n	2268 <usbInitEndpointI+0x58>
  osalDbgAssert(usbp->state == USB_ACTIVE,
    2224:	7823      	ldrb	r3, [r4, #0]
    2226:	2b04      	cmp	r3, #4
    2228:	d002      	beq.n	2230 <usbInitEndpointI+0x20>
    222a:	4811      	ldr	r0, [pc, #68]	; (2270 <usbInitEndpointI+0x60>)
    222c:	f7fe fe88 	bl	f40 <chSysHalt>
    2230:	00bd      	lsls	r5, r7, #2
    2232:	1965      	adds	r5, r4, r5
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
    2234:	68eb      	ldr	r3, [r5, #12]
    2236:	2b00      	cmp	r3, #0
    2238:	d002      	beq.n	2240 <usbInitEndpointI+0x30>
    223a:	480d      	ldr	r0, [pc, #52]	; (2270 <usbInitEndpointI+0x60>)
    223c:	f7fe fe80 	bl	f40 <chSysHalt>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
    2240:	6970      	ldr	r0, [r6, #20]
  usbp->epc[ep] = epcp;
    2242:	60ee      	str	r6, [r5, #12]
  if (epcp->in_state != NULL) {
    2244:	2800      	cmp	r0, #0
    2246:	d003      	beq.n	2250 <usbInitEndpointI+0x40>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
    2248:	2214      	movs	r2, #20
    224a:	2100      	movs	r1, #0
    224c:	f005 fb8c 	bl	7968 <memset>
  }
  if (epcp->out_state != NULL) {
    2250:	69b0      	ldr	r0, [r6, #24]
    2252:	2800      	cmp	r0, #0
    2254:	d003      	beq.n	225e <usbInitEndpointI+0x4e>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
    2256:	2214      	movs	r2, #20
    2258:	2100      	movs	r1, #0
    225a:	f005 fb85 	bl	7968 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
    225e:	0039      	movs	r1, r7
    2260:	0020      	movs	r0, r4
    2262:	f000 ffb5 	bl	31d0 <usb_lld_init_endpoint>
}
    2266:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
    2268:	4801      	ldr	r0, [pc, #4]	; (2270 <usbInitEndpointI+0x60>)
    226a:	f7fe fe69 	bl	f40 <chSysHalt>
    226e:	e7d9      	b.n	2224 <usbInitEndpointI+0x14>
    2270:	00007dc4 	.word	0x00007dc4
	...

00002280 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
    2280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2282:	0007      	movs	r7, r0
  unsigned i;

  osalDbgCheckClassI();
    2284:	f7fe ff3c 	bl	1100 <chDbgCheckClassI>
  osalDbgCheck(usbp != NULL);
    2288:	2f00      	cmp	r7, #0
    228a:	d02c      	beq.n	22e6 <usbDisableEndpointsI+0x66>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
    228c:	783b      	ldrb	r3, [r7, #0]
    228e:	2b04      	cmp	r3, #4
    2290:	d002      	beq.n	2298 <usbDisableEndpointsI+0x18>
    2292:	4817      	ldr	r0, [pc, #92]	; (22f0 <usbDisableEndpointsI+0x70>)
    2294:	f7fe fe54 	bl	f40 <chSysHalt>

  usbp->transmitting &= 1U;
    2298:	2301      	movs	r3, #1
    229a:	003c      	movs	r4, r7
    229c:	003e      	movs	r6, r7
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
    229e:	2500      	movs	r5, #0
  usbp->transmitting &= 1U;
    22a0:	893a      	ldrh	r2, [r7, #8]
    22a2:	3410      	adds	r4, #16
    22a4:	401a      	ands	r2, r3
    22a6:	813a      	strh	r2, [r7, #8]
  usbp->receiving    &= 1U;
    22a8:	897a      	ldrh	r2, [r7, #10]
    22aa:	364c      	adds	r6, #76	; 0x4c
    22ac:	4013      	ands	r3, r2
    22ae:	817b      	strh	r3, [r7, #10]
    if (usbp->epc[i] != NULL) {
    22b0:	6823      	ldr	r3, [r4, #0]
    22b2:	2b00      	cmp	r3, #0
    22b4:	d010      	beq.n	22d8 <usbDisableEndpointsI+0x58>
      if (usbp->epc[i]->in_state != NULL) {
    22b6:	6958      	ldr	r0, [r3, #20]
    22b8:	2800      	cmp	r0, #0
    22ba:	d005      	beq.n	22c8 <usbDisableEndpointsI+0x48>
  chThdResumeI(trp, msg);
    22bc:	2102      	movs	r1, #2
        osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
    22be:	300c      	adds	r0, #12
    22c0:	4249      	negs	r1, r1
    22c2:	f7ff fad5 	bl	1870 <chThdResumeI>
    22c6:	6823      	ldr	r3, [r4, #0]
      if (usbp->epc[i]->out_state != NULL) {
    22c8:	6998      	ldr	r0, [r3, #24]
    22ca:	2800      	cmp	r0, #0
    22cc:	d004      	beq.n	22d8 <usbDisableEndpointsI+0x58>
    22ce:	2102      	movs	r1, #2
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
    22d0:	300c      	adds	r0, #12
    22d2:	4249      	negs	r1, r1
    22d4:	f7ff facc 	bl	1870 <chThdResumeI>
    usbp->epc[i] = NULL;
    22d8:	c420      	stmia	r4!, {r5}
  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    22da:	42b4      	cmp	r4, r6
    22dc:	d1e8      	bne.n	22b0 <usbDisableEndpointsI+0x30>
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
    22de:	0038      	movs	r0, r7
    22e0:	f001 f82e 	bl	3340 <usb_lld_disable_endpoints>
}
    22e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  osalDbgCheck(usbp != NULL);
    22e6:	4802      	ldr	r0, [pc, #8]	; (22f0 <usbDisableEndpointsI+0x70>)
    22e8:	f7fe fe2a 	bl	f40 <chSysHalt>
    22ec:	e7ce      	b.n	228c <usbDisableEndpointsI+0xc>
    22ee:	46c0      	nop			; (mov r8, r8)
    22f0:	00007dd8 	.word	0x00007dd8
	...

00002300 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
    2300:	b5f0      	push	{r4, r5, r6, r7, lr}
    2302:	46c6      	mov	lr, r8
    2304:	b500      	push	{lr}
    2306:	0005      	movs	r5, r0
    2308:	000e      	movs	r6, r1
    230a:	4690      	mov	r8, r2
    230c:	001f      	movs	r7, r3
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
    230e:	f7fe fef7 	bl	1100 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
    2312:	2d00      	cmp	r5, #0
    2314:	d01f      	beq.n	2356 <usbStartReceiveI+0x56>
    2316:	2e0f      	cmp	r6, #15
    2318:	d81d      	bhi.n	2356 <usbStartReceiveI+0x56>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
    231a:	2301      	movs	r3, #1
    231c:	40b3      	lsls	r3, r6
    231e:	896a      	ldrh	r2, [r5, #10]
    2320:	b29c      	uxth	r4, r3
    2322:	4214      	tst	r4, r2
    2324:	d003      	beq.n	232e <usbStartReceiveI+0x2e>
    2326:	480e      	ldr	r0, [pc, #56]	; (2360 <usbStartReceiveI+0x60>)
    2328:	f7fe fe0a 	bl	f40 <chSysHalt>
    232c:	896a      	ldrh	r2, [r5, #10]

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
    232e:	4314      	orrs	r4, r2

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
    2330:	4642      	mov	r2, r8
  osp = usbp->epc[ep]->out_state;
    2332:	1cb3      	adds	r3, r6, #2
    2334:	009b      	lsls	r3, r3, #2
    2336:	18eb      	adds	r3, r5, r3
    2338:	685b      	ldr	r3, [r3, #4]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
    233a:	816c      	strh	r4, [r5, #10]
  osp = usbp->epc[ep]->out_state;
    233c:	699b      	ldr	r3, [r3, #24]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
    233e:	0031      	movs	r1, r6
  osp->rxbuf  = buf;
    2340:	609a      	str	r2, [r3, #8]
  osp->rxcnt  = 0;
    2342:	2200      	movs	r2, #0
  osp->rxsize = n;
    2344:	601f      	str	r7, [r3, #0]
  usb_lld_start_out(usbp, ep);
    2346:	0028      	movs	r0, r5
  osp->rxcnt  = 0;
    2348:	605a      	str	r2, [r3, #4]
  osp->thread = NULL;
    234a:	60da      	str	r2, [r3, #12]
  usb_lld_start_out(usbp, ep);
    234c:	f001 f860 	bl	3410 <usb_lld_start_out>
}
    2350:	bc04      	pop	{r2}
    2352:	4690      	mov	r8, r2
    2354:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
    2356:	4802      	ldr	r0, [pc, #8]	; (2360 <usbStartReceiveI+0x60>)
    2358:	f7fe fdf2 	bl	f40 <chSysHalt>
    235c:	e7dd      	b.n	231a <usbStartReceiveI+0x1a>
    235e:	46c0      	nop			; (mov r8, r8)
    2360:	00007df0 	.word	0x00007df0
	...

00002370 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
    2370:	b5f0      	push	{r4, r5, r6, r7, lr}
    2372:	46c6      	mov	lr, r8
    2374:	b500      	push	{lr}
    2376:	0005      	movs	r5, r0
    2378:	000e      	movs	r6, r1
    237a:	4690      	mov	r8, r2
    237c:	001f      	movs	r7, r3
  USBInEndpointState *isp;

  osalDbgCheckClassI();
    237e:	f7fe febf 	bl	1100 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
    2382:	2d00      	cmp	r5, #0
    2384:	d01f      	beq.n	23c6 <usbStartTransmitI+0x56>
    2386:	2e0f      	cmp	r6, #15
    2388:	d81d      	bhi.n	23c6 <usbStartTransmitI+0x56>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
    238a:	2301      	movs	r3, #1
    238c:	40b3      	lsls	r3, r6
    238e:	892a      	ldrh	r2, [r5, #8]
    2390:	b29c      	uxth	r4, r3
    2392:	4214      	tst	r4, r2
    2394:	d003      	beq.n	239e <usbStartTransmitI+0x2e>
    2396:	480e      	ldr	r0, [pc, #56]	; (23d0 <usbStartTransmitI+0x60>)
    2398:	f7fe fdd2 	bl	f40 <chSysHalt>
    239c:	892a      	ldrh	r2, [r5, #8]

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
    239e:	4314      	orrs	r4, r2

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
    23a0:	4642      	mov	r2, r8
  isp = usbp->epc[ep]->in_state;
    23a2:	1cb3      	adds	r3, r6, #2
    23a4:	009b      	lsls	r3, r3, #2
    23a6:	18eb      	adds	r3, r5, r3
    23a8:	685b      	ldr	r3, [r3, #4]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
    23aa:	812c      	strh	r4, [r5, #8]
  isp = usbp->epc[ep]->in_state;
    23ac:	695b      	ldr	r3, [r3, #20]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
    23ae:	0031      	movs	r1, r6
  isp->txbuf  = buf;
    23b0:	609a      	str	r2, [r3, #8]
  isp->txcnt  = 0;
    23b2:	2200      	movs	r2, #0
  isp->txsize = n;
    23b4:	601f      	str	r7, [r3, #0]
  usb_lld_start_in(usbp, ep);
    23b6:	0028      	movs	r0, r5
  isp->txcnt  = 0;
    23b8:	605a      	str	r2, [r3, #4]
  isp->thread = NULL;
    23ba:	60da      	str	r2, [r3, #12]
  usb_lld_start_in(usbp, ep);
    23bc:	f001 f840 	bl	3440 <usb_lld_start_in>
}
    23c0:	bc04      	pop	{r2}
    23c2:	4690      	mov	r8, r2
    23c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
    23c6:	4802      	ldr	r0, [pc, #8]	; (23d0 <usbStartTransmitI+0x60>)
    23c8:	f7fe fdba 	bl	f40 <chSysHalt>
    23cc:	e7dd      	b.n	238a <usbStartTransmitI+0x1a>
    23ce:	46c0      	nop			; (mov r8, r8)
    23d0:	00007e04 	.word	0x00007e04
	...

000023e0 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
    23e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
    23e2:	2302      	movs	r3, #2

  /* Resetting internal state.*/
  usbp->status        = 0;
    23e4:	22dc      	movs	r2, #220	; 0xdc
  usbp->state         = USB_READY;
    23e6:	7003      	strb	r3, [r0, #0]
    23e8:	0004      	movs	r4, r0
  usbp->status        = 0;
    23ea:	2300      	movs	r3, #0
    23ec:	0006      	movs	r6, r0
void _usb_reset(USBDriver *usbp) {
    23ee:	0007      	movs	r7, r0
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
    23f0:	2500      	movs	r5, #0
  usbp->status        = 0;
    23f2:	5083      	str	r3, [r0, r2]
    23f4:	340c      	adds	r4, #12
  usbp->transmitting  = 0;
    23f6:	6083      	str	r3, [r0, #8]
    23f8:	364c      	adds	r6, #76	; 0x4c
    if (usbp->epc[i] != NULL) {
    23fa:	6823      	ldr	r3, [r4, #0]
    23fc:	2b00      	cmp	r3, #0
    23fe:	d017      	beq.n	2430 <_usb_reset+0x50>
  __ASM volatile ("cpsid i" : : : "memory");
    2400:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2402:	f7fe fe1d 	bl	1040 <_dbg_check_lock_from_isr>
      if (usbp->epc[i]->in_state != NULL) {
    2406:	6823      	ldr	r3, [r4, #0]
    2408:	6958      	ldr	r0, [r3, #20]
    240a:	2800      	cmp	r0, #0
    240c:	d005      	beq.n	241a <_usb_reset+0x3a>
    240e:	2102      	movs	r1, #2
        osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
    2410:	300c      	adds	r0, #12
    2412:	4249      	negs	r1, r1
    2414:	f7ff fa2c 	bl	1870 <chThdResumeI>
    2418:	6823      	ldr	r3, [r4, #0]
      if (usbp->epc[i]->out_state != NULL) {
    241a:	6998      	ldr	r0, [r3, #24]
    241c:	2800      	cmp	r0, #0
    241e:	d004      	beq.n	242a <_usb_reset+0x4a>
    2420:	2102      	movs	r1, #2
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
    2422:	300c      	adds	r0, #12
    2424:	4249      	negs	r1, r1
    2426:	f7ff fa23 	bl	1870 <chThdResumeI>
  _dbg_check_unlock_from_isr();
    242a:	f7fe fe21 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    242e:	b662      	cpsie	i
    usbp->epc[i] = NULL;
    2430:	c420      	stmia	r4!, {r5}
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    2432:	42b4      	cmp	r4, r6
    2434:	d1e1      	bne.n	23fa <_usb_reset+0x1a>
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
    2436:	23c4      	movs	r3, #196	; 0xc4

  /* Low level reset.*/
  usb_lld_reset(usbp);
    2438:	0038      	movs	r0, r7
  usbp->ep0state = USB_EP0_WAITING_SETUP;
    243a:	54fd      	strb	r5, [r7, r3]
  usb_lld_reset(usbp);
    243c:	f000 ff58 	bl	32f0 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
    2440:	687b      	ldr	r3, [r7, #4]
    2442:	681b      	ldr	r3, [r3, #0]
    2444:	2b00      	cmp	r3, #0
    2446:	d002      	beq.n	244e <_usb_reset+0x6e>
    2448:	2100      	movs	r1, #0
    244a:	0038      	movs	r0, r7
    244c:	4798      	blx	r3
}
    244e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00002450 <_usb_suspend>:
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
    2450:	23e0      	movs	r3, #224	; 0xe0
    2452:	7802      	ldrb	r2, [r0, #0]
void _usb_suspend(USBDriver *usbp) {
    2454:	b570      	push	{r4, r5, r6, lr}
  usbp->saved_state = usbp->state;
    2456:	54c2      	strb	r2, [r0, r3]
  usbp->state       = USB_SUSPENDED;
    2458:	3bdb      	subs	r3, #219	; 0xdb
    245a:	7003      	strb	r3, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
    245c:	6843      	ldr	r3, [r0, #4]
void _usb_suspend(USBDriver *usbp) {
    245e:	0005      	movs	r5, r0
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
    2460:	681b      	ldr	r3, [r3, #0]
    2462:	2b00      	cmp	r3, #0
    2464:	d001      	beq.n	246a <_usb_suspend+0x1a>
    2466:	2104      	movs	r1, #4
    2468:	4798      	blx	r3
    246a:	002c      	movs	r4, r5
    246c:	354c      	adds	r5, #76	; 0x4c
    246e:	340c      	adds	r4, #12
#if USB_USE_WAIT == TRUE
  {
    unsigned i;

    for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
      if (usbp->epc[i] != NULL) {
    2470:	6823      	ldr	r3, [r4, #0]
    2472:	2b00      	cmp	r3, #0
    2474:	d017      	beq.n	24a6 <_usb_suspend+0x56>
  __ASM volatile ("cpsid i" : : : "memory");
    2476:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2478:	f7fe fde2 	bl	1040 <_dbg_check_lock_from_isr>
        osalSysLockFromISR();
        if (usbp->epc[i]->in_state != NULL) {
    247c:	6823      	ldr	r3, [r4, #0]
    247e:	6958      	ldr	r0, [r3, #20]
    2480:	2800      	cmp	r0, #0
    2482:	d005      	beq.n	2490 <_usb_suspend+0x40>
    2484:	2102      	movs	r1, #2
          osalThreadResumeI(&usbp->epc[i]->in_state->thread, MSG_RESET);
    2486:	300c      	adds	r0, #12
    2488:	4249      	negs	r1, r1
    248a:	f7ff f9f1 	bl	1870 <chThdResumeI>
    248e:	6823      	ldr	r3, [r4, #0]
        }
        if (usbp->epc[i]->out_state != NULL) {
    2490:	6998      	ldr	r0, [r3, #24]
    2492:	2800      	cmp	r0, #0
    2494:	d004      	beq.n	24a0 <_usb_suspend+0x50>
    2496:	2102      	movs	r1, #2
          osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
    2498:	300c      	adds	r0, #12
    249a:	4249      	negs	r1, r1
    249c:	f7ff f9e8 	bl	1870 <chThdResumeI>
  _dbg_check_unlock_from_isr();
    24a0:	f7fe fde6 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    24a4:	b662      	cpsie	i
    24a6:	3404      	adds	r4, #4
    for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    24a8:	42ac      	cmp	r4, r5
    24aa:	d1e1      	bne.n	2470 <_usb_suspend+0x20>
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
    24ac:	bd70      	pop	{r4, r5, r6, pc}
    24ae:	46c0      	nop			; (mov r8, r8)

000024b0 <_usb_wakeup>:
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
    24b0:	23e0      	movs	r3, #224	; 0xe0
    24b2:	5cc3      	ldrb	r3, [r0, r3]
void _usb_wakeup(USBDriver *usbp) {
    24b4:	b510      	push	{r4, lr}
  usbp->state = usbp->saved_state;
    24b6:	7003      	strb	r3, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
    24b8:	6843      	ldr	r3, [r0, #4]
    24ba:	681b      	ldr	r3, [r3, #0]
    24bc:	2b00      	cmp	r3, #0
    24be:	d001      	beq.n	24c4 <_usb_wakeup+0x14>
    24c0:	2105      	movs	r1, #5
    24c2:	4798      	blx	r3
}
    24c4:	bd10      	pop	{r4, pc}
    24c6:	46c0      	nop			; (mov r8, r8)
	...

000024d0 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
    24d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
    24d2:	2200      	movs	r2, #0
    24d4:	23c4      	movs	r3, #196	; 0xc4
    24d6:	54c2      	strb	r2, [r0, r3]
  usbReadSetup(usbp, ep, usbp->setup);
    24d8:	0002      	movs	r2, r0
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
    24da:	0004      	movs	r4, r0
  usbReadSetup(usbp, ep, usbp->setup);
    24dc:	32d4      	adds	r2, #212	; 0xd4
    24de:	f000 ff6f 	bl	33c0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
    24e2:	6863      	ldr	r3, [r4, #4]
    24e4:	689b      	ldr	r3, [r3, #8]
    24e6:	2b00      	cmp	r3, #0
    24e8:	d02b      	beq.n	2542 <_usb_ep0setup+0x72>
      !(usbp->config->requests_hook_cb(usbp))) {
    24ea:	0020      	movs	r0, r4
    24ec:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
    24ee:	2800      	cmp	r0, #0
    24f0:	d027      	beq.n	2542 <_usb_ep0setup+0x72>
    24f2:	23cc      	movs	r3, #204	; 0xcc
    24f4:	58e1      	ldr	r1, [r4, r3]
  hw |= (uint16_t)*p << 8U;
    24f6:	23db      	movs	r3, #219	; 0xdb
    24f8:	5ce2      	ldrb	r2, [r4, r3]
  hw  = (uint16_t)*p++;
    24fa:	3b01      	subs	r3, #1
  hw |= (uint16_t)*p << 8U;
    24fc:	5ce3      	ldrb	r3, [r4, r3]
    24fe:	0212      	lsls	r2, r2, #8
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
    2500:	4313      	orrs	r3, r2
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
    2502:	428b      	cmp	r3, r1
    2504:	d300      	bcc.n	2508 <_usb_ep0setup+0x38>
    2506:	e096      	b.n	2636 <_usb_ep0setup+0x166>
    usbp->ep0n = max;
    2508:	22cc      	movs	r2, #204	; 0xcc
    250a:	50a3      	str	r3, [r4, r2]
    250c:	3208      	adds	r2, #8
    250e:	5ca2      	ldrb	r2, [r4, r2]
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    2510:	b252      	sxtb	r2, r2
    2512:	2a00      	cmp	r2, #0
    2514:	da00      	bge.n	2518 <_usb_ep0setup+0x48>
    2516:	e095      	b.n	2644 <_usb_ep0setup+0x174>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
    2518:	2b00      	cmp	r3, #0
    251a:	d100      	bne.n	251e <_usb_ep0setup+0x4e>
    251c:	e07b      	b.n	2616 <_usb_ep0setup+0x146>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
    251e:	23c4      	movs	r3, #196	; 0xc4
    2520:	2204      	movs	r2, #4
    2522:	54e2      	strb	r2, [r4, r3]
  __ASM volatile ("cpsid i" : : : "memory");
    2524:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2526:	f7fe fd8b 	bl	1040 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
    252a:	23cc      	movs	r3, #204	; 0xcc
    252c:	22c8      	movs	r2, #200	; 0xc8
    252e:	58e3      	ldr	r3, [r4, r3]
    2530:	58a2      	ldr	r2, [r4, r2]
    2532:	2100      	movs	r1, #0
    2534:	0020      	movs	r0, r4
    2536:	f7ff fee3 	bl	2300 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
    253a:	f7fe fd99 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    253e:	b662      	cpsie	i
    2540:	e016      	b.n	2570 <_usb_ep0setup+0xa0>
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
    2542:	26d4      	movs	r6, #212	; 0xd4
    2544:	2560      	movs	r5, #96	; 0x60
    2546:	5da0      	ldrb	r0, [r4, r6]
    2548:	4005      	ands	r5, r0
    254a:	d012      	beq.n	2572 <_usb_ep0setup+0xa2>
      usb_lld_stall_in(usbp, 0);
    254c:	2100      	movs	r1, #0
    254e:	0020      	movs	r0, r4
    2550:	f000 ff96 	bl	3480 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
    2554:	2100      	movs	r1, #0
    2556:	0020      	movs	r0, r4
    2558:	f000 ff82 	bl	3460 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    255c:	6863      	ldr	r3, [r4, #4]
    255e:	681b      	ldr	r3, [r3, #0]
    2560:	2b00      	cmp	r3, #0
    2562:	d002      	beq.n	256a <_usb_ep0setup+0x9a>
    2564:	2106      	movs	r1, #6
    2566:	0020      	movs	r0, r4
    2568:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
    256a:	23c4      	movs	r3, #196	; 0xc4
    256c:	2206      	movs	r2, #6
    256e:	54e2      	strb	r2, [r4, r3]
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
    2570:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
           ((uint32_t)usbp->setup[1] << 8U))) {
    2572:	23d5      	movs	r3, #213	; 0xd5
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
    2574:	227f      	movs	r2, #127	; 0x7f
           ((uint32_t)usbp->setup[1] << 8U))) {
    2576:	5ce3      	ldrb	r3, [r4, r3]
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
    2578:	4002      	ands	r2, r0
           ((uint32_t)usbp->setup[1] << 8U))) {
    257a:	021b      	lsls	r3, r3, #8
                                        USB_RTYPE_TYPE_MASK)) |
    257c:	4313      	orrs	r3, r2
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
    257e:	22c0      	movs	r2, #192	; 0xc0
    2580:	0092      	lsls	r2, r2, #2
    2582:	4293      	cmp	r3, r2
    2584:	d100      	bne.n	2588 <_usb_ep0setup+0xb8>
    2586:	e0d4      	b.n	2732 <_usb_ep0setup+0x262>
    2588:	d91d      	bls.n	25c6 <_usb_ep0setup+0xf6>
    258a:	22c0      	movs	r2, #192	; 0xc0
    258c:	00d2      	lsls	r2, r2, #3
    258e:	4293      	cmp	r3, r2
    2590:	d100      	bne.n	2594 <_usb_ep0setup+0xc4>
    2592:	e0b4      	b.n	26fe <_usb_ep0setup+0x22e>
    2594:	d800      	bhi.n	2598 <_usb_ep0setup+0xc8>
    2596:	e096      	b.n	26c6 <_usb_ep0setup+0x1f6>
    2598:	2290      	movs	r2, #144	; 0x90
    259a:	0112      	lsls	r2, r2, #4
    259c:	4293      	cmp	r3, r2
    259e:	d067      	beq.n	2670 <_usb_ep0setup+0x1a0>
    25a0:	4a95      	ldr	r2, [pc, #596]	; (27f8 <_usb_ep0setup+0x328>)
    25a2:	4293      	cmp	r3, r2
    25a4:	d100      	bne.n	25a8 <_usb_ep0setup+0xd8>
    25a6:	e0d1      	b.n	274c <_usb_ep0setup+0x27c>
    25a8:	2280      	movs	r2, #128	; 0x80
    25aa:	0112      	lsls	r2, r2, #4
    25ac:	4293      	cmp	r3, r2
    25ae:	d1cd      	bne.n	254c <_usb_ep0setup+0x7c>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    25b0:	0023      	movs	r3, r4
    25b2:	22c8      	movs	r2, #200	; 0xc8
    25b4:	33df      	adds	r3, #223	; 0xdf
    25b6:	50a3      	str	r3, [r4, r2]
    25b8:	23cc      	movs	r3, #204	; 0xcc
    25ba:	3ac7      	subs	r2, #199	; 0xc7
    25bc:	50e2      	str	r2, [r4, r3]
    25be:	3304      	adds	r3, #4
    25c0:	50e5      	str	r5, [r4, r3]
    25c2:	2101      	movs	r1, #1
    25c4:	e797      	b.n	24f6 <_usb_ep0setup+0x26>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
    25c6:	2b02      	cmp	r3, #2
    25c8:	d100      	bne.n	25cc <_usb_ep0setup+0xfc>
    25ca:	e0ca      	b.n	2762 <_usb_ep0setup+0x292>
    25cc:	d800      	bhi.n	25d0 <_usb_ep0setup+0x100>
    25ce:	e08a      	b.n	26e6 <_usb_ep0setup+0x216>
    25d0:	2280      	movs	r2, #128	; 0x80
    25d2:	0052      	lsls	r2, r2, #1
    25d4:	4293      	cmp	r3, r2
    25d6:	d065      	beq.n	26a4 <_usb_ep0setup+0x1d4>
    25d8:	3202      	adds	r2, #2
    25da:	4293      	cmp	r3, r2
    25dc:	d1b6      	bne.n	254c <_usb_ep0setup+0x7c>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
    25de:	23d6      	movs	r3, #214	; 0xd6
    25e0:	5ce3      	ldrb	r3, [r4, r3]
    25e2:	2b00      	cmp	r3, #0
    25e4:	d1b2      	bne.n	254c <_usb_ep0setup+0x7c>
    25e6:	210f      	movs	r1, #15
    if ((usbp->setup[4] & 0x0FU) != 0U) {
    25e8:	33d8      	adds	r3, #216	; 0xd8
    25ea:	5ce3      	ldrb	r3, [r4, r3]
    25ec:	4019      	ands	r1, r3
    25ee:	d008      	beq.n	2602 <_usb_ep0setup+0x132>
      if ((usbp->setup[4] & 0x80U) != 0U) {
    25f0:	b25b      	sxtb	r3, r3
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
    25f2:	0020      	movs	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
    25f4:	2b00      	cmp	r3, #0
    25f6:	da00      	bge.n	25fa <_usb_ep0setup+0x12a>
    25f8:	e0f4      	b.n	27e4 <_usb_ep0setup+0x314>
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
    25fa:	f000 ff51 	bl	34a0 <usb_lld_clear_out>
    25fe:	23d4      	movs	r3, #212	; 0xd4
    2600:	5ce0      	ldrb	r0, [r4, r3]
    usbSetupTransfer(usbp, NULL, 0, NULL);
    2602:	2300      	movs	r3, #0
    2604:	22c8      	movs	r2, #200	; 0xc8
    2606:	50a3      	str	r3, [r4, r2]
    2608:	3204      	adds	r2, #4
    260a:	50a3      	str	r3, [r4, r2]
    260c:	3204      	adds	r2, #4
    260e:	50a3      	str	r3, [r4, r2]
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    2610:	b240      	sxtb	r0, r0
    2612:	2800      	cmp	r0, #0
    2614:	db23      	blt.n	265e <_usb_ep0setup+0x18e>
      usbp->ep0state = USB_EP0_SENDING_STS;
    2616:	23c4      	movs	r3, #196	; 0xc4
    2618:	2205      	movs	r2, #5
    261a:	54e2      	strb	r2, [r4, r3]
  __ASM volatile ("cpsid i" : : : "memory");
    261c:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    261e:	f7fe fd0f 	bl	1040 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
    2622:	2300      	movs	r3, #0
    2624:	2200      	movs	r2, #0
    2626:	2100      	movs	r1, #0
    2628:	0020      	movs	r0, r4
    262a:	f7ff fea1 	bl	2370 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
    262e:	f7fe fd1f 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    2632:	b662      	cpsie	i
    2634:	e79c      	b.n	2570 <_usb_ep0setup+0xa0>
    2636:	23d4      	movs	r3, #212	; 0xd4
    2638:	5ce2      	ldrb	r2, [r4, r3]
  if (usbp->ep0n > max) {
    263a:	000b      	movs	r3, r1
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    263c:	b252      	sxtb	r2, r2
    263e:	2a00      	cmp	r2, #0
    2640:	db00      	blt.n	2644 <_usb_ep0setup+0x174>
    2642:	e769      	b.n	2518 <_usb_ep0setup+0x48>
    if (usbp->ep0n != 0U) {
    2644:	2b00      	cmp	r3, #0
    2646:	d00a      	beq.n	265e <_usb_ep0setup+0x18e>
      usbp->ep0state = USB_EP0_TX;
    2648:	23c4      	movs	r3, #196	; 0xc4
    264a:	2201      	movs	r2, #1
    264c:	54e2      	strb	r2, [r4, r3]
  __ASM volatile ("cpsid i" : : : "memory");
    264e:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2650:	f7fe fcf6 	bl	1040 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
    2654:	23cc      	movs	r3, #204	; 0xcc
    2656:	22c8      	movs	r2, #200	; 0xc8
    2658:	58e3      	ldr	r3, [r4, r3]
    265a:	58a2      	ldr	r2, [r4, r2]
    265c:	e7e3      	b.n	2626 <_usb_ep0setup+0x156>
      usbp->ep0state = USB_EP0_WAITING_STS;
    265e:	23c4      	movs	r3, #196	; 0xc4
    2660:	2203      	movs	r2, #3
    2662:	54e2      	strb	r2, [r4, r3]
    2664:	b672      	cpsid	i
    2666:	f7fe fceb 	bl	1040 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, NULL, 0);
    266a:	2300      	movs	r3, #0
    266c:	2200      	movs	r2, #0
    266e:	e760      	b.n	2532 <_usb_ep0setup+0x62>
    if (usbp->configuration != usbp->setup[2]) {
    2670:	26d6      	movs	r6, #214	; 0xd6
    2672:	27df      	movs	r7, #223	; 0xdf
    2674:	5da3      	ldrb	r3, [r4, r6]
    2676:	5de2      	ldrb	r2, [r4, r7]
    2678:	429a      	cmp	r2, r3
    267a:	d0c2      	beq.n	2602 <_usb_ep0setup+0x132>
      if (usbp->state == USB_ACTIVE) {
    267c:	7822      	ldrb	r2, [r4, #0]
    267e:	2a04      	cmp	r2, #4
    2680:	d100      	bne.n	2684 <_usb_ep0setup+0x1b4>
    2682:	e09a      	b.n	27ba <_usb_ep0setup+0x2ea>
      if (usbp->setup[2] != 0U) {
    2684:	2b00      	cmp	r3, #0
    2686:	d00a      	beq.n	269e <_usb_ep0setup+0x1ce>
        usbp->configuration = usbp->setup[2];
    2688:	22df      	movs	r2, #223	; 0xdf
    268a:	54a3      	strb	r3, [r4, r2]
        usbp->state = USB_ACTIVE;
    268c:	2304      	movs	r3, #4
    268e:	7023      	strb	r3, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
    2690:	6863      	ldr	r3, [r4, #4]
    2692:	681b      	ldr	r3, [r3, #0]
    2694:	2b00      	cmp	r3, #0
    2696:	d002      	beq.n	269e <_usb_ep0setup+0x1ce>
    2698:	2102      	movs	r1, #2
    269a:	0020      	movs	r0, r4
    269c:	4798      	blx	r3
    269e:	23d4      	movs	r3, #212	; 0xd4
    26a0:	5ce0      	ldrb	r0, [r4, r3]
    26a2:	e7ae      	b.n	2602 <_usb_ep0setup+0x132>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
    26a4:	23d6      	movs	r3, #214	; 0xd6
    26a6:	5ce3      	ldrb	r3, [r4, r3]
    26a8:	2b01      	cmp	r3, #1
    26aa:	d000      	beq.n	26ae <_usb_ep0setup+0x1de>
    26ac:	e74e      	b.n	254c <_usb_ep0setup+0x7c>
      usbp->status &= ~2U;
    26ae:	22dc      	movs	r2, #220	; 0xdc
    26b0:	2102      	movs	r1, #2
    26b2:	5aa3      	ldrh	r3, [r4, r2]
    26b4:	438b      	bics	r3, r1
      usbp->status |= 2U;
    26b6:	52a3      	strh	r3, [r4, r2]
      usbSetupTransfer(usbp, NULL, 0, NULL);
    26b8:	23c8      	movs	r3, #200	; 0xc8
    26ba:	50e5      	str	r5, [r4, r3]
    26bc:	3304      	adds	r3, #4
    26be:	50e5      	str	r5, [r4, r3]
    26c0:	3304      	adds	r3, #4
    26c2:	50e5      	str	r5, [r4, r3]
    26c4:	e7a4      	b.n	2610 <_usb_ep0setup+0x140>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
    26c6:	4a4d      	ldr	r2, [pc, #308]	; (27fc <_usb_ep0setup+0x32c>)
    26c8:	4293      	cmp	r3, r2
    26ca:	d05c      	beq.n	2786 <_usb_ep0setup+0x2b6>
    26cc:	32ff      	adds	r2, #255	; 0xff
    26ce:	32ff      	adds	r2, #255	; 0xff
    26d0:	4293      	cmp	r3, r2
    26d2:	d000      	beq.n	26d6 <_usb_ep0setup+0x206>
    26d4:	e73a      	b.n	254c <_usb_ep0setup+0x7c>
    usbSetupTransfer(usbp, NULL, 0, set_address);
    26d6:	23c8      	movs	r3, #200	; 0xc8
    26d8:	4a49      	ldr	r2, [pc, #292]	; (2800 <_usb_ep0setup+0x330>)
    26da:	50e5      	str	r5, [r4, r3]
    26dc:	3304      	adds	r3, #4
    26de:	50e5      	str	r5, [r4, r3]
    26e0:	3304      	adds	r3, #4
    26e2:	50e2      	str	r2, [r4, r3]
    26e4:	e794      	b.n	2610 <_usb_ep0setup+0x140>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
    26e6:	2b00      	cmp	r3, #0
    26e8:	d12d      	bne.n	2746 <_usb_ep0setup+0x276>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    26ea:	0022      	movs	r2, r4
    26ec:	21c8      	movs	r1, #200	; 0xc8
    26ee:	32dc      	adds	r2, #220	; 0xdc
    26f0:	5062      	str	r2, [r4, r1]
    26f2:	22cc      	movs	r2, #204	; 0xcc
    26f4:	39c6      	subs	r1, #198	; 0xc6
    26f6:	50a1      	str	r1, [r4, r2]
    26f8:	3204      	adds	r2, #4
    26fa:	50a3      	str	r3, [r4, r2]
    26fc:	e6fb      	b.n	24f6 <_usb_ep0setup+0x26>
  hw |= (uint16_t)*p << 8U;
    26fe:	23d9      	movs	r3, #217	; 0xd9
    2700:	5ce2      	ldrb	r2, [r4, r3]
  hw  = (uint16_t)*p++;
    2702:	3b01      	subs	r3, #1
  hw |= (uint16_t)*p << 8U;
    2704:	5ce3      	ldrb	r3, [r4, r3]
    2706:	0212      	lsls	r2, r2, #8
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
    2708:	4313      	orrs	r3, r2
    270a:	21d7      	movs	r1, #215	; 0xd7
    270c:	22d6      	movs	r2, #214	; 0xd6
    270e:	6860      	ldr	r0, [r4, #4]
    2710:	5ca2      	ldrb	r2, [r4, r2]
    2712:	6846      	ldr	r6, [r0, #4]
    2714:	5c61      	ldrb	r1, [r4, r1]
    2716:	0020      	movs	r0, r4
    2718:	47b0      	blx	r6
    if (dp == NULL) {
    271a:	2800      	cmp	r0, #0
    271c:	d100      	bne.n	2720 <_usb_ep0setup+0x250>
    271e:	e715      	b.n	254c <_usb_ep0setup+0x7c>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    2720:	23c8      	movs	r3, #200	; 0xc8
    2722:	6842      	ldr	r2, [r0, #4]
    2724:	6801      	ldr	r1, [r0, #0]
    2726:	50e2      	str	r2, [r4, r3]
    2728:	3304      	adds	r3, #4
    272a:	50e1      	str	r1, [r4, r3]
    272c:	3304      	adds	r3, #4
    272e:	50e5      	str	r5, [r4, r3]
    2730:	e6e1      	b.n	24f6 <_usb_ep0setup+0x26>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
    2732:	23d6      	movs	r3, #214	; 0xd6
    2734:	5ce3      	ldrb	r3, [r4, r3]
    2736:	2b01      	cmp	r3, #1
    2738:	d000      	beq.n	273c <_usb_ep0setup+0x26c>
    273a:	e707      	b.n	254c <_usb_ep0setup+0x7c>
      usbp->status |= 2U;
    273c:	22dc      	movs	r2, #220	; 0xdc
    273e:	2102      	movs	r1, #2
    2740:	5aa3      	ldrh	r3, [r4, r2]
    2742:	430b      	orrs	r3, r1
    2744:	e7b7      	b.n	26b6 <_usb_ep0setup+0x1e6>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
    2746:	2b01      	cmp	r3, #1
    2748:	d000      	beq.n	274c <_usb_ep0setup+0x27c>
    274a:	e6ff      	b.n	254c <_usb_ep0setup+0x7c>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    274c:	23c8      	movs	r3, #200	; 0xc8
    274e:	4a2d      	ldr	r2, [pc, #180]	; (2804 <_usb_ep0setup+0x334>)
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
    2750:	50e2      	str	r2, [r4, r3]
    2752:	2202      	movs	r2, #2
    2754:	3304      	adds	r3, #4
    2756:	50e2      	str	r2, [r4, r3]
    2758:	2200      	movs	r2, #0
    275a:	3304      	adds	r3, #4
    275c:	50e2      	str	r2, [r4, r3]
    275e:	2102      	movs	r1, #2
    2760:	e6c9      	b.n	24f6 <_usb_ep0setup+0x26>
    if ((usbp->setup[4] & 0x80U) != 0U) {
    2762:	23d8      	movs	r3, #216	; 0xd8
    2764:	210f      	movs	r1, #15
    2766:	5ce3      	ldrb	r3, [r4, r3]
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
    2768:	0020      	movs	r0, r4
    276a:	4019      	ands	r1, r3
    if ((usbp->setup[4] & 0x80U) != 0U) {
    276c:	b25b      	sxtb	r3, r3
    276e:	2b00      	cmp	r3, #0
    2770:	db1c      	blt.n	27ac <_usb_ep0setup+0x2dc>
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
    2772:	f000 fdf5 	bl	3360 <usb_lld_get_status_out>
    2776:	2801      	cmp	r0, #1
    2778:	d01c      	beq.n	27b4 <_usb_ep0setup+0x2e4>
    277a:	2802      	cmp	r0, #2
    277c:	d000      	beq.n	2780 <_usb_ep0setup+0x2b0>
    277e:	e6e5      	b.n	254c <_usb_ep0setup+0x7c>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
    2780:	23c8      	movs	r3, #200	; 0xc8
    2782:	4a21      	ldr	r2, [pc, #132]	; (2808 <_usb_ep0setup+0x338>)
    2784:	e7e4      	b.n	2750 <_usb_ep0setup+0x280>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
    2786:	23d6      	movs	r3, #214	; 0xd6
    2788:	5ce3      	ldrb	r3, [r4, r3]
    278a:	2b00      	cmp	r3, #0
    278c:	d000      	beq.n	2790 <_usb_ep0setup+0x2c0>
    278e:	e6dd      	b.n	254c <_usb_ep0setup+0x7c>
    2790:	210f      	movs	r1, #15
    if ((usbp->setup[4] & 0x0FU) != 0U) {
    2792:	33d8      	adds	r3, #216	; 0xd8
    2794:	5ce3      	ldrb	r3, [r4, r3]
    2796:	4019      	ands	r1, r3
    2798:	d100      	bne.n	279c <_usb_ep0setup+0x2cc>
    279a:	e732      	b.n	2602 <_usb_ep0setup+0x132>
      if ((usbp->setup[4] & 0x80U) != 0U) {
    279c:	b25b      	sxtb	r3, r3
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
    279e:	0020      	movs	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
    27a0:	2b00      	cmp	r3, #0
    27a2:	db24      	blt.n	27ee <_usb_ep0setup+0x31e>
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
    27a4:	f000 fe5c 	bl	3460 <usb_lld_stall_out>
    27a8:	5da0      	ldrb	r0, [r4, r6]
    27aa:	e72a      	b.n	2602 <_usb_ep0setup+0x132>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
    27ac:	f000 fdf0 	bl	3390 <usb_lld_get_status_in>
    27b0:	2801      	cmp	r0, #1
    27b2:	d1e2      	bne.n	277a <_usb_ep0setup+0x2aa>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
    27b4:	23c8      	movs	r3, #200	; 0xc8
    27b6:	4a15      	ldr	r2, [pc, #84]	; (280c <_usb_ep0setup+0x33c>)
    27b8:	e7ca      	b.n	2750 <_usb_ep0setup+0x280>
    27ba:	b672      	cpsid	i
    27bc:	f7fe fc40 	bl	1040 <_dbg_check_lock_from_isr>
        usbDisableEndpointsI(usbp);
    27c0:	0020      	movs	r0, r4
    27c2:	f7ff fd5d 	bl	2280 <usbDisableEndpointsI>
  _dbg_check_unlock_from_isr();
    27c6:	f7fe fc53 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    27ca:	b662      	cpsie	i
        usbp->state = USB_SELECTED;
    27cc:	2303      	movs	r3, #3
        usbp->configuration = 0U;
    27ce:	55e5      	strb	r5, [r4, r7]
        usbp->state = USB_SELECTED;
    27d0:	7023      	strb	r3, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
    27d2:	6863      	ldr	r3, [r4, #4]
    27d4:	681b      	ldr	r3, [r3, #0]
    27d6:	2b00      	cmp	r3, #0
    27d8:	d002      	beq.n	27e0 <_usb_ep0setup+0x310>
    27da:	2103      	movs	r1, #3
    27dc:	0020      	movs	r0, r4
    27de:	4798      	blx	r3
    27e0:	5da3      	ldrb	r3, [r4, r6]
    27e2:	e74f      	b.n	2684 <_usb_ep0setup+0x1b4>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
    27e4:	f000 fe6c 	bl	34c0 <usb_lld_clear_in>
    27e8:	23d4      	movs	r3, #212	; 0xd4
    27ea:	5ce0      	ldrb	r0, [r4, r3]
    27ec:	e709      	b.n	2602 <_usb_ep0setup+0x132>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
    27ee:	f000 fe47 	bl	3480 <usb_lld_stall_in>
    27f2:	5da0      	ldrb	r0, [r4, r6]
    27f4:	e705      	b.n	2602 <_usb_ep0setup+0x132>
    27f6:	46c0      	nop			; (mov r8, r8)
    27f8:	00000c02 	.word	0x00000c02
    27fc:	00000302 	.word	0x00000302
    2800:	00002131 	.word	0x00002131
    2804:	00007e38 	.word	0x00007e38
    2808:	00007e30 	.word	0x00007e30
    280c:	00007e34 	.word	0x00007e34

00002810 <_usb_ep0in>:
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
    2810:	23c4      	movs	r3, #196	; 0xc4
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
    2812:	b510      	push	{r4, lr}
  switch (usbp->ep0state) {
    2814:	5cc3      	ldrb	r3, [r0, r3]
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
    2816:	0004      	movs	r4, r0
  switch (usbp->ep0state) {
    2818:	2b06      	cmp	r3, #6
    281a:	d842      	bhi.n	28a2 <_usb_ep0in+0x92>
    281c:	4a2b      	ldr	r2, [pc, #172]	; (28cc <_usb_ep0in+0xbc>)
    281e:	009b      	lsls	r3, r3, #2
    2820:	58d3      	ldr	r3, [r2, r3]
    2822:	469f      	mov	pc, r3
    return;
  case USB_EP0_WAITING_SETUP:
  case USB_EP0_WAITING_STS:
  case USB_EP0_RX:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
    2824:	482a      	ldr	r0, [pc, #168]	; (28d0 <_usb_ep0in+0xc0>)
    2826:	f7fe fb8b 	bl	f40 <chSysHalt>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    282a:	2100      	movs	r1, #0
    282c:	0020      	movs	r0, r4
    282e:	f000 fe27 	bl	3480 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
    2832:	2100      	movs	r1, #0
    2834:	0020      	movs	r0, r4
    2836:	f000 fe13 	bl	3460 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    283a:	6863      	ldr	r3, [r4, #4]
    283c:	681b      	ldr	r3, [r3, #0]
    283e:	2b00      	cmp	r3, #0
    2840:	d002      	beq.n	2848 <_usb_ep0in+0x38>
    2842:	2106      	movs	r1, #6
    2844:	0020      	movs	r0, r4
    2846:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
    2848:	23c4      	movs	r3, #196	; 0xc4
    284a:	2206      	movs	r2, #6
    284c:	54e2      	strb	r2, [r4, r3]
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
    284e:	bd10      	pop	{r4, pc}
    if ((usbp->ep0n < max) &&
    2850:	23cc      	movs	r3, #204	; 0xcc
    2852:	58c0      	ldr	r0, [r0, r3]
  hw |= (uint16_t)*p << 8U;
    2854:	330f      	adds	r3, #15
    2856:	5ce2      	ldrb	r2, [r4, r3]
  hw  = (uint16_t)*p++;
    2858:	3b01      	subs	r3, #1
  hw |= (uint16_t)*p << 8U;
    285a:	5ce3      	ldrb	r3, [r4, r3]
    285c:	0212      	lsls	r2, r2, #8
    max = (size_t)get_hword(&usbp->setup[6]);
    285e:	4313      	orrs	r3, r2
    if ((usbp->ep0n < max) &&
    2860:	4298      	cmp	r0, r3
    2862:	d205      	bcs.n	2870 <_usb_ep0in+0x60>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
    2864:	68e3      	ldr	r3, [r4, #12]
    2866:	8a19      	ldrh	r1, [r3, #16]
    2868:	f7fd fee6 	bl	638 <__aeabi_uidivmod>
    if ((usbp->ep0n < max) &&
    286c:	2900      	cmp	r1, #0
    286e:	d01c      	beq.n	28aa <_usb_ep0in+0x9a>
    usbp->ep0state = USB_EP0_WAITING_STS;
    2870:	23c4      	movs	r3, #196	; 0xc4
    2872:	2203      	movs	r2, #3
    2874:	54e2      	strb	r2, [r4, r3]
  __ASM volatile ("cpsid i" : : : "memory");
    2876:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2878:	f7fe fbe2 	bl	1040 <_dbg_check_lock_from_isr>
    usbStartReceiveI(usbp, 0, NULL, 0);
    287c:	2300      	movs	r3, #0
    287e:	2200      	movs	r2, #0
    2880:	2100      	movs	r1, #0
    2882:	0020      	movs	r0, r4
    2884:	f7ff fd3c 	bl	2300 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
    2888:	f7fe fbf2 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    288c:	b662      	cpsie	i
    288e:	e7de      	b.n	284e <_usb_ep0in+0x3e>
    if (usbp->ep0endcb != NULL) {
    2890:	23d0      	movs	r3, #208	; 0xd0
    2892:	58c3      	ldr	r3, [r0, r3]
    2894:	2b00      	cmp	r3, #0
    2896:	d000      	beq.n	289a <_usb_ep0in+0x8a>
      usbp->ep0endcb(usbp);
    2898:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
    289a:	23c4      	movs	r3, #196	; 0xc4
    289c:	2200      	movs	r2, #0
    289e:	54e2      	strb	r2, [r4, r3]
    return;
    28a0:	e7d5      	b.n	284e <_usb_ep0in+0x3e>
    osalDbgAssert(false, "EP0 state machine invalid state");
    28a2:	480b      	ldr	r0, [pc, #44]	; (28d0 <_usb_ep0in+0xc0>)
    28a4:	f7fe fb4c 	bl	f40 <chSysHalt>
    28a8:	e7d1      	b.n	284e <_usb_ep0in+0x3e>
  __ASM volatile ("cpsid i" : : : "memory");
    28aa:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    28ac:	f7fe fbc8 	bl	1040 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
    28b0:	2300      	movs	r3, #0
    28b2:	2200      	movs	r2, #0
    28b4:	2100      	movs	r1, #0
    28b6:	0020      	movs	r0, r4
    28b8:	f7ff fd5a 	bl	2370 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
    28bc:	f7fe fbd8 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    28c0:	b662      	cpsie	i
      usbp->ep0state = USB_EP0_WAITING_TX0;
    28c2:	23c4      	movs	r3, #196	; 0xc4
    28c4:	2202      	movs	r2, #2
    28c6:	54e2      	strb	r2, [r4, r3]
      return;
    28c8:	e7c1      	b.n	284e <_usb_ep0in+0x3e>
    28ca:	46c0      	nop			; (mov r8, r8)
    28cc:	00007d74 	.word	0x00007d74
    28d0:	00007e18 	.word	0x00007e18
	...

000028e0 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
    28e0:	23c4      	movs	r3, #196	; 0xc4
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
    28e2:	b510      	push	{r4, lr}
  switch (usbp->ep0state) {
    28e4:	5cc3      	ldrb	r3, [r0, r3]
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
    28e6:	0004      	movs	r4, r0
  switch (usbp->ep0state) {
    28e8:	2b06      	cmp	r3, #6
    28ea:	d837      	bhi.n	295c <_usb_ep0out+0x7c>
    28ec:	4a1d      	ldr	r2, [pc, #116]	; (2964 <_usb_ep0out+0x84>)
    28ee:	009b      	lsls	r3, r3, #2
    28f0:	58d3      	ldr	r3, [r2, r3]
    28f2:	469f      	mov	pc, r3
  case USB_EP0_WAITING_SETUP:
  case USB_EP0_TX:
  case USB_EP0_WAITING_TX0:
  case USB_EP0_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
    28f4:	481c      	ldr	r0, [pc, #112]	; (2968 <_usb_ep0out+0x88>)
    28f6:	f7fe fb23 	bl	f40 <chSysHalt>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    28fa:	2100      	movs	r1, #0
    28fc:	0020      	movs	r0, r4
    28fe:	f000 fdbf 	bl	3480 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
    2902:	2100      	movs	r1, #0
    2904:	0020      	movs	r0, r4
    2906:	f000 fdab 	bl	3460 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    290a:	6863      	ldr	r3, [r4, #4]
    290c:	681b      	ldr	r3, [r3, #0]
    290e:	2b00      	cmp	r3, #0
    2910:	d002      	beq.n	2918 <_usb_ep0out+0x38>
    2912:	2106      	movs	r1, #6
    2914:	0020      	movs	r0, r4
    2916:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
    2918:	23c4      	movs	r3, #196	; 0xc4
    291a:	2206      	movs	r2, #6
    291c:	54e2      	strb	r2, [r4, r3]
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
    291e:	bd10      	pop	{r4, pc}
    usbp->ep0state = USB_EP0_SENDING_STS;
    2920:	23c4      	movs	r3, #196	; 0xc4
    2922:	2205      	movs	r2, #5
    2924:	54c2      	strb	r2, [r0, r3]
  __ASM volatile ("cpsid i" : : : "memory");
    2926:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2928:	f7fe fb8a 	bl	1040 <_dbg_check_lock_from_isr>
    usbStartTransmitI(usbp, 0, NULL, 0);
    292c:	2300      	movs	r3, #0
    292e:	2200      	movs	r2, #0
    2930:	2100      	movs	r1, #0
    2932:	0020      	movs	r0, r4
    2934:	f7ff fd1c 	bl	2370 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
    2938:	f7fe fb9a 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    293c:	b662      	cpsie	i
    293e:	e7ee      	b.n	291e <_usb_ep0out+0x3e>
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
    2940:	68c3      	ldr	r3, [r0, #12]
    2942:	699b      	ldr	r3, [r3, #24]
    2944:	685b      	ldr	r3, [r3, #4]
    2946:	2b00      	cmp	r3, #0
    2948:	d1e9      	bne.n	291e <_usb_ep0out+0x3e>
    if (usbp->ep0endcb != NULL) {
    294a:	33d0      	adds	r3, #208	; 0xd0
    294c:	58c3      	ldr	r3, [r0, r3]
    294e:	2b00      	cmp	r3, #0
    2950:	d000      	beq.n	2954 <_usb_ep0out+0x74>
      usbp->ep0endcb(usbp);
    2952:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
    2954:	23c4      	movs	r3, #196	; 0xc4
    2956:	2200      	movs	r2, #0
    2958:	54e2      	strb	r2, [r4, r3]
    return;
    295a:	e7e0      	b.n	291e <_usb_ep0out+0x3e>
    osalDbgAssert(false, "EP0 state machine invalid state");
    295c:	4802      	ldr	r0, [pc, #8]	; (2968 <_usb_ep0out+0x88>)
    295e:	f7fe faef 	bl	f40 <chSysHalt>
    2962:	e7dc      	b.n	291e <_usb_ep0out+0x3e>
    2964:	00007d90 	.word	0x00007d90
    2968:	00007e24 	.word	0x00007e24
    296c:	00000000 	.word	0x00000000

00002970 <nvicEnableVector>:

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
    2970:	0003      	movs	r3, r0
    2972:	4a09      	ldr	r2, [pc, #36]	; (2998 <nvicEnableVector+0x28>)
    2974:	33c0      	adds	r3, #192	; 0xc0
    2976:	0189      	lsls	r1, r1, #6
    2978:	009b      	lsls	r3, r3, #2
    297a:	5099      	str	r1, [r3, r2]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
    297c:	221f      	movs	r2, #31
    297e:	2301      	movs	r3, #1
    2980:	4002      	ands	r2, r0
    2982:	4093      	lsls	r3, r2
    2984:	4a04      	ldr	r2, [pc, #16]	; (2998 <nvicEnableVector+0x28>)
    2986:	0940      	lsrs	r0, r0, #5
    2988:	4694      	mov	ip, r2
    298a:	22c0      	movs	r2, #192	; 0xc0
    298c:	0080      	lsls	r0, r0, #2
    298e:	4460      	add	r0, ip
    2990:	0052      	lsls	r2, r2, #1
    2992:	5083      	str	r3, [r0, r2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
    2994:	6003      	str	r3, [r0, #0]
}
    2996:	4770      	bx	lr
    2998:	e000e100 	.word	0xe000e100
    299c:	00000000 	.word	0x00000000

000029a0 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
    29a0:	b570      	push	{r4, r5, r6, lr}
    29a2:	0004      	movs	r4, r0
    29a4:	000d      	movs	r5, r1

  osalDbgCheck(handler < 12U);
    29a6:	280b      	cmp	r0, #11
    29a8:	d902      	bls.n	29b0 <nvicSetSystemHandlerPriority+0x10>
    29aa:	4805      	ldr	r0, [pc, #20]	; (29c0 <nvicSetSystemHandlerPriority+0x20>)
    29ac:	f7fe fac8 	bl	f40 <chSysHalt>
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
    29b0:	4b04      	ldr	r3, [pc, #16]	; (29c4 <nvicSetSystemHandlerPriority+0x24>)
    29b2:	00a4      	lsls	r4, r4, #2
    29b4:	469c      	mov	ip, r3
    29b6:	01ad      	lsls	r5, r5, #6
    29b8:	4464      	add	r4, ip
    29ba:	6065      	str	r5, [r4, #4]
#endif
}
    29bc:	bd70      	pop	{r4, r5, r6, pc}
    29be:	46c0      	nop			; (mov r8, r8)
    29c0:	00007e3c 	.word	0x00007e3c
    29c4:	e000ed18 	.word	0xe000ed18
	...

000029d0 <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
}
    29d0:	4770      	bx	lr
    29d2:	46c0      	nop			; (mov r8, r8)
	...

000029e0 <kl2x_clock_init>:
 */
void kl2x_clock_init(void) {
#if !KINETIS_NO_INIT

  /* Disable COP watchdog */
  SIM->COPC = 0;
    29e0:	2288      	movs	r2, #136	; 0x88
    29e2:	2100      	movs	r1, #0

  /* Enable PORTA */
  SIM->SCGC5 |= SIM_SCGC5_PORTA;
    29e4:	2080      	movs	r0, #128	; 0x80
  SIM->COPC = 0;
    29e6:	4b37      	ldr	r3, [pc, #220]	; (2ac4 <kl2x_clock_init+0xe4>)
    29e8:	0152      	lsls	r2, r2, #5
void kl2x_clock_init(void) {
    29ea:	b570      	push	{r4, r5, r6, lr}
  SIM->COPC = 0;
    29ec:	5099      	str	r1, [r3, r2]
  SIM->SCGC5 |= SIM_SCGC5_PORTA;
    29ee:	4936      	ldr	r1, [pc, #216]	; (2ac8 <kl2x_clock_init+0xe8>)
    29f0:	0080      	lsls	r0, r0, #2
    29f2:	585a      	ldr	r2, [r3, r1]
void kl2x_clock_init(void) {
    29f4:	b088      	sub	sp, #32
  SIM->SCGC5 |= SIM_SCGC5_PORTA;
    29f6:	4302      	orrs	r2, r0
    29f8:	505a      	str	r2, [r3, r1]
     Typical f_MCGOUTCLK = 21 MHz immediately after reset.
     C4[DMX32]=0 and C4[DRST_DRS]=00  =>  FLL factor=640.
     C3[SCTRIM] and C4[SCFTRIM] factory trim values apply to f_int. */

  /* System oscillator drives 32 kHz clock (OSC32KSEL=0) */
  SIM->SOPT1 &= ~SIM_SOPT1_OSC32KSEL_MASK;
    29fa:	681a      	ldr	r2, [r3, #0]
    29fc:	4933      	ldr	r1, [pc, #204]	; (2acc <kl2x_clock_init+0xec>)
    29fe:	400a      	ands	r2, r1
  /* TODO - not implemented - is it required? Freescale example code
     seems to omit it. */

#elif KINETIS_MCG_MODE == KINETIS_MCG_MODE_PEE
  uint32_t ratio, frdiv;
  uint32_t ratios[] = { 32, 64, 128, 256, 512, 1024, 1280, 1536 };
    2a00:	4669      	mov	r1, sp
  SIM->SOPT1 &= ~SIM_SOPT1_OSC32KSEL_MASK;
    2a02:	601a      	str	r2, [r3, #0]
  uint32_t ratios[] = { 32, 64, 128, 256, 512, 1024, 1280, 1536 };
    2a04:	000a      	movs	r2, r1
    2a06:	4b32      	ldr	r3, [pc, #200]	; (2ad0 <kl2x_clock_init+0xf0>)
    2a08:	cb70      	ldmia	r3!, {r4, r5, r6}
    2a0a:	c270      	stmia	r2!, {r4, r5, r6}
    2a0c:	cb70      	ldmia	r3!, {r4, r5, r6}
    2a0e:	c270      	stmia	r2!, {r4, r5, r6}
    2a10:	cb30      	ldmia	r3!, {r4, r5}
    2a12:	c230      	stmia	r2!, {r4, r5}
   *   f_SYS = f_MCGOUTCLK / OUTDIV1 = 96 MHz / 2 = 48 MHz
   *   f_BUS = f_MCGOUTCLK / OUTDIV1 / OUTDIV4 = 96 MHz / 4 = 24 MHz
   */

  /* EXTAL0 and XTAL0 */
  PORTA->PCR[18] &= ~0x01000700; /* Set PA18 to analog (default) */
    2a14:	4b2f      	ldr	r3, [pc, #188]	; (2ad4 <kl2x_clock_init+0xf4>)
    2a16:	4d30      	ldr	r5, [pc, #192]	; (2ad8 <kl2x_clock_init+0xf8>)
    2a18:	6c9c      	ldr	r4, [r3, #72]	; 0x48
    2a1a:	402c      	ands	r4, r5
    2a1c:	649c      	str	r4, [r3, #72]	; 0x48
  PORTA->PCR[19] &= ~0x01000700; /* Set PA19 to analog (default) */
    2a1e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
         resistor since FRDM-KL25Z has feedback resistor R25 unpopulated.
         Use high-gain mode by setting C2[HGO0] instead if external
         feedback resistor Rf is installed.  */
  MCG->C2 = MCG_C2_EREFS0;      /* external reference (using a crystal) */
  if (KINETIS_XTAL_FREQUENCY > 8000000UL)
    MCG->C2 |= MCG_C2_RANGE0(2);
    2a20:	2420      	movs	r4, #32
  PORTA->PCR[19] &= ~0x01000700; /* Set PA19 to analog (default) */
    2a22:	402a      	ands	r2, r5
    2a24:	64da      	str	r2, [r3, #76]	; 0x4c
  OSC0->CR = KINETIS_BOARD_OSCILLATOR_SETTING;
    2a26:	228a      	movs	r2, #138	; 0x8a
    2a28:	4b2c      	ldr	r3, [pc, #176]	; (2adc <kl2x_clock_init+0xfc>)
    2a2a:	701a      	strb	r2, [r3, #0]
  MCG->C2 = MCG_C2_EREFS0;      /* external reference (using a crystal) */
    2a2c:	4b2c      	ldr	r3, [pc, #176]	; (2ae0 <kl2x_clock_init+0x100>)
    2a2e:	3a86      	subs	r2, #134	; 0x86
    2a30:	705a      	strb	r2, [r3, #1]
    MCG->C2 |= MCG_C2_RANGE0(2);
    2a32:	785a      	ldrb	r2, [r3, #1]
    2a34:	4322      	orrs	r2, r4
    2a36:	705a      	strb	r2, [r3, #1]
    2a38:	2300      	movs	r3, #0
    MCG->C2 |= MCG_C2_RANGE0(1);
  /* (2) Write to C1 to select the clock mode. */
  frdiv = 7;
  ratio = KINETIS_XTAL_FREQUENCY / 31250UL;
  for (i = 0; i < ratio_quantity; ++i) {
    if (ratio == ratios[i]) {
    2a3a:	009a      	lsls	r2, r3, #2
    2a3c:	588a      	ldr	r2, [r1, r2]
    2a3e:	4282      	cmp	r2, r0
    2a40:	d039      	beq.n	2ab6 <kl2x_clock_init+0xd6>
    2a42:	3301      	adds	r3, #1
  for (i = 0; i < ratio_quantity; ++i) {
    2a44:	2b08      	cmp	r3, #8
    2a46:	d1f8      	bne.n	2a3a <kl2x_clock_init+0x5a>
    2a48:	22b8      	movs	r2, #184	; 0xb8
      break;
    }
  }

  /* Switch to crystal as clock source, FLL input of 31.25 KHz */
  MCG->C1 = /* Clear the IREFS bit to switch to the external reference. */
    2a4a:	4b25      	ldr	r3, [pc, #148]	; (2ae0 <kl2x_clock_init+0x100>)
    2a4c:	701a      	strb	r2, [r3, #0]
          MCG_C1_CLKS_ERCLK |  /* Use Ext Ref Clock for system clock, MCGCLKOUT. */
          MCG_C1_FRDIV(frdiv); /* Divide ERCLK / 256 for FLL reference. */
  /* Note: FLL reference frequency must be 31.25 kHz to 39.0625 kHz. */

  MCG->C4 &= ~(MCG_C4_DMX32 | MCG_C4_DRST_DRS_MASK);
    2a4e:	221f      	movs	r2, #31
    2a50:	78d9      	ldrb	r1, [r3, #3]
    2a52:	400a      	ands	r2, r1
    2a54:	70da      	strb	r2, [r3, #3]
  MCG->C6 = 0;  /* PLLS=0: Select FLL as MCG source, not PLL */
    2a56:	2200      	movs	r2, #0
  /* (3) Once configuration is set, wait for MCG mode change. */

  /* From KL25P80M48SF0RM section 24.5.31: */
  /* (1)(c) Loop until S[OSCINIT0] is 1, indicating the
     crystal selected by C2[EREFS0] has been initialized. */
  while ((MCG->S & MCG_S_OSCINIT0) == 0)
    2a58:	2102      	movs	r1, #2
  MCG->C6 = 0;  /* PLLS=0: Select FLL as MCG source, not PLL */
    2a5a:	715a      	strb	r2, [r3, #5]
  while ((MCG->S & MCG_S_OSCINIT0) == 0)
    2a5c:	799a      	ldrb	r2, [r3, #6]
    2a5e:	4211      	tst	r1, r2
    2a60:	d0fc      	beq.n	2a5c <kl2x_clock_init+0x7c>
    ;
  /* (1)(d) Loop until S[IREFST] is 0, indicating the
     external reference is the current reference clock source. */
  while ((MCG->S & MCG_S_IREFST) != 0)
    2a62:	2210      	movs	r2, #16
    2a64:	491e      	ldr	r1, [pc, #120]	; (2ae0 <kl2x_clock_init+0x100>)
    2a66:	798b      	ldrb	r3, [r1, #6]
    2a68:	421a      	tst	r2, r3
    2a6a:	d1fc      	bne.n	2a66 <kl2x_clock_init+0x86>
    ;  /* Wait until external reference clock is FLL reference. */
  /* (1)(e) Loop until S[CLKST] is 2'b10, indicating
     the external reference clock is selected to feed MCGOUTCLK. */
  while ((MCG->S & MCG_S_CLKST_MASK) != MCG_S_CLKST_ERCLK)
    2a6c:	210c      	movs	r1, #12
    2a6e:	4a1c      	ldr	r2, [pc, #112]	; (2ae0 <kl2x_clock_init+0x100>)
    2a70:	7993      	ldrb	r3, [r2, #6]
    2a72:	400b      	ands	r3, r1
    2a74:	2b08      	cmp	r3, #8
    2a76:	d1fb      	bne.n	2a70 <kl2x_clock_init+0x90>
  /* (2)    Then configure C5[PRDIV0] to generate the
     correct PLL reference frequency. */
  #define KINETIS_PLLIN_FREQUENCY 2000000UL
  /* TODO: Make sure KINETIS_XTAL_FREQUENCY >= 2Mhz && <= 50Mhz */
  /* PLL External Reference Divide by ... */
  MCG->C5 = MCG_C5_PRDIV0((KINETIS_XTAL_FREQUENCY/KINETIS_PLLIN_FREQUENCY) - 1);
    2a78:	3b01      	subs	r3, #1
    2a7a:	7113      	strb	r3, [r2, #4]
  /* Config PLL output to match KINETIS_SYSCLK_FREQUENCY
   * TODO: make sure KINETIS_SYSCLK_FREQUENCY is a match */
  for(i = 24; i < 56; i++) {
    if(i == (KINETIS_PLLCLK_FREQUENCY/KINETIS_PLLIN_FREQUENCY)) {
      /* Config PLL to match KINETIS_PLLCLK_FREQUENCY */
      MCG->C6 = MCG_C6_PLLS | MCG_C6_VDIV0(i-24);
    2a7c:	3351      	adds	r3, #81	; 0x51
    2a7e:	7153      	strb	r3, [r2, #5]
  if(i>=56) /* Config PLL for 96 MHz output as default setting */
    MCG->C6 = MCG_C6_PLLS | MCG_C6_VDIV0(0);

  /* (3)(d) Loop until S[PLLST], indicating PLL
     is the PLLS clock source. */
  while ((MCG->S & MCG_S_PLLST) == 0)
    2a80:	2220      	movs	r2, #32
    2a82:	4917      	ldr	r1, [pc, #92]	; (2ae0 <kl2x_clock_init+0x100>)
    2a84:	798b      	ldrb	r3, [r1, #6]
    2a86:	421a      	tst	r2, r3
    2a88:	d0fc      	beq.n	2a84 <kl2x_clock_init+0xa4>
    ;  /* wait until PLL is the PLLS clock source. */
  /* (3)(e) Loop until S[LOCK0] is set, indicating the PLL has acquired lock. */
  /* PLL selected as MCG source. VDIV0=00000 (Multiply=24). */
  while ((MCG->S & MCG_S_LOCK0) == 0)
    2a8a:	2140      	movs	r1, #64	; 0x40
    2a8c:	4a14      	ldr	r2, [pc, #80]	; (2ae0 <kl2x_clock_init+0x100>)
    2a8e:	7993      	ldrb	r3, [r2, #6]
    2a90:	4219      	tst	r1, r3
    2a92:	d0fc      	beq.n	2a8e <kl2x_clock_init+0xae>
  /* Set the PLL dividers for the different clocks */
  /* The MCGOUTCLK is divided by OUTDIV1 and OUTDIV4:
   * OUTDIV1 (divider for core/system and bus/flash clock)
   * OUTDIV4 (additional divider for bus/flash clock)
   *  - these are computed in .h */
  SIM->CLKDIV1 =
    2a94:	4b0b      	ldr	r3, [pc, #44]	; (2ac4 <kl2x_clock_init+0xe4>)
    2a96:	4913      	ldr	r1, [pc, #76]	; (2ae4 <kl2x_clock_init+0x104>)
    2a98:	4813      	ldr	r0, [pc, #76]	; (2ae8 <kl2x_clock_init+0x108>)
    2a9a:	5058      	str	r0, [r3, r1]
          SIM_CLKDIV1_OUTDIV1(KINETIS_CLKDIV1_OUTDIV1-1) |
          SIM_CLKDIV1_OUTDIV4(KINETIS_CLKDIV1_OUTDIV4-1);

  SIM->SOPT2 =
    2a9c:	4913      	ldr	r1, [pc, #76]	; (2aec <kl2x_clock_init+0x10c>)
    2a9e:	4814      	ldr	r0, [pc, #80]	; (2af0 <kl2x_clock_init+0x110>)
    2aa0:	5058      	str	r0, [r3, r1]
  /* (4)(a) C1[CLKS] = 2'b00 to select PLL output as system clock source. */
  // Switch to PEE mode
  //    Select PLL output (CLKS=0)
  //    FLL external reference divider (FRDIV) already set
  //    External reference clock for FLL (IREFS=0)
  MCG->C1 = MCG_C1_CLKS(0);
    2aa2:	2300      	movs	r3, #0
    2aa4:	7013      	strb	r3, [r2, #0]
  /* (4)(b) Loop until S[CLKST] are 2'b11, indicating the PLL output is selected for MCGOUTCLK. */
  while ((MCG->S & MCG_S_CLKST_MASK) != MCG_S_CLKST_PLL)
    2aa6:	220c      	movs	r2, #12
    2aa8:	490d      	ldr	r1, [pc, #52]	; (2ae0 <kl2x_clock_init+0x100>)
    2aaa:	798b      	ldrb	r3, [r1, #6]
    2aac:	4013      	ands	r3, r2
    2aae:	2b0c      	cmp	r3, #12
    2ab0:	d1fb      	bne.n	2aaa <kl2x_clock_init+0xca>
#endif /* KINETIS_MCG_MODE != KINETIS_MCG_MODE_PEE */

#endif /* KINETIS_HAS_MCG_LITE */

#endif /* !KINETIS_NO_INIT */
}
    2ab2:	b008      	add	sp, #32
    2ab4:	bd70      	pop	{r4, r5, r6, pc}
    2ab6:	2280      	movs	r2, #128	; 0x80
    2ab8:	00db      	lsls	r3, r3, #3
    2aba:	4252      	negs	r2, r2
    2abc:	431a      	orrs	r2, r3
    2abe:	b2d2      	uxtb	r2, r2
      break;
    2ac0:	e7c3      	b.n	2a4a <kl2x_clock_init+0x6a>
    2ac2:	46c0      	nop			; (mov r8, r8)
    2ac4:	40047000 	.word	0x40047000
    2ac8:	00001038 	.word	0x00001038
    2acc:	fff3ffff 	.word	0xfff3ffff
    2ad0:	00007a04 	.word	0x00007a04
    2ad4:	40049000 	.word	0x40049000
    2ad8:	fefff8ff 	.word	0xfefff8ff
    2adc:	40065000 	.word	0x40065000
    2ae0:	40064000 	.word	0x40064000
    2ae4:	00001044 	.word	0x00001044
    2ae8:	10010000 	.word	0x10010000
    2aec:	00001004 	.word	0x00001004
    2af0:	01010000 	.word	0x01010000
	...

00002b00 <_pal_lld_readpad>:
 * @notapi
 */
uint8_t _pal_lld_readpad(ioportid_t port,
                         uint8_t pad) {

  return (port->PDIR & ((uint32_t) 1 << pad)) ? PAL_HIGH : PAL_LOW;
    2b00:	6903      	ldr	r3, [r0, #16]
    2b02:	2001      	movs	r0, #1
    2b04:	40cb      	lsrs	r3, r1
    2b06:	4018      	ands	r0, r3
}
    2b08:	4770      	bx	lr
    2b0a:	46c0      	nop			; (mov r8, r8)
    2b0c:	0000      	movs	r0, r0
	...

00002b10 <_pal_lld_setpadmode>:
 *
 * @notapi
 */
void _pal_lld_setpadmode(ioportid_t port,
                         uint8_t pad,
                         iomode_t mode) {
    2b10:	b570      	push	{r4, r5, r6, lr}
    2b12:	0004      	movs	r4, r0
    2b14:	000d      	movs	r5, r1
    2b16:	0016      	movs	r6, r2

  PORT_TypeDef *portcfg = NULL;

  osalDbgAssert(pad < PADS_PER_PORT, "pal_lld_setpadmode() #1, invalid pad");
    2b18:	291f      	cmp	r1, #31
    2b1a:	d834      	bhi.n	2b86 <_pal_lld_setpadmode+0x76>
    2b1c:	2301      	movs	r3, #1

  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    port->PDDR |= ((uint32_t) 1 << pad);
    2b1e:	6962      	ldr	r2, [r4, #20]
    2b20:	40ab      	lsls	r3, r5
  if (mode == PAL_MODE_OUTPUT_PUSHPULL)
    2b22:	2e06      	cmp	r6, #6
    2b24:	d021      	beq.n	2b6a <_pal_lld_setpadmode+0x5a>
  else
    port->PDDR &= ~((uint32_t) 1 << pad);
    2b26:	439a      	bics	r2, r3

  if (port == IOPORT1)
    2b28:	4b31      	ldr	r3, [pc, #196]	; (2bf0 <_pal_lld_setpadmode+0xe0>)
    port->PDDR &= ~((uint32_t) 1 << pad);
    2b2a:	6162      	str	r2, [r4, #20]
  if (port == IOPORT1)
    2b2c:	429c      	cmp	r4, r3
    2b2e:	d010      	beq.n	2b52 <_pal_lld_setpadmode+0x42>
    portcfg = PORTA;
  else if (port == IOPORT2)
    2b30:	4b30      	ldr	r3, [pc, #192]	; (2bf4 <_pal_lld_setpadmode+0xe4>)
    2b32:	429c      	cmp	r4, r3
    2b34:	d02b      	beq.n	2b8e <_pal_lld_setpadmode+0x7e>
    portcfg = PORTB;
  else if (port == IOPORT3)
    2b36:	4b30      	ldr	r3, [pc, #192]	; (2bf8 <_pal_lld_setpadmode+0xe8>)
    2b38:	429c      	cmp	r4, r3
    2b3a:	d053      	beq.n	2be4 <_pal_lld_setpadmode+0xd4>
    portcfg = PORTC;
  else if (port == IOPORT4)
    2b3c:	4b2f      	ldr	r3, [pc, #188]	; (2bfc <_pal_lld_setpadmode+0xec>)
    2b3e:	429c      	cmp	r4, r3
    2b40:	d052      	beq.n	2be8 <_pal_lld_setpadmode+0xd8>
    portcfg = PORTD;
  else if (port == IOPORT5)
    2b42:	4b2f      	ldr	r3, [pc, #188]	; (2c00 <_pal_lld_setpadmode+0xf0>)
    2b44:	429c      	cmp	r4, r3
    2b46:	d024      	beq.n	2b92 <_pal_lld_setpadmode+0x82>
    portcfg = PORTE;

  osalDbgAssert(portcfg != NULL, "pal_lld_setpadmode() #2, invalid port");
    2b48:	482e      	ldr	r0, [pc, #184]	; (2c04 <_pal_lld_setpadmode+0xf4>)
    2b4a:	f7fe f9f9 	bl	f40 <chSysHalt>
  PORT_TypeDef *portcfg = NULL;
    2b4e:	2300      	movs	r3, #0
    2b50:	e000      	b.n	2b54 <_pal_lld_setpadmode+0x44>
    portcfg = PORTA;
    2b52:	4b2d      	ldr	r3, [pc, #180]	; (2c08 <_pal_lld_setpadmode+0xf8>)

  switch (mode) {
    2b54:	2e16      	cmp	r6, #22
    2b56:	d807      	bhi.n	2b68 <_pal_lld_setpadmode+0x58>
    2b58:	4a2c      	ldr	r2, [pc, #176]	; (2c0c <_pal_lld_setpadmode+0xfc>)
    2b5a:	00b6      	lsls	r6, r6, #2
    2b5c:	5992      	ldr	r2, [r2, r6]
    2b5e:	4697      	mov	pc, r2
    break;
  case PAL_MODE_ALTERNATIVE_5:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(5);
    break;
  case PAL_MODE_ALTERNATIVE_6:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(6);
    2b60:	22c0      	movs	r2, #192	; 0xc0
    2b62:	00ad      	lsls	r5, r5, #2
    2b64:	00d2      	lsls	r2, r2, #3
    2b66:	50ea      	str	r2, [r5, r3]
    break;
  case PAL_MODE_ALTERNATIVE_7:
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(7);
    break;
  }
}
    2b68:	bd70      	pop	{r4, r5, r6, pc}
    port->PDDR |= ((uint32_t) 1 << pad);
    2b6a:	4313      	orrs	r3, r2
    2b6c:	6163      	str	r3, [r4, #20]
  if (port == IOPORT1)
    2b6e:	4b20      	ldr	r3, [pc, #128]	; (2bf0 <_pal_lld_setpadmode+0xe0>)
    2b70:	429c      	cmp	r4, r3
    2b72:	d03b      	beq.n	2bec <_pal_lld_setpadmode+0xdc>
  else if (port == IOPORT2)
    2b74:	4b1f      	ldr	r3, [pc, #124]	; (2bf4 <_pal_lld_setpadmode+0xe4>)
    2b76:	429c      	cmp	r4, r3
    2b78:	d1dd      	bne.n	2b36 <_pal_lld_setpadmode+0x26>
    portcfg = PORTB;
    2b7a:	4b25      	ldr	r3, [pc, #148]	; (2c10 <_pal_lld_setpadmode+0x100>)
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1);
    2b7c:	2280      	movs	r2, #128	; 0x80
    2b7e:	00ad      	lsls	r5, r5, #2
    2b80:	0052      	lsls	r2, r2, #1
    2b82:	50ea      	str	r2, [r5, r3]
    break;
    2b84:	e7f0      	b.n	2b68 <_pal_lld_setpadmode+0x58>
  osalDbgAssert(pad < PADS_PER_PORT, "pal_lld_setpadmode() #1, invalid pad");
    2b86:	481f      	ldr	r0, [pc, #124]	; (2c04 <_pal_lld_setpadmode+0xf4>)
    2b88:	f7fe f9da 	bl	f40 <chSysHalt>
    2b8c:	e7c6      	b.n	2b1c <_pal_lld_setpadmode+0xc>
    portcfg = PORTB;
    2b8e:	4b20      	ldr	r3, [pc, #128]	; (2c10 <_pal_lld_setpadmode+0x100>)
    2b90:	e7e0      	b.n	2b54 <_pal_lld_setpadmode+0x44>
    portcfg = PORTE;
    2b92:	4b20      	ldr	r3, [pc, #128]	; (2c14 <_pal_lld_setpadmode+0x104>)
    2b94:	e7de      	b.n	2b54 <_pal_lld_setpadmode+0x44>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(2);
    2b96:	2280      	movs	r2, #128	; 0x80
    2b98:	00ad      	lsls	r5, r5, #2
    2b9a:	0092      	lsls	r2, r2, #2
    2b9c:	50ea      	str	r2, [r5, r3]
    break;
    2b9e:	e7e3      	b.n	2b68 <_pal_lld_setpadmode+0x58>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(5);
    2ba0:	22a0      	movs	r2, #160	; 0xa0
    2ba2:	00ad      	lsls	r5, r5, #2
    2ba4:	00d2      	lsls	r2, r2, #3
    2ba6:	50ea      	str	r2, [r5, r3]
    break;
    2ba8:	e7de      	b.n	2b68 <_pal_lld_setpadmode+0x58>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(4);
    2baa:	2280      	movs	r2, #128	; 0x80
    2bac:	00ad      	lsls	r5, r5, #2
    2bae:	00d2      	lsls	r2, r2, #3
    2bb0:	50ea      	str	r2, [r5, r3]
    break;
    2bb2:	e7d9      	b.n	2b68 <_pal_lld_setpadmode+0x58>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(3);
    2bb4:	22c0      	movs	r2, #192	; 0xc0
    2bb6:	00ad      	lsls	r5, r5, #2
    2bb8:	0092      	lsls	r2, r2, #2
    2bba:	50ea      	str	r2, [r5, r3]
    break;
    2bbc:	e7d4      	b.n	2b68 <_pal_lld_setpadmode+0x58>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
    2bbe:	2281      	movs	r2, #129	; 0x81
    2bc0:	00ad      	lsls	r5, r5, #2
    2bc2:	0052      	lsls	r2, r2, #1
    2bc4:	50ea      	str	r2, [r5, r3]
      break;
    2bc6:	e7cf      	b.n	2b68 <_pal_lld_setpadmode+0x58>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(1) |
    2bc8:	2204      	movs	r2, #4
    2bca:	00ad      	lsls	r5, r5, #2
    2bcc:	32ff      	adds	r2, #255	; 0xff
    2bce:	50ea      	str	r2, [r5, r3]
      break;
    2bd0:	e7ca      	b.n	2b68 <_pal_lld_setpadmode+0x58>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(0);
    2bd2:	2200      	movs	r2, #0
    2bd4:	00ad      	lsls	r5, r5, #2
    2bd6:	50ea      	str	r2, [r5, r3]
    break;
    2bd8:	e7c6      	b.n	2b68 <_pal_lld_setpadmode+0x58>
    portcfg->PCR[pad] = PIN_MUX_ALTERNATIVE(7);
    2bda:	22e0      	movs	r2, #224	; 0xe0
    2bdc:	00ad      	lsls	r5, r5, #2
    2bde:	00d2      	lsls	r2, r2, #3
    2be0:	50ea      	str	r2, [r5, r3]
}
    2be2:	e7c1      	b.n	2b68 <_pal_lld_setpadmode+0x58>
    portcfg = PORTC;
    2be4:	4b0c      	ldr	r3, [pc, #48]	; (2c18 <_pal_lld_setpadmode+0x108>)
    2be6:	e7b5      	b.n	2b54 <_pal_lld_setpadmode+0x44>
    portcfg = PORTD;
    2be8:	4b0c      	ldr	r3, [pc, #48]	; (2c1c <_pal_lld_setpadmode+0x10c>)
    2bea:	e7b3      	b.n	2b54 <_pal_lld_setpadmode+0x44>
    portcfg = PORTA;
    2bec:	4b06      	ldr	r3, [pc, #24]	; (2c08 <_pal_lld_setpadmode+0xf8>)
    2bee:	e7c5      	b.n	2b7c <_pal_lld_setpadmode+0x6c>
    2bf0:	400ff000 	.word	0x400ff000
    2bf4:	400ff040 	.word	0x400ff040
    2bf8:	400ff080 	.word	0x400ff080
    2bfc:	400ff0c0 	.word	0x400ff0c0
    2c00:	400ff100 	.word	0x400ff100
    2c04:	00007eb8 	.word	0x00007eb8
    2c08:	40049000 	.word	0x40049000
    2c0c:	00007e5c 	.word	0x00007e5c
    2c10:	4004a000 	.word	0x4004a000
    2c14:	4004d000 	.word	0x4004d000
    2c18:	4004b000 	.word	0x4004b000
    2c1c:	4004c000 	.word	0x4004c000

00002c20 <_pal_lld_init>:
 *
 * @param[in] config    the Kinetis ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    2c20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  int i, j;

  /* Enable clocking on all Ports */
  SIM->SCGC5 |= SIM_SCGC5_PORTA |
    2c22:	23f8      	movs	r3, #248	; 0xf8
    2c24:	490b      	ldr	r1, [pc, #44]	; (2c54 <_pal_lld_init+0x34>)
    2c26:	4a0c      	ldr	r2, [pc, #48]	; (2c58 <_pal_lld_init+0x38>)
    2c28:	019b      	lsls	r3, r3, #6
    2c2a:	588c      	ldr	r4, [r1, r2]
    2c2c:	0006      	movs	r6, r0
    2c2e:	4323      	orrs	r3, r4
    2c30:	508b      	str	r3, [r1, r2]
    2c32:	23a5      	movs	r3, #165	; 0xa5
    2c34:	009b      	lsls	r3, r3, #2
    2c36:	18c7      	adds	r7, r0, r3
                SIM_SCGC5_PORTD |
                SIM_SCGC5_PORTE;

  /* Initial PORT and GPIO setup */
  for (i = 0; i < TOTAL_PORTS; i++) {
    for (j = 0; j < PADS_PER_PORT; j++) {
    2c38:	2400      	movs	r4, #0
    2c3a:	1d35      	adds	r5, r6, #4
      pal_lld_setpadmode(config->ports[i].port,
    2c3c:	b2e1      	uxtb	r1, r4
    2c3e:	cd04      	ldmia	r5!, {r2}
    2c40:	6830      	ldr	r0, [r6, #0]
    for (j = 0; j < PADS_PER_PORT; j++) {
    2c42:	3401      	adds	r4, #1
      pal_lld_setpadmode(config->ports[i].port,
    2c44:	f7ff ff64 	bl	2b10 <_pal_lld_setpadmode>
    for (j = 0; j < PADS_PER_PORT; j++) {
    2c48:	2c20      	cmp	r4, #32
    2c4a:	d1f7      	bne.n	2c3c <_pal_lld_init+0x1c>
    2c4c:	3684      	adds	r6, #132	; 0x84
  for (i = 0; i < TOTAL_PORTS; i++) {
    2c4e:	42be      	cmp	r6, r7
    2c50:	d1f2      	bne.n	2c38 <_pal_lld_init+0x18>
                         j,
                         config->ports[i].pads[j]);
    }
  }
}
    2c52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2c54:	40047000 	.word	0x40047000
    2c58:	00001038 	.word	0x00001038
    2c5c:	00000000 	.word	0x00000000

00002c60 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
    2c60:	b510      	push	{r4, lr}
    2c62:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();
    2c64:	f7fe fa1c 	bl	10a0 <_dbg_check_enter_isr>
  __ASM volatile ("cpsid i" : : : "memory");
    2c68:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2c6a:	f7fe f9e9 	bl	1040 <_dbg_check_lock_from_isr>
  chSysTimerHandlerI();
    2c6e:	f7fe f96f 	bl	f50 <chSysTimerHandlerI>
  _dbg_check_unlock_from_isr();
    2c72:	f7fe f9fd 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    2c76:	b662      	cpsie	i

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
    2c78:	f7fe fa2a 	bl	10d0 <_dbg_check_leave_isr>
    2c7c:	0020      	movs	r0, r4
    2c7e:	f7ff f8e7 	bl	1e50 <_port_irq_epilogue>
}
    2c82:	bd10      	pop	{r4, pc}
	...

00002c90 <st_lld_init>:
 */
void st_lld_init(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (KINETIS_SYSCLK_FREQUENCY / OSAL_ST_FREQUENCY) - 1;
    2c90:	4b06      	ldr	r3, [pc, #24]	; (2cac <st_lld_init+0x1c>)
    2c92:	4a07      	ldr	r2, [pc, #28]	; (2cb0 <st_lld_init+0x20>)
void st_lld_init(void) {
    2c94:	b510      	push	{r4, lr}
  SysTick->LOAD = (KINETIS_SYSCLK_FREQUENCY / OSAL_ST_FREQUENCY) - 1;
    2c96:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
    2c98:	2200      	movs	r2, #0
    2c9a:	609a      	str	r2, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
    2c9c:	3207      	adds	r2, #7
    2c9e:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, KINETIS_ST_IRQ_PRIORITY);
    2ca0:	2108      	movs	r1, #8
    2ca2:	200b      	movs	r0, #11
    2ca4:	f7ff fe7c 	bl	29a0 <nvicSetSystemHandlerPriority>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    2ca8:	bd10      	pop	{r4, pc}
    2caa:	46c0      	nop			; (mov r8, r8)
    2cac:	e000e010 	.word	0xe000e010
    2cb0:	0000bb7f 	.word	0x0000bb7f
	...

00002cc0 <usb_packet_transmit>:
/* Driver local functions.                                                   */
/*===========================================================================*/

/* Called from locked ISR. */
void usb_packet_transmit(USBDriver *usbp, usbep_t ep, size_t n)
{
    2cc0:	b5f0      	push	{r4, r5, r6, r7, lr}
  const USBEndpointConfig *epc = usbp->epc[ep];
  USBInEndpointState *isp = epc->in_state;

  bd_t *bd = (bd_t *)&_bdt[BDT_INDEX(ep, TX, isp->odd_even)];
    2cc2:	2402      	movs	r4, #2
  const USBEndpointConfig *epc = usbp->epc[ep];
    2cc4:	1c8b      	adds	r3, r1, #2
    2cc6:	009b      	lsls	r3, r3, #2
    2cc8:	18c0      	adds	r0, r0, r3
    2cca:	6840      	ldr	r0, [r0, #4]
  bd_t *bd = (bd_t *)&_bdt[BDT_INDEX(ep, TX, isp->odd_even)];
    2ccc:	0089      	lsls	r1, r1, #2
  USBInEndpointState *isp = epc->in_state;
    2cce:	6945      	ldr	r5, [r0, #20]
  
  if (n > (size_t)epc->in_maxsize)
    2cd0:	8a00      	ldrh	r0, [r0, #16]
  bd_t *bd = (bd_t *)&_bdt[BDT_INDEX(ep, TX, isp->odd_even)];
    2cd2:	7c2b      	ldrb	r3, [r5, #16]
    2cd4:	4321      	orrs	r1, r4
    2cd6:	4319      	orrs	r1, r3
    2cd8:	4290      	cmp	r0, r2
    2cda:	d900      	bls.n	2cde <usb_packet_transmit+0x1e>
    2cdc:	0010      	movs	r0, r2
    n = (size_t)epc->in_maxsize;

  /* Copy from buf to _usbb[] */
  size_t i=0;
  for(i=0;i<n;i++)
    2cde:	2800      	cmp	r0, #0
    2ce0:	d018      	beq.n	2d14 <usb_packet_transmit+0x54>
    2ce2:	2300      	movs	r3, #0
    2ce4:	4f0d      	ldr	r7, [pc, #52]	; (2d1c <usb_packet_transmit+0x5c>)
    2ce6:	00cc      	lsls	r4, r1, #3
    bd->addr[i] = isp->txbuf[i];
    2ce8:	193e      	adds	r6, r7, r4
    2cea:	68aa      	ldr	r2, [r5, #8]
    2cec:	5cd1      	ldrb	r1, [r2, r3]
    2cee:	6872      	ldr	r2, [r6, #4]
    2cf0:	54d1      	strb	r1, [r2, r3]
  for(i=0;i<n;i++)
    2cf2:	3301      	adds	r3, #1
    2cf4:	4283      	cmp	r3, r0
    2cf6:	d1f8      	bne.n	2cea <usb_packet_transmit+0x2a>
    2cf8:	7c2b      	ldrb	r3, [r5, #16]

  /* Update the Buffer status */
  bd->desc = BDT_DESC(n, isp->data_bank);
    2cfa:	2188      	movs	r1, #136	; 0x88
    2cfc:	7c6a      	ldrb	r2, [r5, #17]
    2cfe:	0400      	lsls	r0, r0, #16
    2d00:	4308      	orrs	r0, r1
    2d02:	0191      	lsls	r1, r2, #6
    2d04:	4308      	orrs	r0, r1
  /* Toggle the odd and data bits for next TX */
  isp->data_bank ^= DATA1;
    2d06:	2101      	movs	r1, #1
    2d08:	404a      	eors	r2, r1
  isp->odd_even ^= ODD;
    2d0a:	404b      	eors	r3, r1
  bd->desc = BDT_DESC(n, isp->data_bank);
    2d0c:	5138      	str	r0, [r7, r4]
  isp->data_bank ^= DATA1;
    2d0e:	746a      	strb	r2, [r5, #17]
  isp->odd_even ^= ODD;
    2d10:	742b      	strb	r3, [r5, #16]
}
    2d12:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2d14:	4f01      	ldr	r7, [pc, #4]	; (2d1c <usb_packet_transmit+0x5c>)
    2d16:	00cc      	lsls	r4, r1, #3
    2d18:	e7ef      	b.n	2cfa <usb_packet_transmit+0x3a>
    2d1a:	46c0      	nop			; (mov r8, r8)
    2d1c:	20000400 	.word	0x20000400

00002d20 <usb_packet_receive>:

/* Called from locked ISR. */
void usb_packet_receive(USBDriver *usbp, usbep_t ep, size_t n)
{
    2d20:	4684      	mov	ip, r0
    2d22:	0089      	lsls	r1, r1, #2
    2d24:	b5f0      	push	{r4, r5, r6, r7, lr}
    2d26:	448c      	add	ip, r1
    2d28:	46c6      	mov	lr, r8
  const USBEndpointConfig *epc = usbp->epc[ep];
    2d2a:	4663      	mov	r3, ip
{
    2d2c:	b500      	push	{lr}
  const USBEndpointConfig *epc = usbp->epc[ep];
    2d2e:	68df      	ldr	r7, [r3, #12]
  USBOutEndpointState *osp = epc->out_state;
    2d30:	69bd      	ldr	r5, [r7, #24]

  bd_t *bd = (bd_t *)&_bdt[BDT_INDEX(ep, RX, osp->odd_even)];
    2d32:	7cab      	ldrb	r3, [r5, #18]
    2d34:	4319      	orrs	r1, r3

  if (n > (size_t)epc->out_maxsize)
    2d36:	8a7b      	ldrh	r3, [r7, #18]
    2d38:	001c      	movs	r4, r3
    2d3a:	4293      	cmp	r3, r2
    2d3c:	d900      	bls.n	2d40 <usb_packet_receive+0x20>
    2d3e:	0014      	movs	r4, r2
    n = (size_t)epc->out_maxsize;

  /* Copy from _usbb[] to buf  */
  size_t i=0;
  for(i=0;i<n;i++)
    2d40:	2c00      	cmp	r4, #0
    2d42:	d029      	beq.n	2d98 <usb_packet_receive+0x78>
    2d44:	00ca      	lsls	r2, r1, #3
    2d46:	2300      	movs	r3, #0
    2d48:	4690      	mov	r8, r2
    2d4a:	4816      	ldr	r0, [pc, #88]	; (2da4 <usb_packet_receive+0x84>)
    osp->rxbuf[i] = bd->addr[i];
    2d4c:	1886      	adds	r6, r0, r2
    2d4e:	6872      	ldr	r2, [r6, #4]
    2d50:	68a9      	ldr	r1, [r5, #8]
    2d52:	5cd2      	ldrb	r2, [r2, r3]
    2d54:	54ca      	strb	r2, [r1, r3]
  for(i=0;i<n;i++)
    2d56:	3301      	adds	r3, #1
    2d58:	42a3      	cmp	r3, r4
    2d5a:	d1f8      	bne.n	2d4e <usb_packet_receive+0x2e>
    2d5c:	4662      	mov	r2, ip
    2d5e:	8a7b      	ldrh	r3, [r7, #18]
    2d60:	68d7      	ldr	r7, [r2, #12]
    2d62:	69bc      	ldr	r4, [r7, #24]

  /* Update the Buffer status
   * Set current buffer to same DATA bank and then toggle.
   * Since even/odd buffers are ping-pong and setup re-initialized them
   * this should work correctly */
  bd->desc = BDT_DESC(epc->out_maxsize, osp->data_bank);
    2d64:	2188      	movs	r1, #136	; 0x88
    2d66:	7cee      	ldrb	r6, [r5, #19]
    2d68:	041b      	lsls	r3, r3, #16
    2d6a:	01b2      	lsls	r2, r6, #6
    2d6c:	430a      	orrs	r2, r1
    2d6e:	4313      	orrs	r3, r2
    2d70:	4642      	mov	r2, r8
    2d72:	5083      	str	r3, [r0, r2]
  osp->data_bank ^= DATA1;
    2d74:	2301      	movs	r3, #1
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
    2d76:	6820      	ldr	r0, [r4, #0]
  osp->data_bank ^= DATA1;
    2d78:	405e      	eors	r6, r3
    2d7a:	74ee      	strb	r6, [r5, #19]
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
    2d7c:	2800      	cmp	r0, #0
    2d7e:	d008      	beq.n	2d92 <usb_packet_receive+0x72>
    osp->rxpkts = 1;
  else
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
    2d80:	8a79      	ldrh	r1, [r7, #18]
    2d82:	3801      	subs	r0, #1
    2d84:	1840      	adds	r0, r0, r1
    2d86:	f7fd fbd1 	bl	52c <__udivsi3>
    2d8a:	8220      	strh	r0, [r4, #16]
}
    2d8c:	bc04      	pop	{r2}
    2d8e:	4690      	mov	r8, r2
    2d90:	bdf0      	pop	{r4, r5, r6, r7, pc}
    osp->rxpkts = 1;
    2d92:	2301      	movs	r3, #1
    2d94:	8223      	strh	r3, [r4, #16]
    2d96:	e7f9      	b.n	2d8c <usb_packet_receive+0x6c>
    2d98:	00ca      	lsls	r2, r1, #3
  for(i=0;i<n;i++)
    2d9a:	002c      	movs	r4, r5
    2d9c:	4801      	ldr	r0, [pc, #4]	; (2da4 <usb_packet_receive+0x84>)
    2d9e:	4690      	mov	r8, r2
    2da0:	e7e0      	b.n	2d64 <usb_packet_receive+0x44>
    2da2:	46c0      	nop			; (mov r8, r8)
    2da4:	20000400 	.word	0x20000400
	...

00002db0 <VectorA0>:
OSAL_IRQ_HANDLER(KINETIS_USB_IRQ_VECTOR) {
    2db0:	b5f0      	push	{r4, r5, r6, r7, lr}
    2db2:	46de      	mov	lr, fp
    2db4:	4657      	mov	r7, sl
    2db6:	464e      	mov	r6, r9
    2db8:	4645      	mov	r5, r8
  uint8_t istat = USB0->ISTAT;
    2dba:	2380      	movs	r3, #128	; 0x80
OSAL_IRQ_HANDLER(KINETIS_USB_IRQ_VECTOR) {
    2dbc:	b5e0      	push	{r5, r6, r7, lr}
  uint8_t istat = USB0->ISTAT;
    2dbe:	4ac1      	ldr	r2, [pc, #772]	; (30c4 <VectorA0+0x314>)
OSAL_IRQ_HANDLER(KINETIS_USB_IRQ_VECTOR) {
    2dc0:	b083      	sub	sp, #12
  uint8_t istat = USB0->ISTAT;
    2dc2:	5cd4      	ldrb	r4, [r2, r3]
  OSAL_IRQ_PROLOGUE();
    2dc4:	4673      	mov	r3, lr
  uint8_t istat = USB0->ISTAT;
    2dc6:	b2e4      	uxtb	r4, r4
  OSAL_IRQ_PROLOGUE();
    2dc8:	9301      	str	r3, [sp, #4]
    2dca:	f7fe f969 	bl	10a0 <_dbg_check_enter_isr>
  if(istat & USBx_ISTAT_SOFTOK) {
    2dce:	0763      	lsls	r3, r4, #29
    2dd0:	d50a      	bpl.n	2de8 <VectorA0+0x38>
    _usb_isr_invoke_sof_cb(usbp);
    2dd2:	4fbd      	ldr	r7, [pc, #756]	; (30c8 <VectorA0+0x318>)
    2dd4:	687b      	ldr	r3, [r7, #4]
    2dd6:	68db      	ldr	r3, [r3, #12]
    2dd8:	2b00      	cmp	r3, #0
    2dda:	d001      	beq.n	2de0 <VectorA0+0x30>
    2ddc:	0038      	movs	r0, r7
    2dde:	4798      	blx	r3
    USB0->ISTAT = USBx_ISTAT_SOFTOK;
    2de0:	2380      	movs	r3, #128	; 0x80
    2de2:	2104      	movs	r1, #4
    2de4:	4ab7      	ldr	r2, [pc, #732]	; (30c4 <VectorA0+0x314>)
    2de6:	54d1      	strb	r1, [r2, r3]
  while(istat & USBx_ISTAT_TOKDNE) {
    2de8:	0723      	lsls	r3, r4, #28
    2dea:	d400      	bmi.n	2dee <VectorA0+0x3e>
    2dec:	e08f      	b.n	2f0e <VectorA0+0x15e>
    2dee:	4bb7      	ldr	r3, [pc, #732]	; (30cc <VectorA0+0x31c>)
    2df0:	4fb5      	ldr	r7, [pc, #724]	; (30c8 <VectorA0+0x318>)
    2df2:	469b      	mov	fp, r3
    uint8_t tx_rx    = (stat & USBx_STAT_TX_MASK) >> USBx_STAT_TX_SHIFT;
    2df4:	2301      	movs	r3, #1
    uint8_t stat = USB0->STAT;
    2df6:	4eb3      	ldr	r6, [pc, #716]	; (30c4 <VectorA0+0x314>)
    uint8_t tx_rx    = (stat & USBx_STAT_TX_MASK) >> USBx_STAT_TX_SHIFT;
    2df8:	4698      	mov	r8, r3
    2dfa:	e013      	b.n	2e24 <VectorA0+0x74>
    if(tx_rx == RX && epc->out_state != NULL)
    2dfc:	69ab      	ldr	r3, [r5, #24]
    2dfe:	2b00      	cmp	r3, #0
    2e00:	d100      	bne.n	2e04 <VectorA0+0x54>
    2e02:	e0b1      	b.n	2f68 <VectorA0+0x1b8>
      epc->out_state->odd_even = odd_even;
    2e04:	7498      	strb	r0, [r3, #18]
    switch(BDT_TOK_PID(bd->desc))
    2e06:	2909      	cmp	r1, #9
    2e08:	d100      	bne.n	2e0c <VectorA0+0x5c>
    2e0a:	e0cd      	b.n	2fa8 <VectorA0+0x1f8>
    2e0c:	290d      	cmp	r1, #13
    2e0e:	d100      	bne.n	2e12 <VectorA0+0x62>
    2e10:	e0af      	b.n	2f72 <VectorA0+0x1c2>
    2e12:	2901      	cmp	r1, #1
    2e14:	d02f      	beq.n	2e76 <VectorA0+0xc6>
    USB0->ISTAT = USBx_ISTAT_TOKDNE;
    2e16:	2280      	movs	r2, #128	; 0x80
    2e18:	2308      	movs	r3, #8
    2e1a:	54b3      	strb	r3, [r6, r2]
    istat = USB0->ISTAT;
    2e1c:	5cb4      	ldrb	r4, [r6, r2]
    2e1e:	b2e4      	uxtb	r4, r4
  while(istat & USBx_ISTAT_TOKDNE) {
    2e20:	4223      	tst	r3, r4
    2e22:	d074      	beq.n	2f0e <VectorA0+0x15e>
    uint8_t stat = USB0->STAT;
    2e24:	2390      	movs	r3, #144	; 0x90
    2e26:	5cf3      	ldrb	r3, [r6, r3]
    2e28:	b2db      	uxtb	r3, r3
    uint8_t ep = stat >> 4;
    2e2a:	091c      	lsrs	r4, r3, #4
    const USBEndpointConfig *epc = usbp->epc[ep];
    2e2c:	1ca2      	adds	r2, r4, #2
    2e2e:	4691      	mov	r9, r2
    2e30:	0092      	lsls	r2, r2, #2
    2e32:	18ba      	adds	r2, r7, r2
    2e34:	6855      	ldr	r5, [r2, #4]
    uint8_t tx_rx    = (stat & USBx_STAT_TX_MASK) >> USBx_STAT_TX_SHIFT;
    2e36:	4642      	mov	r2, r8
    uint8_t odd_even = (stat & USBx_STAT_ODD_MASK) >> USBx_STAT_ODD_SHIFT;
    2e38:	1098      	asrs	r0, r3, #2
    uint8_t tx_rx    = (stat & USBx_STAT_TX_MASK) >> USBx_STAT_TX_SHIFT;
    2e3a:	10db      	asrs	r3, r3, #3
    2e3c:	4013      	ands	r3, r2
    bd_t *bd = (bd_t*)&_bdt[BDT_INDEX(ep,tx_rx,odd_even)];
    2e3e:	00a2      	lsls	r2, r4, #2
    2e40:	4694      	mov	ip, r2
    uint8_t odd_even = (stat & USBx_STAT_ODD_MASK) >> USBx_STAT_ODD_SHIFT;
    2e42:	4642      	mov	r2, r8
    2e44:	4010      	ands	r0, r2
    bd_t *bd = (bd_t*)&_bdt[BDT_INDEX(ep,tx_rx,odd_even)];
    2e46:	4662      	mov	r2, ip
    2e48:	0059      	lsls	r1, r3, #1
    2e4a:	4302      	orrs	r2, r0
    2e4c:	430a      	orrs	r2, r1
    2e4e:	00d2      	lsls	r2, r2, #3
    2e50:	4692      	mov	sl, r2
    2e52:	465a      	mov	r2, fp
    2e54:	4651      	mov	r1, sl
    2e56:	5852      	ldr	r2, [r2, r1]
    2e58:	0691      	lsls	r1, r2, #26
    2e5a:	0f09      	lsrs	r1, r1, #28
    if(tx_rx == RX && epc->out_state != NULL)
    2e5c:	2b00      	cmp	r3, #0
    2e5e:	d0cd      	beq.n	2dfc <VectorA0+0x4c>
    switch(BDT_TOK_PID(bd->desc))
    2e60:	2909      	cmp	r1, #9
    2e62:	d100      	bne.n	2e66 <VectorA0+0xb6>
    2e64:	e0a0      	b.n	2fa8 <VectorA0+0x1f8>
    2e66:	290d      	cmp	r1, #13
    2e68:	d100      	bne.n	2e6c <VectorA0+0xbc>
    2e6a:	e082      	b.n	2f72 <VectorA0+0x1c2>
    2e6c:	2901      	cmp	r1, #1
    2e6e:	d1d2      	bne.n	2e16 <VectorA0+0x66>
        if(epc->out_state == NULL)
    2e70:	69ab      	ldr	r3, [r5, #24]
    2e72:	2b00      	cmp	r3, #0
    2e74:	d0cf      	beq.n	2e16 <VectorA0+0x66>
        uint16_t rxed = BDT_BC(bd->desc);
    2e76:	0192      	lsls	r2, r2, #6
    2e78:	0d93      	lsrs	r3, r2, #22
    2e7a:	469a      	mov	sl, r3
  __ASM volatile ("cpsid i" : : : "memory");
    2e7c:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2e7e:	f7fe f8df 	bl	1040 <_dbg_check_lock_from_isr>
        usb_packet_receive(usbp,ep,rxed);
    2e82:	4652      	mov	r2, sl
    2e84:	0021      	movs	r1, r4
    2e86:	0038      	movs	r0, r7
    2e88:	f7ff ff4a 	bl	2d20 <usb_packet_receive>
  _dbg_check_unlock_from_isr();
    2e8c:	f7fe f8f0 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    2e90:	b662      	cpsie	i
        if(rxed)
    2e92:	4653      	mov	r3, sl
    2e94:	2b00      	cmp	r3, #0
    2e96:	d0be      	beq.n	2e16 <VectorA0+0x66>
          epc->out_state->rxsize             -= rxed;
    2e98:	4651      	mov	r1, sl
          epc->out_state->rxbuf += rxed;
    2e9a:	69ab      	ldr	r3, [r5, #24]
    2e9c:	689a      	ldr	r2, [r3, #8]
    2e9e:	4452      	add	r2, sl
    2ea0:	609a      	str	r2, [r3, #8]
          epc->out_state->rxcnt              += rxed;
    2ea2:	685a      	ldr	r2, [r3, #4]
    2ea4:	4452      	add	r2, sl
    2ea6:	605a      	str	r2, [r3, #4]
          epc->out_state->rxsize             -= rxed;
    2ea8:	681a      	ldr	r2, [r3, #0]
    2eaa:	1a52      	subs	r2, r2, r1
    2eac:	601a      	str	r2, [r3, #0]
          epc->out_state->rxpkts             -= 1;
    2eae:	8a1a      	ldrh	r2, [r3, #16]
    2eb0:	3a01      	subs	r2, #1
    2eb2:	b292      	uxth	r2, r2
    2eb4:	821a      	strh	r2, [r3, #16]
          if ((rxed < epc->out_maxsize) || (epc->out_state->rxpkts == 0))
    2eb6:	8a6b      	ldrh	r3, [r5, #18]
    2eb8:	4553      	cmp	r3, sl
    2eba:	d800      	bhi.n	2ebe <VectorA0+0x10e>
    2ebc:	e0de      	b.n	307c <VectorA0+0x2cc>
            if(epc->out_cb != NULL)
    2ebe:	68eb      	ldr	r3, [r5, #12]
    2ec0:	2b00      	cmp	r3, #0
    2ec2:	d0a8      	beq.n	2e16 <VectorA0+0x66>
              _usb_isr_invoke_out_cb(usbp, ep);
    2ec4:	4642      	mov	r2, r8
    2ec6:	40a2      	lsls	r2, r4
    2ec8:	897b      	ldrh	r3, [r7, #10]
    2eca:	4393      	bics	r3, r2
    2ecc:	817b      	strh	r3, [r7, #10]
    2ece:	464b      	mov	r3, r9
    2ed0:	009b      	lsls	r3, r3, #2
    2ed2:	18fb      	adds	r3, r7, r3
    2ed4:	685b      	ldr	r3, [r3, #4]
    2ed6:	68db      	ldr	r3, [r3, #12]
    2ed8:	2b00      	cmp	r3, #0
    2eda:	d002      	beq.n	2ee2 <VectorA0+0x132>
    2edc:	0021      	movs	r1, r4
    2ede:	0038      	movs	r0, r7
    2ee0:	4798      	blx	r3
  __ASM volatile ("cpsid i" : : : "memory");
    2ee2:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2ee4:	f7fe f8ac 	bl	1040 <_dbg_check_lock_from_isr>
    2ee8:	464b      	mov	r3, r9
    2eea:	009b      	lsls	r3, r3, #2
    2eec:	18fb      	adds	r3, r7, r3
    2eee:	685b      	ldr	r3, [r3, #4]
    2ef0:	6998      	ldr	r0, [r3, #24]
  chThdResumeI(trp, msg);
    2ef2:	6841      	ldr	r1, [r0, #4]
    2ef4:	300c      	adds	r0, #12
    2ef6:	f7fe fcbb 	bl	1870 <chThdResumeI>
  _dbg_check_unlock_from_isr();
    2efa:	f7fe f8b9 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    2efe:	b662      	cpsie	i
    USB0->ISTAT = USBx_ISTAT_TOKDNE;
    2f00:	2280      	movs	r2, #128	; 0x80
    2f02:	2308      	movs	r3, #8
    2f04:	54b3      	strb	r3, [r6, r2]
    istat = USB0->ISTAT;
    2f06:	5cb4      	ldrb	r4, [r6, r2]
    2f08:	b2e4      	uxtb	r4, r4
  while(istat & USBx_ISTAT_TOKDNE) {
    2f0a:	4223      	tst	r3, r4
    2f0c:	d18a      	bne.n	2e24 <VectorA0+0x74>
  if(istat & USBx_ISTAT_USBRST) {
    2f0e:	2501      	movs	r5, #1
    2f10:	4225      	tst	r5, r4
    2f12:	d000      	beq.n	2f16 <VectorA0+0x166>
    2f14:	e0a6      	b.n	3064 <VectorA0+0x2b4>
  if(istat & USBx_ISTAT_STALL) {
    2f16:	b263      	sxtb	r3, r4
    2f18:	2b00      	cmp	r3, #0
    2f1a:	da00      	bge.n	2f1e <VectorA0+0x16e>
    2f1c:	e07c      	b.n	3018 <VectorA0+0x268>
  if(istat & USBx_ISTAT_ERROR) {
    2f1e:	2302      	movs	r3, #2
    2f20:	4223      	tst	r3, r4
    2f22:	d006      	beq.n	2f32 <VectorA0+0x182>
    uint8_t err = USB0->ERRSTAT;
    2f24:	2088      	movs	r0, #136	; 0x88
    2f26:	4a67      	ldr	r2, [pc, #412]	; (30c4 <VectorA0+0x314>)
    2f28:	5c11      	ldrb	r1, [r2, r0]
    2f2a:	b2c9      	uxtb	r1, r1
    USB0->ERRSTAT = err;
    2f2c:	5411      	strb	r1, [r2, r0]
    USB0->ISTAT = USBx_ISTAT_ERROR;
    2f2e:	2180      	movs	r1, #128	; 0x80
    2f30:	5453      	strb	r3, [r2, r1]
  if(istat & USBx_ISTAT_SLEEP) {
    2f32:	06e3      	lsls	r3, r4, #27
    2f34:	d508      	bpl.n	2f48 <VectorA0+0x198>
    if(usbp->state == USB_ACTIVE) {
    2f36:	4864      	ldr	r0, [pc, #400]	; (30c8 <VectorA0+0x318>)
    2f38:	7803      	ldrb	r3, [r0, #0]
    2f3a:	2b04      	cmp	r3, #4
    2f3c:	d100      	bne.n	2f40 <VectorA0+0x190>
    2f3e:	e0b7      	b.n	30b0 <VectorA0+0x300>
    USB0->ISTAT = USBx_ISTAT_SLEEP;
    2f40:	2380      	movs	r3, #128	; 0x80
    2f42:	2110      	movs	r1, #16
    2f44:	4a5f      	ldr	r2, [pc, #380]	; (30c4 <VectorA0+0x314>)
    2f46:	54d1      	strb	r1, [r2, r3]
  if(istat & USBx_ISTAT_RESUME) {
    2f48:	2520      	movs	r5, #32
    2f4a:	4225      	tst	r5, r4
    2f4c:	d000      	beq.n	2f50 <VectorA0+0x1a0>
    2f4e:	e06b      	b.n	3028 <VectorA0+0x278>
  OSAL_IRQ_EPILOGUE();
    2f50:	f7fe f8be 	bl	10d0 <_dbg_check_leave_isr>
    2f54:	9801      	ldr	r0, [sp, #4]
    2f56:	f7fe ff7b 	bl	1e50 <_port_irq_epilogue>
}
    2f5a:	b003      	add	sp, #12
    2f5c:	bc3c      	pop	{r2, r3, r4, r5}
    2f5e:	4690      	mov	r8, r2
    2f60:	4699      	mov	r9, r3
    2f62:	46a2      	mov	sl, r4
    2f64:	46ab      	mov	fp, r5
    2f66:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(BDT_TOK_PID(bd->desc))
    2f68:	2909      	cmp	r1, #9
    2f6a:	d01d      	beq.n	2fa8 <VectorA0+0x1f8>
    2f6c:	290d      	cmp	r1, #13
    2f6e:	d000      	beq.n	2f72 <VectorA0+0x1c2>
    2f70:	e751      	b.n	2e16 <VectorA0+0x66>
        _bdt[BDT_INDEX(ep, TX, EVEN)].desc = 0;
    2f72:	4662      	mov	r2, ip
    2f74:	2302      	movs	r3, #2
    2f76:	4659      	mov	r1, fp
    2f78:	4313      	orrs	r3, r2
    2f7a:	2200      	movs	r2, #0
    2f7c:	00db      	lsls	r3, r3, #3
    2f7e:	50ca      	str	r2, [r1, r3]
        _bdt[BDT_INDEX(ep, TX,  ODD)].desc = 0;
    2f80:	4661      	mov	r1, ip
    2f82:	2303      	movs	r3, #3
    2f84:	430b      	orrs	r3, r1
    2f86:	4659      	mov	r1, fp
    2f88:	00db      	lsls	r3, r3, #3
    2f8a:	50ca      	str	r2, [r1, r3]
        (usbp)->receiving &= ~1;
    2f8c:	4642      	mov	r2, r8
    2f8e:	897b      	ldrh	r3, [r7, #10]
        _usb_isr_invoke_setup_cb(usbp, ep);
    2f90:	0021      	movs	r1, r4
        (usbp)->receiving &= ~1;
    2f92:	4393      	bics	r3, r2
    2f94:	817b      	strh	r3, [r7, #10]
        usbp->epc[ep]->in_state->data_bank = DATA1;
    2f96:	696b      	ldr	r3, [r5, #20]
        _usb_isr_invoke_setup_cb(usbp, ep);
    2f98:	0038      	movs	r0, r7
        usbp->epc[ep]->in_state->data_bank = DATA1;
    2f9a:	745a      	strb	r2, [r3, #17]
        _usb_isr_invoke_setup_cb(usbp, ep);
    2f9c:	686b      	ldr	r3, [r5, #4]
    2f9e:	4798      	blx	r3
        USB0->CTL = USBx_CTL_USBENSOFEN;
    2fa0:	2394      	movs	r3, #148	; 0x94
    2fa2:	4642      	mov	r2, r8
    2fa4:	54f2      	strb	r2, [r6, r3]
      } break;
    2fa6:	e736      	b.n	2e16 <VectorA0+0x66>
        if(epc->in_state == NULL)
    2fa8:	696b      	ldr	r3, [r5, #20]
    2faa:	2b00      	cmp	r3, #0
    2fac:	d100      	bne.n	2fb0 <VectorA0+0x200>
    2fae:	e732      	b.n	2e16 <VectorA0+0x66>
        if(ep == 0 && (((uint16_t)usbp->setup[0]<<8)|usbp->setup[1]) == 0x0500)
    2fb0:	2c00      	cmp	r4, #0
    2fb2:	d106      	bne.n	2fc2 <VectorA0+0x212>
    2fb4:	22d4      	movs	r2, #212	; 0xd4
    2fb6:	5aba      	ldrh	r2, [r7, r2]
    2fb8:	2a05      	cmp	r2, #5
    2fba:	d063      	beq.n	3084 <VectorA0+0x2d4>
    2fbc:	465a      	mov	r2, fp
    2fbe:	4651      	mov	r1, sl
    2fc0:	5852      	ldr	r2, [r2, r1]
        epc->in_state->txcnt += txed;
    2fc2:	6859      	ldr	r1, [r3, #4]
        uint16_t txed = BDT_BC(bd->desc);
    2fc4:	0192      	lsls	r2, r2, #6
        epc->in_state->txcnt += txed;
    2fc6:	0d92      	lsrs	r2, r2, #22
        if(epc->in_state->txcnt < epc->in_state->txsize)
    2fc8:	6818      	ldr	r0, [r3, #0]
        epc->in_state->txcnt += txed;
    2fca:	1851      	adds	r1, r2, r1
    2fcc:	6059      	str	r1, [r3, #4]
        if(epc->in_state->txcnt < epc->in_state->txsize)
    2fce:	4281      	cmp	r1, r0
    2fd0:	d335      	bcc.n	303e <VectorA0+0x28e>
          if(epc->in_cb != NULL)
    2fd2:	68ab      	ldr	r3, [r5, #8]
    2fd4:	2b00      	cmp	r3, #0
    2fd6:	d100      	bne.n	2fda <VectorA0+0x22a>
    2fd8:	e71d      	b.n	2e16 <VectorA0+0x66>
            _usb_isr_invoke_in_cb(usbp,ep);
    2fda:	4642      	mov	r2, r8
    2fdc:	40a2      	lsls	r2, r4
    2fde:	893b      	ldrh	r3, [r7, #8]
    2fe0:	4393      	bics	r3, r2
    2fe2:	813b      	strh	r3, [r7, #8]
    2fe4:	464b      	mov	r3, r9
    2fe6:	009b      	lsls	r3, r3, #2
    2fe8:	18fb      	adds	r3, r7, r3
    2fea:	685b      	ldr	r3, [r3, #4]
    2fec:	689b      	ldr	r3, [r3, #8]
    2fee:	2b00      	cmp	r3, #0
    2ff0:	d002      	beq.n	2ff8 <VectorA0+0x248>
    2ff2:	0021      	movs	r1, r4
    2ff4:	0038      	movs	r0, r7
    2ff6:	4798      	blx	r3
  __ASM volatile ("cpsid i" : : : "memory");
    2ff8:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    2ffa:	f7fe f821 	bl	1040 <_dbg_check_lock_from_isr>
    2ffe:	464b      	mov	r3, r9
    3000:	009b      	lsls	r3, r3, #2
    3002:	18fb      	adds	r3, r7, r3
    3004:	685b      	ldr	r3, [r3, #4]
    3006:	2100      	movs	r1, #0
    3008:	6958      	ldr	r0, [r3, #20]
    300a:	300c      	adds	r0, #12
    300c:	f7fe fc30 	bl	1870 <chThdResumeI>
  _dbg_check_unlock_from_isr();
    3010:	f7fe f82e 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    3014:	b662      	cpsie	i
    3016:	e6fe      	b.n	2e16 <VectorA0+0x66>
    USB0->ISTAT = USBx_ISTAT_STALL;
    3018:	2380      	movs	r3, #128	; 0x80
    301a:	4a2a      	ldr	r2, [pc, #168]	; (30c4 <VectorA0+0x314>)
    301c:	54d3      	strb	r3, [r2, r3]
  if(istat & USBx_ISTAT_ERROR) {
    301e:	2302      	movs	r3, #2
    3020:	4223      	tst	r3, r4
    3022:	d100      	bne.n	3026 <VectorA0+0x276>
    3024:	e785      	b.n	2f32 <VectorA0+0x182>
    3026:	e77d      	b.n	2f24 <VectorA0+0x174>
    USB0->INTEN &= ~USBx_INTEN_RESUMEEN;
    3028:	2284      	movs	r2, #132	; 0x84
    302a:	4c26      	ldr	r4, [pc, #152]	; (30c4 <VectorA0+0x314>)
    _usb_wakeup(usbp);
    302c:	4826      	ldr	r0, [pc, #152]	; (30c8 <VectorA0+0x318>)
    USB0->INTEN &= ~USBx_INTEN_RESUMEEN;
    302e:	5ca3      	ldrb	r3, [r4, r2]
    3030:	43ab      	bics	r3, r5
    3032:	54a3      	strb	r3, [r4, r2]
    _usb_wakeup(usbp);
    3034:	f7ff fa3c 	bl	24b0 <_usb_wakeup>
    USB0->ISTAT = USBx_ISTAT_RESUME;
    3038:	2380      	movs	r3, #128	; 0x80
    303a:	54e5      	strb	r5, [r4, r3]
    303c:	e788      	b.n	2f50 <VectorA0+0x1a0>
          epc->in_state->txbuf += txed;
    303e:	6899      	ldr	r1, [r3, #8]
    3040:	468c      	mov	ip, r1
    3042:	4462      	add	r2, ip
    3044:	609a      	str	r2, [r3, #8]
  __ASM volatile ("cpsid i" : : : "memory");
    3046:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    3048:	f7fd fffa 	bl	1040 <_dbg_check_lock_from_isr>
          usb_packet_transmit(usbp,ep,epc->in_state->txsize - epc->in_state->txcnt);
    304c:	696b      	ldr	r3, [r5, #20]
    304e:	0021      	movs	r1, r4
    3050:	681a      	ldr	r2, [r3, #0]
    3052:	685b      	ldr	r3, [r3, #4]
    3054:	0038      	movs	r0, r7
    3056:	1ad2      	subs	r2, r2, r3
    3058:	f7ff fe32 	bl	2cc0 <usb_packet_transmit>
  _dbg_check_unlock_from_isr();
    305c:	f7fe f808 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    3060:	b662      	cpsie	i
    3062:	e6d8      	b.n	2e16 <VectorA0+0x66>
    _usb_reset(usbp);
    3064:	4818      	ldr	r0, [pc, #96]	; (30c8 <VectorA0+0x318>)
    3066:	f7ff f9bb 	bl	23e0 <_usb_reset>
    USB0->ISTAT = USBx_ISTAT_USBRST;
    306a:	2380      	movs	r3, #128	; 0x80
    306c:	4a15      	ldr	r2, [pc, #84]	; (30c4 <VectorA0+0x314>)
    306e:	54d5      	strb	r5, [r2, r3]
    OSAL_IRQ_EPILOGUE();
    3070:	f7fe f82e 	bl	10d0 <_dbg_check_leave_isr>
    3074:	9801      	ldr	r0, [sp, #4]
    3076:	f7fe feeb 	bl	1e50 <_port_irq_epilogue>
    return;
    307a:	e76e      	b.n	2f5a <VectorA0+0x1aa>
          if ((rxed < epc->out_maxsize) || (epc->out_state->rxpkts == 0))
    307c:	2a00      	cmp	r2, #0
    307e:	d000      	beq.n	3082 <VectorA0+0x2d2>
    3080:	e6c9      	b.n	2e16 <VectorA0+0x66>
    3082:	e71c      	b.n	2ebe <VectorA0+0x10e>
          usbp->address = usbp->setup[2];
    3084:	22d6      	movs	r2, #214	; 0xd6
    3086:	5cb9      	ldrb	r1, [r7, r2]
    3088:	3208      	adds	r2, #8
    308a:	54b9      	strb	r1, [r7, r2]
  USB0->ADDR = usbp->address&0x7F;
    308c:	3a5f      	subs	r2, #95	; 0x5f
    308e:	400a      	ands	r2, r1
    3090:	2198      	movs	r1, #152	; 0x98
    3092:	5472      	strb	r2, [r6, r1]
          _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
    3094:	687a      	ldr	r2, [r7, #4]
    3096:	6812      	ldr	r2, [r2, #0]
    3098:	2a00      	cmp	r2, #0
    309a:	d006      	beq.n	30aa <VectorA0+0x2fa>
    309c:	3997      	subs	r1, #151	; 0x97
    309e:	0038      	movs	r0, r7
    30a0:	4790      	blx	r2
    30a2:	465b      	mov	r3, fp
    30a4:	4652      	mov	r2, sl
    30a6:	589b      	ldr	r3, [r3, r2]
    30a8:	696b      	ldr	r3, [r5, #20]
          usbp->state = USB_SELECTED;
    30aa:	2203      	movs	r2, #3
    30ac:	703a      	strb	r2, [r7, #0]
    30ae:	e785      	b.n	2fbc <VectorA0+0x20c>
      _usb_suspend(usbp);
    30b0:	f7ff f9ce 	bl	2450 <_usb_suspend>
      USB0->INTEN |= USBx_INTEN_RESUMEEN;
    30b4:	2284      	movs	r2, #132	; 0x84
    30b6:	2020      	movs	r0, #32
    30b8:	4902      	ldr	r1, [pc, #8]	; (30c4 <VectorA0+0x314>)
    30ba:	5c8b      	ldrb	r3, [r1, r2]
    30bc:	4303      	orrs	r3, r0
    30be:	548b      	strb	r3, [r1, r2]
    30c0:	e73e      	b.n	2f40 <VectorA0+0x190>
    30c2:	46c0      	nop			; (mov r8, r8)
    30c4:	40072000 	.word	0x40072000
    30c8:	20000180 	.word	0x20000180
    30cc:	20000400 	.word	0x20000400

000030d0 <usb_lld_init>:
void usb_lld_init(void) {
    30d0:	b510      	push	{r4, lr}
  usbObjectInit(&USBD1);
    30d2:	4805      	ldr	r0, [pc, #20]	; (30e8 <usb_lld_init+0x18>)
    30d4:	f7ff f84c 	bl	2170 <usbObjectInit>
  SIM->SOPT2 |= SIM_SOPT2_USBSRC;
    30d8:	2380      	movs	r3, #128	; 0x80
    30da:	4904      	ldr	r1, [pc, #16]	; (30ec <usb_lld_init+0x1c>)
    30dc:	4a04      	ldr	r2, [pc, #16]	; (30f0 <usb_lld_init+0x20>)
    30de:	02db      	lsls	r3, r3, #11
    30e0:	5888      	ldr	r0, [r1, r2]
    30e2:	4303      	orrs	r3, r0
    30e4:	508b      	str	r3, [r1, r2]
}
    30e6:	bd10      	pop	{r4, pc}
    30e8:	20000180 	.word	0x20000180
    30ec:	40047000 	.word	0x40047000
    30f0:	00001004 	.word	0x00001004
	...

00003100 <usb_lld_start>:
  if (usbp->state == USB_STOP) {
    3100:	7803      	ldrb	r3, [r0, #0]
void usb_lld_start(USBDriver *usbp) {
    3102:	b510      	push	{r4, lr}
  if (usbp->state == USB_STOP) {
    3104:	2b01      	cmp	r3, #1
    3106:	d000      	beq.n	310a <usb_lld_start+0xa>
}
    3108:	bd10      	pop	{r4, pc}
    if (&USBD1 == usbp) {
    310a:	4b22      	ldr	r3, [pc, #136]	; (3194 <usb_lld_start+0x94>)
    310c:	4298      	cmp	r0, r3
    310e:	d1fb      	bne.n	3108 <usb_lld_start+0x8>
    3110:	2200      	movs	r2, #0
        _bdt[i].desc=0;
    3112:	2000      	movs	r0, #0
    3114:	4920      	ldr	r1, [pc, #128]	; (3198 <usb_lld_start+0x98>)
    3116:	00d3      	lsls	r3, r2, #3
    3118:	50c8      	str	r0, [r1, r3]
    311a:	3201      	adds	r2, #1
        _bdt[i].addr=0;
    311c:	18cb      	adds	r3, r1, r3
    311e:	6058      	str	r0, [r3, #4]
      for(i=0;i<KINETIS_USB_ENDPOINTS;i++) {
    3120:	2a10      	cmp	r2, #16
    3122:	d1f8      	bne.n	3116 <usb_lld_start+0x16>
      SIM->SCGC4 |= SIM_SCGC4_USBOTG;
    3124:	2380      	movs	r3, #128	; 0x80
    3126:	481d      	ldr	r0, [pc, #116]	; (319c <usb_lld_start+0x9c>)
    3128:	4a1d      	ldr	r2, [pc, #116]	; (31a0 <usb_lld_start+0xa0>)
    312a:	02db      	lsls	r3, r3, #11
    312c:	5884      	ldr	r4, [r0, r2]
    312e:	4323      	orrs	r3, r4
    3130:	5083      	str	r3, [r0, r2]
      USB0->USBTRC0 |= USBx_USBTRC0_USBRESET;
    3132:	2086      	movs	r0, #134	; 0x86
    3134:	2480      	movs	r4, #128	; 0x80
    3136:	4a1b      	ldr	r2, [pc, #108]	; (31a4 <usb_lld_start+0xa4>)
    3138:	0040      	lsls	r0, r0, #1
    313a:	5c13      	ldrb	r3, [r2, r0]
    313c:	4323      	orrs	r3, r4
    313e:	5413      	strb	r3, [r2, r0]
      while ((USB0->USBTRC0 & USBx_USBTRC0_USBRESET));
    3140:	5c13      	ldrb	r3, [r2, r0]
    3142:	b25b      	sxtb	r3, r3
    3144:	2b00      	cmp	r3, #0
    3146:	dbfb      	blt.n	3140 <usb_lld_start+0x40>
      USB0->BDTPAGE1 = ((uint32_t)_bdt) >> 8;
    3148:	249c      	movs	r4, #156	; 0x9c
    314a:	0a0b      	lsrs	r3, r1, #8
    314c:	b2db      	uxtb	r3, r3
    314e:	5513      	strb	r3, [r2, r4]
      USB0->BDTPAGE2 = ((uint32_t)_bdt) >> 16;
    3150:	0c0b      	lsrs	r3, r1, #16
    3152:	b2db      	uxtb	r3, r3
    3154:	3414      	adds	r4, #20
    3156:	5513      	strb	r3, [r2, r4]
      USB0->BDTPAGE3 = ((uint32_t)_bdt) >> 24;
    3158:	23b4      	movs	r3, #180	; 0xb4
    315a:	0e09      	lsrs	r1, r1, #24
    315c:	54d1      	strb	r1, [r2, r3]
      USB0->ISTAT = 0xFF;
    315e:	2180      	movs	r1, #128	; 0x80
    3160:	334b      	adds	r3, #75	; 0x4b
    3162:	5453      	strb	r3, [r2, r1]
      USB0->ERRSTAT = 0xFF;
    3164:	3108      	adds	r1, #8
    3166:	5453      	strb	r3, [r2, r1]
      USB0->USBTRC0 |= 0x40; //a hint was given that this is an undocumented interrupt bit
    3168:	2140      	movs	r1, #64	; 0x40
      USB0->OTGISTAT = 0xFF;
    316a:	7413      	strb	r3, [r2, #16]
      USB0->USBTRC0 |= 0x40; //a hint was given that this is an undocumented interrupt bit
    316c:	5c13      	ldrb	r3, [r2, r0]
    316e:	430b      	orrs	r3, r1
    3170:	5413      	strb	r3, [r2, r0]
      USB0->CTL = USBx_CTL_ODDRST | USBx_CTL_USBENSOFEN;
    3172:	2103      	movs	r1, #3
    3174:	2394      	movs	r3, #148	; 0x94
    3176:	54d1      	strb	r1, [r2, r3]
      USB0->USBCTRL = 0;
    3178:	2100      	movs	r1, #0
      USB0->INTEN |= USBx_INTEN_USBRSTEN;
    317a:	2001      	movs	r0, #1
      USB0->USBCTRL = 0;
    317c:	336c      	adds	r3, #108	; 0x6c
    317e:	54d1      	strb	r1, [r2, r3]
      USB0->INTEN |= USBx_INTEN_USBRSTEN;
    3180:	3184      	adds	r1, #132	; 0x84
    3182:	5c53      	ldrb	r3, [r2, r1]
    3184:	4303      	orrs	r3, r0
    3186:	5453      	strb	r3, [r2, r1]
      nvicEnableVector(USB_OTG_IRQn, KINETIS_USB_USB0_IRQ_PRIORITY);
    3188:	2018      	movs	r0, #24
    318a:	3982      	subs	r1, #130	; 0x82
    318c:	f7ff fbf0 	bl	2970 <nvicEnableVector>
}
    3190:	e7ba      	b.n	3108 <usb_lld_start+0x8>
    3192:	46c0      	nop			; (mov r8, r8)
    3194:	20000180 	.word	0x20000180
    3198:	20000400 	.word	0x20000400
    319c:	40047000 	.word	0x40047000
    31a0:	00001034 	.word	0x00001034
    31a4:	40072000 	.word	0x40072000
	...

000031b0 <usb_lld_set_address>:
  USB0->ADDR = usbp->address&0x7F;
    31b0:	23de      	movs	r3, #222	; 0xde
    31b2:	5cc2      	ldrb	r2, [r0, r3]
    31b4:	3b5f      	subs	r3, #95	; 0x5f
    31b6:	4013      	ands	r3, r2
    31b8:	2298      	movs	r2, #152	; 0x98
    31ba:	4901      	ldr	r1, [pc, #4]	; (31c0 <usb_lld_set_address+0x10>)
    31bc:	548b      	strb	r3, [r1, r2]
}
    31be:	4770      	bx	lr
    31c0:	40072000 	.word	0x40072000
	...

000031d0 <usb_lld_init_endpoint>:
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
    31d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    31d2:	46ce      	mov	lr, r9
    31d4:	4647      	mov	r7, r8
    31d6:	b580      	push	{r7, lr}
  if(ep > KINETIS_USB_ENDPOINTS)
    31d8:	2910      	cmp	r1, #16
    31da:	d878      	bhi.n	32ce <usb_lld_init_endpoint+0xfe>
  const USBEndpointConfig *epc = usbp->epc[ep];
    31dc:	1c8b      	adds	r3, r1, #2
    31de:	009b      	lsls	r3, r3, #2
    31e0:	18c0      	adds	r0, r0, r3
    31e2:	6843      	ldr	r3, [r0, #4]
    31e4:	4699      	mov	r9, r3
  if(epc->out_state != NULL)
    31e6:	699b      	ldr	r3, [r3, #24]
    31e8:	2b00      	cmp	r3, #0
    31ea:	d02f      	beq.n	324c <usb_lld_init_endpoint+0x7c>
    epc->out_state->odd_even = EVEN;
    31ec:	2200      	movs	r2, #0
    31ee:	749a      	strb	r2, [r3, #18]
    epc->out_state->data_bank = DATA0;
    31f0:	74da      	strb	r2, [r3, #19]
    _bdt[BDT_INDEX(ep, RX, EVEN)].desc = BDT_DESC(epc->out_maxsize, DATA0);
    31f2:	464b      	mov	r3, r9
    31f4:	8a5e      	ldrh	r6, [r3, #18]
    31f6:	2388      	movs	r3, #136	; 0x88
    31f8:	0436      	lsls	r6, r6, #16
    31fa:	4d38      	ldr	r5, [pc, #224]	; (32dc <usb_lld_init_endpoint+0x10c>)
    31fc:	4333      	orrs	r3, r6
    31fe:	014f      	lsls	r7, r1, #5
  if(_usbbn < (KINETIS_USB_ENDPOINTS)*4)
    3200:	4837      	ldr	r0, [pc, #220]	; (32e0 <usb_lld_init_endpoint+0x110>)
    _bdt[BDT_INDEX(ep, RX, EVEN)].desc = BDT_DESC(epc->out_maxsize, DATA0);
    3202:	517b      	str	r3, [r7, r5]
  if(_usbbn < (KINETIS_USB_ENDPOINTS)*4)
    3204:	7803      	ldrb	r3, [r0, #0]
    _bdt[BDT_INDEX(ep, RX, EVEN)].desc = BDT_DESC(epc->out_maxsize, DATA0);
    3206:	008a      	lsls	r2, r1, #2
  if(_usbbn < (KINETIS_USB_ENDPOINTS)*4)
    3208:	2b3f      	cmp	r3, #63	; 0x3f
    320a:	d81e      	bhi.n	324a <usb_lld_init_endpoint+0x7a>
    return _usbb[_usbbn++];
    320c:	7803      	ldrb	r3, [r0, #0]
    _bdt[BDT_INDEX(ep, RX, EVEN)].addr = usb_alloc(epc->out_maxsize);
    320e:	19ef      	adds	r7, r5, r7
    return _usbb[_usbbn++];
    3210:	b2db      	uxtb	r3, r3
    3212:	1c5c      	adds	r4, r3, #1
    3214:	b2e4      	uxtb	r4, r4
    3216:	7004      	strb	r4, [r0, #0]
    3218:	4c32      	ldr	r4, [pc, #200]	; (32e4 <usb_lld_init_endpoint+0x114>)
    321a:	019b      	lsls	r3, r3, #6
    321c:	46a4      	mov	ip, r4
    321e:	4463      	add	r3, ip
    _bdt[BDT_INDEX(ep, RX, EVEN)].addr = usb_alloc(epc->out_maxsize);
    3220:	607b      	str	r3, [r7, #4]
    _bdt[BDT_INDEX(ep, RX,  ODD)].desc = BDT_DESC(epc->out_maxsize, DATA1);
    3222:	2301      	movs	r3, #1
    3224:	431a      	orrs	r2, r3
    3226:	33c7      	adds	r3, #199	; 0xc7
    3228:	431e      	orrs	r6, r3
    322a:	00d2      	lsls	r2, r2, #3
    322c:	5156      	str	r6, [r2, r5]
  if(_usbbn < (KINETIS_USB_ENDPOINTS)*4)
    322e:	7803      	ldrb	r3, [r0, #0]
    3230:	2b3f      	cmp	r3, #63	; 0x3f
    3232:	d851      	bhi.n	32d8 <usb_lld_init_endpoint+0x108>
    return _usbb[_usbbn++];
    3234:	7803      	ldrb	r3, [r0, #0]
    _bdt[BDT_INDEX(ep, RX,  ODD)].addr = usb_alloc(epc->out_maxsize);
    3236:	18aa      	adds	r2, r5, r2
    return _usbb[_usbbn++];
    3238:	b2db      	uxtb	r3, r3
    323a:	1c5e      	adds	r6, r3, #1
    323c:	019b      	lsls	r3, r3, #6
    323e:	4463      	add	r3, ip
    3240:	b2f6      	uxtb	r6, r6
    3242:	7006      	strb	r6, [r0, #0]
    _bdt[BDT_INDEX(ep, RX,  ODD)].addr = usb_alloc(epc->out_maxsize);
    3244:	6053      	str	r3, [r2, #4]
    mask |= USBx_ENDPTn_EPRXEN;
    3246:	2308      	movs	r3, #8
    3248:	e001      	b.n	324e <usb_lld_init_endpoint+0x7e>
    324a:	e7fe      	b.n	324a <usb_lld_init_endpoint+0x7a>
  uint8_t mask=0;
    324c:	2300      	movs	r3, #0
  if(epc->in_state != NULL)
    324e:	464a      	mov	r2, r9
    3250:	6952      	ldr	r2, [r2, #20]
    3252:	2a00      	cmp	r2, #0
    3254:	d02b      	beq.n	32ae <usb_lld_init_endpoint+0xde>
    epc->in_state->odd_even = EVEN;
    3256:	2700      	movs	r7, #0
    _bdt[BDT_INDEX(ep, TX, EVEN)].desc = 0;
    3258:	2002      	movs	r0, #2
    epc->in_state->odd_even = EVEN;
    325a:	7417      	strb	r7, [r2, #16]
    epc->in_state->data_bank = DATA0;
    325c:	7457      	strb	r7, [r2, #17]
    _bdt[BDT_INDEX(ep, TX, EVEN)].desc = 0;
    325e:	008a      	lsls	r2, r1, #2
    3260:	4310      	orrs	r0, r2
    3262:	4d1e      	ldr	r5, [pc, #120]	; (32dc <usb_lld_init_endpoint+0x10c>)
    3264:	00c0      	lsls	r0, r0, #3
  if(_usbbn < (KINETIS_USB_ENDPOINTS)*4)
    3266:	4e1e      	ldr	r6, [pc, #120]	; (32e0 <usb_lld_init_endpoint+0x110>)
    _bdt[BDT_INDEX(ep, TX, EVEN)].desc = 0;
    3268:	5147      	str	r7, [r0, r5]
    326a:	4690      	mov	r8, r2
  if(_usbbn < (KINETIS_USB_ENDPOINTS)*4)
    326c:	7832      	ldrb	r2, [r6, #0]
    326e:	2a3f      	cmp	r2, #63	; 0x3f
    3270:	d831      	bhi.n	32d6 <usb_lld_init_endpoint+0x106>
    return _usbb[_usbbn++];
    3272:	7832      	ldrb	r2, [r6, #0]
    _bdt[BDT_INDEX(ep, TX, EVEN)].addr = usb_alloc(epc->in_maxsize);
    3274:	1828      	adds	r0, r5, r0
    return _usbb[_usbbn++];
    3276:	b2d2      	uxtb	r2, r2
    3278:	1c54      	adds	r4, r2, #1
    327a:	b2e4      	uxtb	r4, r4
    327c:	7034      	strb	r4, [r6, #0]
    327e:	4c19      	ldr	r4, [pc, #100]	; (32e4 <usb_lld_init_endpoint+0x114>)
    3280:	0192      	lsls	r2, r2, #6
    3282:	46a4      	mov	ip, r4
    3284:	4462      	add	r2, ip
    _bdt[BDT_INDEX(ep, TX, EVEN)].addr = usb_alloc(epc->in_maxsize);
    3286:	6042      	str	r2, [r0, #4]
    _bdt[BDT_INDEX(ep, TX,  ODD)].desc = 0;
    3288:	4642      	mov	r2, r8
    328a:	2003      	movs	r0, #3
    328c:	4310      	orrs	r0, r2
    328e:	00c0      	lsls	r0, r0, #3
    3290:	5147      	str	r7, [r0, r5]
  if(_usbbn < (KINETIS_USB_ENDPOINTS)*4)
    3292:	7832      	ldrb	r2, [r6, #0]
    3294:	2a3f      	cmp	r2, #63	; 0x3f
    3296:	d820      	bhi.n	32da <usb_lld_init_endpoint+0x10a>
    return _usbb[_usbbn++];
    3298:	7832      	ldrb	r2, [r6, #0]
    _bdt[BDT_INDEX(ep, TX,  ODD)].addr = usb_alloc(epc->in_maxsize);
    329a:	182d      	adds	r5, r5, r0
    return _usbb[_usbbn++];
    329c:	b2d2      	uxtb	r2, r2
    329e:	1c57      	adds	r7, r2, #1
    32a0:	0192      	lsls	r2, r2, #6
    32a2:	4462      	add	r2, ip
    32a4:	b2ff      	uxtb	r7, r7
    32a6:	7037      	strb	r7, [r6, #0]
    _bdt[BDT_INDEX(ep, TX,  ODD)].addr = usb_alloc(epc->in_maxsize);
    32a8:	606a      	str	r2, [r5, #4]
    mask |= USBx_ENDPTn_EPTXEN;
    32aa:	2204      	movs	r2, #4
    32ac:	4313      	orrs	r3, r2
  if((epc->ep_mode & USB_EP_MODE_TYPE) != USB_EP_MODE_TYPE_ISOC)
    32ae:	464a      	mov	r2, r9
    32b0:	2003      	movs	r0, #3
    32b2:	6812      	ldr	r2, [r2, #0]
    32b4:	4002      	ands	r2, r0
    32b6:	2a01      	cmp	r2, #1
    32b8:	d003      	beq.n	32c2 <usb_lld_init_endpoint+0xf2>
    mask |= USBx_ENDPTn_EPHSHK;
    32ba:	2001      	movs	r0, #1
    32bc:	4303      	orrs	r3, r0
  if((epc->ep_mode & USB_EP_MODE_TYPE) != USB_EP_MODE_TYPE_CTRL)
    32be:	2a00      	cmp	r2, #0
    32c0:	d001      	beq.n	32c6 <usb_lld_init_endpoint+0xf6>
    mask |= USBx_ENDPTn_EPCTLDIS;
    32c2:	2210      	movs	r2, #16
    32c4:	4313      	orrs	r3, r2
  USB0->ENDPT[ep].V = mask;
    32c6:	3130      	adds	r1, #48	; 0x30
    32c8:	4a07      	ldr	r2, [pc, #28]	; (32e8 <usb_lld_init_endpoint+0x118>)
    32ca:	0089      	lsls	r1, r1, #2
    32cc:	548b      	strb	r3, [r1, r2]
}
    32ce:	bc0c      	pop	{r2, r3}
    32d0:	4690      	mov	r8, r2
    32d2:	4699      	mov	r9, r3
    32d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    32d6:	e7fe      	b.n	32d6 <usb_lld_init_endpoint+0x106>
    32d8:	e7fe      	b.n	32d8 <usb_lld_init_endpoint+0x108>
    32da:	e7fe      	b.n	32da <usb_lld_init_endpoint+0x10a>
    32dc:	20000400 	.word	0x20000400
    32e0:	20000ac0 	.word	0x20000ac0
    32e4:	20000600 	.word	0x20000600
    32e8:	40072000 	.word	0x40072000
    32ec:	00000000 	.word	0x00000000

000032f0 <usb_lld_reset>:
void usb_lld_reset(USBDriver *usbp) {
    32f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  _usbbn = 0;
    32f2:	2500      	movs	r5, #0
    32f4:	4b0e      	ldr	r3, [pc, #56]	; (3330 <usb_lld_reset+0x40>)
  USB0->CTL = USBx_CTL_ODDRST;
    32f6:	2794      	movs	r7, #148	; 0x94
  _usbbn = 0;
    32f8:	701d      	strb	r5, [r3, #0]
  USB0->CTL = USBx_CTL_ODDRST;
    32fa:	2302      	movs	r3, #2
    32fc:	4c0d      	ldr	r4, [pc, #52]	; (3334 <usb_lld_reset+0x44>)
  usb_lld_init_endpoint(usbp, 0);
    32fe:	2100      	movs	r1, #0
  USB0->CTL = USBx_CTL_ODDRST;
    3300:	55e3      	strb	r3, [r4, r7]
  usbp->epc[0] = &ep0config;
    3302:	4b0d      	ldr	r3, [pc, #52]	; (3338 <usb_lld_reset+0x48>)
void usb_lld_reset(USBDriver *usbp) {
    3304:	0006      	movs	r6, r0
  usbp->epc[0] = &ep0config;
    3306:	60c3      	str	r3, [r0, #12]
  usb_lld_init_endpoint(usbp, 0);
    3308:	f7ff ff62 	bl	31d0 <usb_lld_init_endpoint>
  USB0->ERRSTAT = 0xFF;
    330c:	23ff      	movs	r3, #255	; 0xff
    330e:	2288      	movs	r2, #136	; 0x88
    3310:	54a3      	strb	r3, [r4, r2]
  USB0->ISTAT = 0xFF;
    3312:	3a08      	subs	r2, #8
    3314:	54a3      	strb	r3, [r4, r2]
  usbp->address = 0;
    3316:	325e      	adds	r2, #94	; 0x5e
    3318:	54b5      	strb	r5, [r6, r2]
  USB0->ADDR = 0;
    331a:	3a46      	subs	r2, #70	; 0x46
    331c:	54a5      	strb	r5, [r4, r2]
  USB0->ERREN = 0xFF;
    331e:	3a0c      	subs	r2, #12
    3320:	54a3      	strb	r3, [r4, r2]
  USB0->INTEN = USBx_INTEN_TOKDNEEN |
    3322:	3b7b      	subs	r3, #123	; 0x7b
    3324:	3213      	adds	r2, #19
    3326:	54e2      	strb	r2, [r4, r3]
  USB0->CTL = USBx_CTL_USBENSOFEN;
    3328:	3b83      	subs	r3, #131	; 0x83
    332a:	55e3      	strb	r3, [r4, r7]
}
    332c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    332e:	46c0      	nop			; (mov r8, r8)
    3330:	20000ac0 	.word	0x20000ac0
    3334:	40072000 	.word	0x40072000
    3338:	00007ecc 	.word	0x00007ecc
    333c:	00000000 	.word	0x00000000

00003340 <usb_lld_disable_endpoints>:
void usb_lld_disable_endpoints(USBDriver *usbp) {
    3340:	2301      	movs	r3, #1
    USB0->ENDPT[i].V = 0;
    3342:	2100      	movs	r1, #0
    3344:	4804      	ldr	r0, [pc, #16]	; (3358 <usb_lld_disable_endpoints+0x18>)
    3346:	001a      	movs	r2, r3
    3348:	3230      	adds	r2, #48	; 0x30
    334a:	0092      	lsls	r2, r2, #2
    334c:	3301      	adds	r3, #1
    334e:	5411      	strb	r1, [r2, r0]
  for(i=1;i<KINETIS_USB_ENDPOINTS;i++)
    3350:	2b10      	cmp	r3, #16
    3352:	d1f8      	bne.n	3346 <usb_lld_disable_endpoints+0x6>
}
    3354:	4770      	bx	lr
    3356:	46c0      	nop			; (mov r8, r8)
    3358:	40072000 	.word	0x40072000
    335c:	00000000 	.word	0x00000000

00003360 <usb_lld_get_status_out>:
    return EP_STATUS_DISABLED;
    3360:	2000      	movs	r0, #0
  if(ep > USB_MAX_ENDPOINTS)
    3362:	290f      	cmp	r1, #15
    3364:	d80d      	bhi.n	3382 <usb_lld_get_status_out+0x22>
    3366:	4b07      	ldr	r3, [pc, #28]	; (3384 <usb_lld_get_status_out+0x24>)
    3368:	0089      	lsls	r1, r1, #2
    336a:	469c      	mov	ip, r3
  if(!(USB0->ENDPT[ep].V & (USBx_ENDPTn_EPRXEN)))
    336c:	23c0      	movs	r3, #192	; 0xc0
    336e:	4461      	add	r1, ip
    3370:	5cca      	ldrb	r2, [r1, r3]
    3372:	0712      	lsls	r2, r2, #28
    3374:	d505      	bpl.n	3382 <usb_lld_get_status_out+0x22>
  else if(USB0->ENDPT[ep].V & USBx_ENDPTn_EPSTALL)
    3376:	5ccb      	ldrb	r3, [r1, r3]
    3378:	3002      	adds	r0, #2
    337a:	4018      	ands	r0, r3
  return EP_STATUS_ACTIVE;
    337c:	4243      	negs	r3, r0
    337e:	4158      	adcs	r0, r3
    3380:	3001      	adds	r0, #1
}
    3382:	4770      	bx	lr
    3384:	40072000 	.word	0x40072000
	...

00003390 <usb_lld_get_status_in>:
    return EP_STATUS_DISABLED;
    3390:	2000      	movs	r0, #0
  if(ep > USB_MAX_ENDPOINTS)
    3392:	290f      	cmp	r1, #15
    3394:	d80d      	bhi.n	33b2 <usb_lld_get_status_in+0x22>
    3396:	4b07      	ldr	r3, [pc, #28]	; (33b4 <usb_lld_get_status_in+0x24>)
    3398:	0089      	lsls	r1, r1, #2
    339a:	469c      	mov	ip, r3
  if(!(USB0->ENDPT[ep].V & (USBx_ENDPTn_EPTXEN)))
    339c:	23c0      	movs	r3, #192	; 0xc0
    339e:	4461      	add	r1, ip
    33a0:	5cca      	ldrb	r2, [r1, r3]
    33a2:	0752      	lsls	r2, r2, #29
    33a4:	d505      	bpl.n	33b2 <usb_lld_get_status_in+0x22>
  else if(USB0->ENDPT[ep].V & USBx_ENDPTn_EPSTALL)
    33a6:	5ccb      	ldrb	r3, [r1, r3]
    33a8:	3002      	adds	r0, #2
    33aa:	4018      	ands	r0, r3
  return EP_STATUS_ACTIVE;
    33ac:	4243      	negs	r3, r0
    33ae:	4158      	adcs	r0, r3
    33b0:	3001      	adds	r0, #1
}
    33b2:	4770      	bx	lr
    33b4:	40072000 	.word	0x40072000
	...

000033c0 <usb_lld_read_setup>:
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
    33c0:	008b      	lsls	r3, r1, #2
    33c2:	469c      	mov	ip, r3
    33c4:	0001      	movs	r1, r0
    33c6:	4461      	add	r1, ip
  USBOutEndpointState *os = usbp->epc[ep]->out_state;
    33c8:	68cb      	ldr	r3, [r1, #12]
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
    33ca:	b5f0      	push	{r4, r5, r6, r7, lr}
  USBOutEndpointState *os = usbp->epc[ep]->out_state;
    33cc:	699e      	ldr	r6, [r3, #24]
  bd_t *bd = (bd_t*)&_bdt[BDT_INDEX(ep, RX, os->odd_even)];
    33ce:	4663      	mov	r3, ip
    33d0:	7cb0      	ldrb	r0, [r6, #18]
    33d2:	4f0e      	ldr	r7, [pc, #56]	; (340c <usb_lld_read_setup+0x4c>)
    33d4:	4318      	orrs	r0, r3
    33d6:	2300      	movs	r3, #0
    33d8:	00c0      	lsls	r0, r0, #3
    buf[n] = bd->addr[n];
    33da:	183d      	adds	r5, r7, r0
    33dc:	686c      	ldr	r4, [r5, #4]
    33de:	5ce4      	ldrb	r4, [r4, r3]
    33e0:	54d4      	strb	r4, [r2, r3]
    33e2:	3301      	adds	r3, #1
  for (n = 0; n < 8; n++) {
    33e4:	2b08      	cmp	r3, #8
    33e6:	d1f9      	bne.n	33dc <usb_lld_read_setup+0x1c>
  bd->desc = BDT_DESC(usbp->epc[ep]->out_maxsize,DATA0);
    33e8:	2288      	movs	r2, #136	; 0x88
    33ea:	68cb      	ldr	r3, [r1, #12]
    33ec:	8a5b      	ldrh	r3, [r3, #18]
    33ee:	041b      	lsls	r3, r3, #16
    33f0:	431a      	orrs	r2, r3
    33f2:	503a      	str	r2, [r7, r0]
  _bdt[BDT_INDEX(ep, RX, os->odd_even^ODD)].desc = BDT_DESC(usbp->epc[ep]->out_maxsize,DATA1);
    33f4:	2201      	movs	r2, #1
    33f6:	7cb1      	ldrb	r1, [r6, #18]
    33f8:	4051      	eors	r1, r2
    33fa:	4662      	mov	r2, ip
    33fc:	4311      	orrs	r1, r2
    33fe:	22c8      	movs	r2, #200	; 0xc8
    3400:	00c9      	lsls	r1, r1, #3
    3402:	4313      	orrs	r3, r2
    3404:	507b      	str	r3, [r7, r1]
  os->data_bank = DATA1;
    3406:	2301      	movs	r3, #1
    3408:	74f3      	strb	r3, [r6, #19]
}
    340a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    340c:	20000400 	.word	0x20000400

00003410 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
    3410:	3102      	adds	r1, #2
    3412:	0089      	lsls	r1, r1, #2
    3414:	1841      	adds	r1, r0, r1
    3416:	684b      	ldr	r3, [r1, #4]
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
    3418:	b510      	push	{r4, lr}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
    341a:	699c      	ldr	r4, [r3, #24]
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
    341c:	6820      	ldr	r0, [r4, #0]
    341e:	2800      	cmp	r0, #0
    3420:	d006      	beq.n	3430 <usb_lld_start_out+0x20>
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
    3422:	8a59      	ldrh	r1, [r3, #18]
    3424:	1840      	adds	r0, r0, r1
    3426:	3801      	subs	r0, #1
    3428:	f7fd f880 	bl	52c <__udivsi3>
    342c:	8220      	strh	r0, [r4, #16]
                             usbp->epc[ep]->out_maxsize);
}
    342e:	bd10      	pop	{r4, pc}
    osp->rxpkts = 1;
    3430:	2301      	movs	r3, #1
    3432:	8223      	strh	r3, [r4, #16]
    3434:	e7fb      	b.n	342e <usb_lld_start_out+0x1e>
    3436:	46c0      	nop			; (mov r8, r8)
	...

00003440 <usb_lld_start_in>:
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  (void)usbp;
  (void)ep;
  usb_packet_transmit(usbp,ep,usbp->epc[ep]->in_state->txsize);
    3440:	1c8b      	adds	r3, r1, #2
    3442:	009b      	lsls	r3, r3, #2
    3444:	18c3      	adds	r3, r0, r3
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
    3446:	b510      	push	{r4, lr}
  usb_packet_transmit(usbp,ep,usbp->epc[ep]->in_state->txsize);
    3448:	685b      	ldr	r3, [r3, #4]
    344a:	695b      	ldr	r3, [r3, #20]
    344c:	681a      	ldr	r2, [r3, #0]
    344e:	f7ff fc37 	bl	2cc0 <usb_packet_transmit>
}
    3452:	bd10      	pop	{r4, pc}
	...

00003460 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
    3460:	4b04      	ldr	r3, [pc, #16]	; (3474 <usb_lld_stall_out+0x14>)
  (void)usbp;
#if KINETIS_USB_USE_USB0
  USB0->ENDPT[ep].V |= USBx_ENDPTn_EPSTALL;
    3462:	22c0      	movs	r2, #192	; 0xc0
    3464:	469c      	mov	ip, r3
    3466:	2002      	movs	r0, #2
    3468:	0089      	lsls	r1, r1, #2
    346a:	4461      	add	r1, ip
    346c:	5c8b      	ldrb	r3, [r1, r2]
    346e:	4303      	orrs	r3, r0
    3470:	548b      	strb	r3, [r1, r2]
#endif /* KINETIS_USB_USE_USB0 */
}
    3472:	4770      	bx	lr
    3474:	40072000 	.word	0x40072000
	...

00003480 <usb_lld_stall_in>:
    3480:	4b04      	ldr	r3, [pc, #16]	; (3494 <usb_lld_stall_in+0x14>)
    3482:	22c0      	movs	r2, #192	; 0xc0
    3484:	469c      	mov	ip, r3
    3486:	2002      	movs	r0, #2
    3488:	0089      	lsls	r1, r1, #2
    348a:	4461      	add	r1, ip
    348c:	5c8b      	ldrb	r3, [r1, r2]
    348e:	4303      	orrs	r3, r0
    3490:	548b      	strb	r3, [r1, r2]
    3492:	4770      	bx	lr
    3494:	40072000 	.word	0x40072000
	...

000034a0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
    34a0:	4b04      	ldr	r3, [pc, #16]	; (34b4 <usb_lld_clear_out+0x14>)
  (void)usbp;
#if KINETIS_USB_USE_USB0
  USB0->ENDPT[ep].V &= ~USBx_ENDPTn_EPSTALL;
    34a2:	22c0      	movs	r2, #192	; 0xc0
    34a4:	469c      	mov	ip, r3
    34a6:	2002      	movs	r0, #2
    34a8:	0089      	lsls	r1, r1, #2
    34aa:	4461      	add	r1, ip
    34ac:	5c8b      	ldrb	r3, [r1, r2]
    34ae:	4383      	bics	r3, r0
    34b0:	548b      	strb	r3, [r1, r2]
#endif /* KINETIS_USB_USE_USB0 */
}
    34b2:	4770      	bx	lr
    34b4:	40072000 	.word	0x40072000
	...

000034c0 <usb_lld_clear_in>:
    34c0:	4b04      	ldr	r3, [pc, #16]	; (34d4 <usb_lld_clear_in+0x14>)
    34c2:	22c0      	movs	r2, #192	; 0xc0
    34c4:	469c      	mov	ip, r3
    34c6:	2002      	movs	r0, #2
    34c8:	0089      	lsls	r1, r1, #2
    34ca:	4461      	add	r1, ip
    34cc:	5c8b      	ldrb	r3, [r1, r2]
    34ce:	4383      	bics	r3, r0
    34d0:	548b      	strb	r3, [r1, r2]
    34d2:	4770      	bx	lr
    34d4:	40072000 	.word	0x40072000
	...

000034e0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
    34e0:	b510      	push	{r4, lr}

  kl2x_clock_init();
    34e2:	f7ff fa7d 	bl	29e0 <kl2x_clock_init>
}
    34e6:	bd10      	pop	{r4, pc}
	...

000034f0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
    34f0:	4770      	bx	lr
    34f2:	46c0      	nop			; (mov r8, r8)
	...

00003500 <usb_get_descriptor_cb>:
/*
 * Handles the GET_DESCRIPTOR callback
 *
 * Returns the proper descriptor
 */
static const USBDescriptor *usb_get_descriptor_cb(USBDriver *usbp, uint8_t dtype, uint8_t dindex, uint16_t lang) {
    3500:	b510      	push	{r4, lr}
  (void)usbp;
  (void)lang;
  switch(dtype) {
    3502:	2922      	cmp	r1, #34	; 0x22
    3504:	d819      	bhi.n	353a <usb_get_descriptor_cb+0x3a>
    3506:	4c18      	ldr	r4, [pc, #96]	; (3568 <usb_get_descriptor_cb+0x68>)
    3508:	0089      	lsls	r1, r1, #2
    350a:	5861      	ldr	r1, [r4, r1]
    350c:	468f      	mov	pc, r1
  /* Generic descriptors */
  case USB_DESCRIPTOR_DEVICE:   /* Device Descriptor */
    return &usb_device_descriptor;
    350e:	4817      	ldr	r0, [pc, #92]	; (356c <usb_get_descriptor_cb+0x6c>)
      return &nkro_hid_report_descriptor;
#endif /* NKRO_ENABLE */
    }
  }
  return NULL;
}
    3510:	bd10      	pop	{r4, pc}
    if(dindex < 4)
    3512:	2a03      	cmp	r2, #3
    3514:	d811      	bhi.n	353a <usb_get_descriptor_cb+0x3a>
      return &usb_strings[dindex];
    3516:	4816      	ldr	r0, [pc, #88]	; (3570 <usb_get_descriptor_cb+0x70>)
    3518:	00d2      	lsls	r2, r2, #3
    351a:	1880      	adds	r0, r0, r2
    351c:	e7f8      	b.n	3510 <usb_get_descriptor_cb+0x10>
    switch(lang) {    /* yea, poor label, it's actually wIndex from the setup packet */
    351e:	2b04      	cmp	r3, #4
    3520:	d80b      	bhi.n	353a <usb_get_descriptor_cb+0x3a>
    3522:	4a14      	ldr	r2, [pc, #80]	; (3574 <usb_get_descriptor_cb+0x74>)
    3524:	009b      	lsls	r3, r3, #2
    3526:	58d3      	ldr	r3, [r2, r3]
    3528:	469f      	mov	pc, r3
    switch(lang) {
    352a:	2b04      	cmp	r3, #4
    352c:	d805      	bhi.n	353a <usb_get_descriptor_cb+0x3a>
    352e:	4a12      	ldr	r2, [pc, #72]	; (3578 <usb_get_descriptor_cb+0x78>)
    3530:	009b      	lsls	r3, r3, #2
    3532:	58d3      	ldr	r3, [r2, r3]
    3534:	469f      	mov	pc, r3
    return &hid_configuration_descriptor;
    3536:	4811      	ldr	r0, [pc, #68]	; (357c <usb_get_descriptor_cb+0x7c>)
    3538:	e7ea      	b.n	3510 <usb_get_descriptor_cb+0x10>
  return NULL;
    353a:	2000      	movs	r0, #0
    353c:	e7e8      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &extra_hid_report_descriptor;
    353e:	4810      	ldr	r0, [pc, #64]	; (3580 <usb_get_descriptor_cb+0x80>)
    3540:	e7e6      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &console_hid_report_descriptor;
    3542:	4810      	ldr	r0, [pc, #64]	; (3584 <usb_get_descriptor_cb+0x84>)
    3544:	e7e4      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &mouse_hid_report_descriptor;
    3546:	4810      	ldr	r0, [pc, #64]	; (3588 <usb_get_descriptor_cb+0x88>)
    3548:	e7e2      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &keyboard_hid_report_descriptor;
    354a:	4810      	ldr	r0, [pc, #64]	; (358c <usb_get_descriptor_cb+0x8c>)
    354c:	e7e0      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &nkro_hid_report_descriptor;
    354e:	4810      	ldr	r0, [pc, #64]	; (3590 <usb_get_descriptor_cb+0x90>)
    3550:	e7de      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &extra_hid_descriptor;
    3552:	4810      	ldr	r0, [pc, #64]	; (3594 <usb_get_descriptor_cb+0x94>)
    3554:	e7dc      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &console_hid_descriptor;
    3556:	4810      	ldr	r0, [pc, #64]	; (3598 <usb_get_descriptor_cb+0x98>)
    3558:	e7da      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &mouse_hid_descriptor;
    355a:	4810      	ldr	r0, [pc, #64]	; (359c <usb_get_descriptor_cb+0x9c>)
    355c:	e7d8      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &keyboard_hid_descriptor;
    355e:	4810      	ldr	r0, [pc, #64]	; (35a0 <usb_get_descriptor_cb+0xa0>)
    3560:	e7d6      	b.n	3510 <usb_get_descriptor_cb+0x10>
      return &nkro_hid_descriptor;
    3562:	4810      	ldr	r0, [pc, #64]	; (35a4 <usb_get_descriptor_cb+0xa4>)
    3564:	e7d4      	b.n	3510 <usb_get_descriptor_cb+0x10>
    3566:	46c0      	nop			; (mov r8, r8)
    3568:	00008184 	.word	0x00008184
    356c:	0000851c 	.word	0x0000851c
    3570:	0000856c 	.word	0x0000856c
    3574:	00008210 	.word	0x00008210
    3578:	00008224 	.word	0x00008224
    357c:	00008320 	.word	0x00008320
    3580:	00008318 	.word	0x00008318
    3584:	000082b0 	.word	0x000082b0
    3588:	000084a4 	.word	0x000084a4
    358c:	0000841c 	.word	0x0000841c
    3590:	00008514 	.word	0x00008514
    3594:	000082dc 	.word	0x000082dc
    3598:	00008290 	.word	0x00008290
    359c:	00008448 	.word	0x00008448
    35a0:	000083d4 	.word	0x000083d4
    35a4:	000084d0 	.word	0x000084d0
	...

000035b0 <kbd_in_cb>:
/* keyboard IN callback hander (a kbd report has made it IN) */
void kbd_in_cb(USBDriver *usbp, usbep_t ep) {
  /* STUB */
  (void)usbp;
  (void)ep;
}
    35b0:	4770      	bx	lr
    35b2:	46c0      	nop			; (mov r8, r8)
	...

000035c0 <console_queue_onotify>:
  osalSysUnlockFromISR();
}

/* Callback when data is inserted into the output queue
 * Called from a locked state */
void console_queue_onotify(io_buffers_queue_t *bqp) {
    35c0:	b510      	push	{r4, lr}
  size_t n;
  USBDriver *usbp = bqGetLinkX(bqp);
    35c2:	6b44      	ldr	r4, [r0, #52]	; 0x34
void console_queue_onotify(io_buffers_queue_t *bqp) {
    35c4:	b082      	sub	sp, #8

  if(usbGetDriverStateI(usbp) != USB_ACTIVE)
    35c6:	7823      	ldrb	r3, [r4, #0]
    35c8:	2b04      	cmp	r3, #4
    35ca:	d001      	beq.n	35d0 <console_queue_onotify+0x10>
      /* Buffer found, starting a new transaction.*/
      /* Should have n == CONSOLE_EPSIZE; check this? */
      usbStartTransmitI(usbp, CONSOLE_ENDPOINT, buf, CONSOLE_EPSIZE);
    }
  }
}
    35cc:	b002      	add	sp, #8
    35ce:	bd10      	pop	{r4, pc}
  if (!usbGetTransmitStatusI(usbp, CONSOLE_ENDPOINT)) {
    35d0:	8923      	ldrh	r3, [r4, #8]
    35d2:	071b      	lsls	r3, r3, #28
    35d4:	d4fa      	bmi.n	35cc <console_queue_onotify+0xc>
    uint8_t *buf = obqGetFullBufferI(&console_buf_queue, &n);
    35d6:	a901      	add	r1, sp, #4
    35d8:	4805      	ldr	r0, [pc, #20]	; (35f0 <console_queue_onotify+0x30>)
    35da:	f7fe fca1 	bl	1f20 <obqGetFullBufferI>
    if (buf != NULL) {
    35de:	2800      	cmp	r0, #0
    35e0:	d0f4      	beq.n	35cc <console_queue_onotify+0xc>
      usbStartTransmitI(usbp, CONSOLE_ENDPOINT, buf, CONSOLE_EPSIZE);
    35e2:	0002      	movs	r2, r0
    35e4:	2310      	movs	r3, #16
    35e6:	2103      	movs	r1, #3
    35e8:	0020      	movs	r0, r4
    35ea:	f7fe fec1 	bl	2370 <usbStartTransmitI>
    35ee:	e7ed      	b.n	35cc <console_queue_onotify+0xc>
    35f0:	20000af4 	.word	0x20000af4
	...

00003600 <mouse_in_cb>:
    3600:	4770      	bx	lr
    3602:	46c0      	nop			; (mov r8, r8)
	...

00003610 <extra_in_cb>:
    3610:	4770      	bx	lr
    3612:	46c0      	nop			; (mov r8, r8)
	...

00003620 <nkro_in_cb>:
    3620:	4770      	bx	lr
    3622:	46c0      	nop			; (mov r8, r8)
	...

00003630 <usb_sof_cb>:
    3630:	4770      	bx	lr
    3632:	46c0      	nop			; (mov r8, r8)
	...

00003640 <console_in_cb>:
void console_in_cb(USBDriver *usbp, usbep_t ep) {
    3640:	b530      	push	{r4, r5, lr}
    3642:	0004      	movs	r4, r0
    3644:	b083      	sub	sp, #12
  __ASM volatile ("cpsid i" : : : "memory");
    3646:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    3648:	f7fd fcfa 	bl	1040 <_dbg_check_lock_from_isr>
    364c:	f7fd fd58 	bl	1100 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
    3650:	4d13      	ldr	r5, [pc, #76]	; (36a0 <console_in_cb+0x60>)
  if (chVTIsArmedI(vtp)) {
    3652:	68eb      	ldr	r3, [r5, #12]
    3654:	2b00      	cmp	r3, #0
    3656:	d002      	beq.n	365e <console_in_cb+0x1e>
    chVTDoResetI(vtp);
    3658:	0028      	movs	r0, r5
    365a:	f7fd fdc1 	bl	11e0 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
    365e:	0023      	movs	r3, r4
    3660:	0028      	movs	r0, r5
    3662:	4a10      	ldr	r2, [pc, #64]	; (36a4 <console_in_cb+0x64>)
    3664:	2132      	movs	r1, #50	; 0x32
    3666:	f7fd fd8b 	bl	1180 <chVTDoSetI>
  if (usbp->epc[CONSOLE_ENDPOINT]->in_state->txsize > 0U) {
    366a:	69a3      	ldr	r3, [r4, #24]
    obqReleaseEmptyBufferI(&console_buf_queue);
    366c:	4d0e      	ldr	r5, [pc, #56]	; (36a8 <console_in_cb+0x68>)
  if (usbp->epc[CONSOLE_ENDPOINT]->in_state->txsize > 0U) {
    366e:	695b      	ldr	r3, [r3, #20]
    3670:	681b      	ldr	r3, [r3, #0]
    3672:	2b00      	cmp	r3, #0
    3674:	d110      	bne.n	3698 <console_in_cb+0x58>
  buf = obqGetFullBufferI(&console_buf_queue, &n);
    3676:	a901      	add	r1, sp, #4
    3678:	0028      	movs	r0, r5
    367a:	f7fe fc51 	bl	1f20 <obqGetFullBufferI>
  if (buf != NULL) {
    367e:	2800      	cmp	r0, #0
    3680:	d005      	beq.n	368e <console_in_cb+0x4e>
    usbStartTransmitI(usbp, CONSOLE_ENDPOINT, buf, CONSOLE_EPSIZE);
    3682:	0002      	movs	r2, r0
    3684:	2310      	movs	r3, #16
    3686:	2103      	movs	r1, #3
    3688:	0020      	movs	r0, r4
    368a:	f7fe fe71 	bl	2370 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
    368e:	f7fd fcef 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    3692:	b662      	cpsie	i
}
    3694:	b003      	add	sp, #12
    3696:	bd30      	pop	{r4, r5, pc}
    obqReleaseEmptyBufferI(&console_buf_queue);
    3698:	0028      	movs	r0, r5
    369a:	f7fe fc59 	bl	1f50 <obqReleaseEmptyBufferI>
    369e:	e7ea      	b.n	3676 <console_in_cb+0x36>
    36a0:	20000b40 	.word	0x20000b40
    36a4:	00003741 	.word	0x00003741
    36a8:	20000af4 	.word	0x20000af4
    36ac:	00000000 	.word	0x00000000

000036b0 <keyboard_idle_timer_cb>:
static void keyboard_idle_timer_cb(void *arg) {
    36b0:	b570      	push	{r4, r5, r6, lr}
    36b2:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
    36b4:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    36b6:	f7fd fcc3 	bl	1040 <_dbg_check_lock_from_isr>
  if(usbGetDriverStateI(usbp) != USB_ACTIVE) {
    36ba:	7823      	ldrb	r3, [r4, #0]
    36bc:	2b04      	cmp	r3, #4
    36be:	d126      	bne.n	370e <keyboard_idle_timer_cb+0x5e>
  if(!keyboard_nkro && keyboard_idle) {
    36c0:	4b19      	ldr	r3, [pc, #100]	; (3728 <keyboard_idle_timer_cb+0x78>)
    36c2:	781b      	ldrb	r3, [r3, #0]
    36c4:	2b00      	cmp	r3, #0
    36c6:	d122      	bne.n	370e <keyboard_idle_timer_cb+0x5e>
    36c8:	4d18      	ldr	r5, [pc, #96]	; (372c <keyboard_idle_timer_cb+0x7c>)
    36ca:	782a      	ldrb	r2, [r5, #0]
    36cc:	2a00      	cmp	r2, #0
    36ce:	d01e      	beq.n	370e <keyboard_idle_timer_cb+0x5e>
    if(!usbGetTransmitStatusI(usbp, KBD_ENDPOINT)) {
    36d0:	8923      	ldrh	r3, [r4, #8]
    36d2:	079b      	lsls	r3, r3, #30
    36d4:	d51f      	bpl.n	3716 <keyboard_idle_timer_cb+0x66>
    chVTSetI(&keyboard_idle_timer, 4*MS2ST(keyboard_idle), keyboard_idle_timer_cb, (void *)usbp);
    36d6:	4b16      	ldr	r3, [pc, #88]	; (3730 <keyboard_idle_timer_cb+0x80>)
    36d8:	21fa      	movs	r1, #250	; 0xfa
    36da:	469c      	mov	ip, r3
    36dc:	0150      	lsls	r0, r2, #5
    36de:	1a80      	subs	r0, r0, r2
    36e0:	0080      	lsls	r0, r0, #2
    36e2:	1880      	adds	r0, r0, r2
    36e4:	00c0      	lsls	r0, r0, #3
    36e6:	4460      	add	r0, ip
    36e8:	0089      	lsls	r1, r1, #2
    36ea:	f7fc ff1f 	bl	52c <__udivsi3>
    36ee:	0085      	lsls	r5, r0, #2
  chDbgCheckClassI();
    36f0:	f7fd fd06 	bl	1100 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
    36f4:	4e0f      	ldr	r6, [pc, #60]	; (3734 <keyboard_idle_timer_cb+0x84>)
  if (chVTIsArmedI(vtp)) {
    36f6:	68f3      	ldr	r3, [r6, #12]
    36f8:	2b00      	cmp	r3, #0
    36fa:	d002      	beq.n	3702 <keyboard_idle_timer_cb+0x52>
    chVTDoResetI(vtp);
    36fc:	0030      	movs	r0, r6
    36fe:	f7fd fd6f 	bl	11e0 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
    3702:	0023      	movs	r3, r4
    3704:	4a0c      	ldr	r2, [pc, #48]	; (3738 <keyboard_idle_timer_cb+0x88>)
    3706:	0029      	movs	r1, r5
    3708:	0030      	movs	r0, r6
    370a:	f7fd fd39 	bl	1180 <chVTDoSetI>
  _dbg_check_unlock_from_isr();
    370e:	f7fd fcaf 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    3712:	b662      	cpsie	i
}
    3714:	bd70      	pop	{r4, r5, r6, pc}
      usbStartTransmitI(usbp, KBD_ENDPOINT, (uint8_t *)&keyboard_report_sent, KBD_EPSIZE);
    3716:	4a09      	ldr	r2, [pc, #36]	; (373c <keyboard_idle_timer_cb+0x8c>)
    3718:	2308      	movs	r3, #8
    371a:	2101      	movs	r1, #1
    371c:	0020      	movs	r0, r4
    371e:	f7fe fe27 	bl	2370 <usbStartTransmitI>
    3722:	782a      	ldrb	r2, [r5, #0]
    3724:	e7d7      	b.n	36d6 <keyboard_idle_timer_cb+0x26>
    3726:	46c0      	nop			; (mov r8, r8)
    3728:	1ffffe31 	.word	0x1ffffe31
    372c:	20000bd0 	.word	0x20000bd0
    3730:	000003e7 	.word	0x000003e7
    3734:	20000bd4 	.word	0x20000bd4
    3738:	000036b1 	.word	0x000036b1
    373c:	20000bec 	.word	0x20000bec

00003740 <console_flush_cb>:

/* Flush timer code
 * callback (called from ISR, unlocked state) */
static void console_flush_cb(void *arg) {
    3740:	b530      	push	{r4, r5, lr}
    3742:	0004      	movs	r4, r0
    3744:	b083      	sub	sp, #12
  __ASM volatile ("cpsid i" : : : "memory");
    3746:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    3748:	f7fd fc7a 	bl	1040 <_dbg_check_lock_from_isr>
  USBDriver *usbp = (USBDriver *)arg;
  osalSysLockFromISR();

  /* check that the states of things are as they're supposed to */
  if(usbGetDriverStateI(usbp) != USB_ACTIVE) {
    374c:	7823      	ldrb	r3, [r4, #0]
    374e:	2b04      	cmp	r3, #4
    3750:	d108      	bne.n	3764 <console_flush_cb+0x24>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(usbp, CONSOLE_ENDPOINT)) {
    3752:	8923      	ldrh	r3, [r4, #8]
    3754:	071b      	lsls	r3, r3, #28
    3756:	d405      	bmi.n	3764 <console_flush_cb+0x24>
    return;
  }

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if(obqTryFlushI(&console_buf_queue)) {
    3758:	4d1a      	ldr	r5, [pc, #104]	; (37c4 <console_flush_cb+0x84>)
    375a:	0028      	movs	r0, r5
    375c:	f7fe fcc0 	bl	20e0 <obqTryFlushI>
    3760:	2800      	cmp	r0, #0
    3762:	d113      	bne.n	378c <console_flush_cb+0x4c>
  chDbgCheckClassI();
    3764:	f7fd fccc 	bl	1100 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
    3768:	4d17      	ldr	r5, [pc, #92]	; (37c8 <console_flush_cb+0x88>)
  if (chVTIsArmedI(vtp)) {
    376a:	68eb      	ldr	r3, [r5, #12]
    376c:	2b00      	cmp	r3, #0
    376e:	d002      	beq.n	3776 <console_flush_cb+0x36>
    chVTDoResetI(vtp);
    3770:	0028      	movs	r0, r5
    3772:	f7fd fd35 	bl	11e0 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
    3776:	0023      	movs	r3, r4
    3778:	4a14      	ldr	r2, [pc, #80]	; (37cc <console_flush_cb+0x8c>)
    377a:	2132      	movs	r1, #50	; 0x32
    377c:	0028      	movs	r0, r5
    377e:	f7fd fcff 	bl	1180 <chVTDoSetI>
  _dbg_check_unlock_from_isr();
    3782:	f7fd fc75 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    3786:	b662      	cpsie	i
  }

  /* rearm the timer */
  chVTSetI(&console_flush_timer, MS2ST(CONSOLE_FLUSH_MS), console_flush_cb, (void *)usbp);
  osalSysUnlockFromISR();
}
    3788:	b003      	add	sp, #12
    378a:	bd30      	pop	{r4, r5, pc}
    uint8_t *buf = obqGetFullBufferI(&console_buf_queue, &n);
    378c:	0028      	movs	r0, r5
    378e:	a901      	add	r1, sp, #4
    3790:	f7fe fbc6 	bl	1f20 <obqGetFullBufferI>
    3794:	1e05      	subs	r5, r0, #0
    osalDbgAssert(buf != NULL, "queue is empty");
    3796:	d011      	beq.n	37bc <console_flush_cb+0x7c>
    for(i=n; i<CONSOLE_EPSIZE; i++)
    3798:	9b01      	ldr	r3, [sp, #4]
    379a:	2b0f      	cmp	r3, #15
    379c:	d807      	bhi.n	37ae <console_flush_cb+0x6e>
    379e:	0029      	movs	r1, r5
      buf[i]=0;
    37a0:	2200      	movs	r2, #0
    37a2:	18eb      	adds	r3, r5, r3
    37a4:	3110      	adds	r1, #16
    37a6:	701a      	strb	r2, [r3, #0]
    37a8:	3301      	adds	r3, #1
    for(i=n; i<CONSOLE_EPSIZE; i++)
    37aa:	428b      	cmp	r3, r1
    37ac:	d1fb      	bne.n	37a6 <console_flush_cb+0x66>
    usbStartTransmitI(usbp, CONSOLE_ENDPOINT, buf, CONSOLE_EPSIZE);
    37ae:	2310      	movs	r3, #16
    37b0:	002a      	movs	r2, r5
    37b2:	2103      	movs	r1, #3
    37b4:	0020      	movs	r0, r4
    37b6:	f7fe fddb 	bl	2370 <usbStartTransmitI>
    37ba:	e7d3      	b.n	3764 <console_flush_cb+0x24>
    osalDbgAssert(buf != NULL, "queue is empty");
    37bc:	4804      	ldr	r0, [pc, #16]	; (37d0 <console_flush_cb+0x90>)
    37be:	f7fd fbbf 	bl	f40 <chSysHalt>
    37c2:	e7e9      	b.n	3798 <console_flush_cb+0x58>
    37c4:	20000af4 	.word	0x20000af4
    37c8:	20000b40 	.word	0x20000b40
    37cc:	00003741 	.word	0x00003741
    37d0:	00008258 	.word	0x00008258
	...

000037e0 <usb_request_hook_cb>:
  if(((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) &&
    37e0:	227f      	movs	r2, #127	; 0x7f
    37e2:	23d4      	movs	r3, #212	; 0xd4
    37e4:	0011      	movs	r1, r2
static bool usb_request_hook_cb(USBDriver *usbp) {
    37e6:	b570      	push	{r4, r5, r6, lr}
  if(((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) &&
    37e8:	5cc3      	ldrb	r3, [r0, r3]
static bool usb_request_hook_cb(USBDriver *usbp) {
    37ea:	0004      	movs	r4, r0
  if(((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) &&
    37ec:	4019      	ands	r1, r3
    37ee:	2921      	cmp	r1, #33	; 0x21
    37f0:	d021      	beq.n	3836 <usb_request_hook_cb+0x56>
  if((usbp->setup[0] == 0x81) && (usbp->setup[1] == USB_REQ_GET_DESCRIPTOR)) {
    37f2:	22d4      	movs	r2, #212	; 0xd4
    37f4:	4b70      	ldr	r3, [pc, #448]	; (39b8 <usb_request_hook_cb+0x1d8>)
    37f6:	5aa2      	ldrh	r2, [r4, r2]
    37f8:	429a      	cmp	r2, r3
    37fa:	d11a      	bne.n	3832 <usb_request_hook_cb+0x52>
  hw |= (uint16_t)*p << 8U;
    37fc:	23d9      	movs	r3, #217	; 0xd9
    37fe:	5ce2      	ldrb	r2, [r4, r3]
  hw = (uint16_t)*p++;
    3800:	3b01      	subs	r3, #1
  hw |= (uint16_t)*p << 8U;
    3802:	5ce3      	ldrb	r3, [r4, r3]
    3804:	0212      	lsls	r2, r2, #8
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3], usbp->setup[2], get_hword(&usbp->setup[4]));
    3806:	4313      	orrs	r3, r2
    3808:	21d7      	movs	r1, #215	; 0xd7
    380a:	22d6      	movs	r2, #214	; 0xd6
    380c:	6860      	ldr	r0, [r4, #4]
    380e:	5ca2      	ldrb	r2, [r4, r2]
    3810:	6845      	ldr	r5, [r0, #4]
    3812:	5c61      	ldrb	r1, [r4, r1]
    3814:	0020      	movs	r0, r4
    3816:	47a8      	blx	r5
    if(dp == NULL)
    3818:	2800      	cmp	r0, #0
    381a:	d00a      	beq.n	3832 <usb_request_hook_cb+0x52>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    381c:	23c8      	movs	r3, #200	; 0xc8
    381e:	6842      	ldr	r2, [r0, #4]
    3820:	50e2      	str	r2, [r4, r3]
    3822:	6802      	ldr	r2, [r0, #0]
    3824:	3304      	adds	r3, #4
          usbSetupTransfer(usbp, (uint8_t *)&mouse_report_blank, sizeof(mouse_report_blank), NULL);
    3826:	50e2      	str	r2, [r4, r3]
    3828:	2200      	movs	r2, #0
          return TRUE;
    382a:	2001      	movs	r0, #1
          usbSetupTransfer(usbp, (uint8_t *)&mouse_report_blank, sizeof(mouse_report_blank), NULL);
    382c:	3304      	adds	r3, #4
    382e:	50e2      	str	r2, [r4, r3]
}
    3830:	bd70      	pop	{r4, r5, r6, pc}
                return FALSE;
    3832:	2000      	movs	r0, #0
    3834:	e7fc      	b.n	3830 <usb_request_hook_cb+0x50>
    switch(usbp->setup[0] & USB_RTYPE_DIR_MASK) {
    3836:	4393      	bics	r3, r2
    3838:	d013      	beq.n	3862 <usb_request_hook_cb+0x82>
    383a:	2b80      	cmp	r3, #128	; 0x80
    383c:	d1d9      	bne.n	37f2 <usb_request_hook_cb+0x12>
      switch(usbp->setup[1]) {   /* bRequest */
    383e:	3355      	adds	r3, #85	; 0x55
    3840:	5cc3      	ldrb	r3, [r0, r3]
    3842:	2b02      	cmp	r3, #2
    3844:	d100      	bne.n	3848 <usb_request_hook_cb+0x68>
    3846:	e0a9      	b.n	399c <usb_request_hook_cb+0x1bc>
    3848:	2b03      	cmp	r3, #3
    384a:	d100      	bne.n	384e <usb_request_hook_cb+0x6e>
    384c:	e097      	b.n	397e <usb_request_hook_cb+0x19e>
    384e:	2b01      	cmp	r3, #1
    3850:	d1cf      	bne.n	37f2 <usb_request_hook_cb+0x12>
        switch(usbp->setup[4]) {     /* LSB(wIndex) (check MSB==0?) */
    3852:	33d7      	adds	r3, #215	; 0xd7
    3854:	5cc3      	ldrb	r3, [r0, r3]
    3856:	2b04      	cmp	r3, #4
    3858:	d875      	bhi.n	3946 <usb_request_hook_cb+0x166>
    385a:	4a58      	ldr	r2, [pc, #352]	; (39bc <usb_request_hook_cb+0x1dc>)
    385c:	009b      	lsls	r3, r3, #2
    385e:	58d3      	ldr	r3, [r2, r3]
    3860:	469f      	mov	pc, r3
      switch(usbp->setup[1]) {   /* bRequest */
    3862:	23d5      	movs	r3, #213	; 0xd5
    3864:	5cc3      	ldrb	r3, [r0, r3]
    3866:	2b0a      	cmp	r3, #10
    3868:	d076      	beq.n	3958 <usb_request_hook_cb+0x178>
    386a:	2b0b      	cmp	r3, #11
    386c:	d034      	beq.n	38d8 <usb_request_hook_cb+0xf8>
    386e:	2b09      	cmp	r3, #9
    3870:	d1bf      	bne.n	37f2 <usb_request_hook_cb+0x12>
        switch(usbp->setup[4]) {       /* LSB(wIndex) (check MSB==0 and wLength==1?) */
    3872:	33cf      	adds	r3, #207	; 0xcf
    3874:	5cc3      	ldrb	r3, [r0, r3]
    3876:	2b00      	cmp	r3, #0
    3878:	d001      	beq.n	387e <usb_request_hook_cb+0x9e>
    387a:	2b04      	cmp	r3, #4
    387c:	d1b9      	bne.n	37f2 <usb_request_hook_cb+0x12>
          usbSetupTransfer(usbp, (uint8_t *)&keyboard_led_stats, 1, NULL);
    387e:	23c8      	movs	r3, #200	; 0xc8
    3880:	4a4f      	ldr	r2, [pc, #316]	; (39c0 <usb_request_hook_cb+0x1e0>)
    3882:	50e2      	str	r2, [r4, r3]
    3884:	3304      	adds	r3, #4
    3886:	2201      	movs	r2, #1
    3888:	e7cd      	b.n	3826 <usb_request_hook_cb+0x46>
          usbSetupTransfer(usbp, console_queue_buffer, CONSOLE_EPSIZE, NULL);
    388a:	23c8      	movs	r3, #200	; 0xc8
    388c:	4a4d      	ldr	r2, [pc, #308]	; (39c4 <usb_request_hook_cb+0x1e4>)
    388e:	50c2      	str	r2, [r0, r3]
    3890:	3304      	adds	r3, #4
    3892:	2210      	movs	r2, #16
    3894:	e7c7      	b.n	3826 <usb_request_hook_cb+0x46>
          usbSetupTransfer(usbp, (uint8_t *)&mouse_report_blank, sizeof(mouse_report_blank), NULL);
    3896:	23c8      	movs	r3, #200	; 0xc8
    3898:	4a4b      	ldr	r2, [pc, #300]	; (39c8 <usb_request_hook_cb+0x1e8>)
    389a:	50c2      	str	r2, [r0, r3]
    389c:	3304      	adds	r3, #4
    389e:	2205      	movs	r2, #5
    38a0:	e7c1      	b.n	3826 <usb_request_hook_cb+0x46>
          usbSetupTransfer(usbp, (uint8_t *)&keyboard_report_sent, sizeof(keyboard_report_sent), NULL);
    38a2:	23c8      	movs	r3, #200	; 0xc8
    38a4:	4a49      	ldr	r2, [pc, #292]	; (39cc <usb_request_hook_cb+0x1ec>)
    38a6:	50c2      	str	r2, [r0, r3]
    38a8:	3304      	adds	r3, #4
    38aa:	2210      	movs	r2, #16
    38ac:	e7bb      	b.n	3826 <usb_request_hook_cb+0x46>
          if(usbp->setup[3] == 1) { /* MSB(wValue) [Report Type] == 1 [Input Report] */
    38ae:	23d7      	movs	r3, #215	; 0xd7
    38b0:	5cc3      	ldrb	r3, [r0, r3]
    38b2:	2b01      	cmp	r3, #1
    38b4:	d1bd      	bne.n	3832 <usb_request_hook_cb+0x52>
            switch(usbp->setup[2]) { /* LSB(wValue) [Report ID] */
    38b6:	23d6      	movs	r3, #214	; 0xd6
    38b8:	5cc3      	ldrb	r3, [r0, r3]
    38ba:	2b02      	cmp	r3, #2
    38bc:	d074      	beq.n	39a8 <usb_request_hook_cb+0x1c8>
    38be:	2b03      	cmp	r3, #3
    38c0:	d1b7      	bne.n	3832 <usb_request_hook_cb+0x52>
                usbSetupTransfer(usbp, (uint8_t *)extra_report_blank, sizeof(extra_report_blank), NULL);
    38c2:	21c8      	movs	r1, #200	; 0xc8
                extra_report_blank[0] = REPORT_ID_CONSUMER;
    38c4:	4a42      	ldr	r2, [pc, #264]	; (39d0 <usb_request_hook_cb+0x1f0>)
                usbSetupTransfer(usbp, (uint8_t *)extra_report_blank, sizeof(extra_report_blank), NULL);
    38c6:	5042      	str	r2, [r0, r1]
                extra_report_blank[0] = REPORT_ID_CONSUMER;
    38c8:	7013      	strb	r3, [r2, #0]
                usbSetupTransfer(usbp, (uint8_t *)extra_report_blank, sizeof(extra_report_blank), NULL);
    38ca:	22cc      	movs	r2, #204	; 0xcc
    38cc:	5083      	str	r3, [r0, r2]
    38ce:	23d0      	movs	r3, #208	; 0xd0
    38d0:	2200      	movs	r2, #0
    38d2:	50c2      	str	r2, [r0, r3]
                return TRUE;
    38d4:	2001      	movs	r0, #1
    38d6:	e7ab      	b.n	3830 <usb_request_hook_cb+0x50>
        if((usbp->setup[4] == KBD_INTERFACE) && (usbp->setup[5] == 0)) {   /* wIndex */
    38d8:	23d8      	movs	r3, #216	; 0xd8
    38da:	5ac3      	ldrh	r3, [r0, r3]
    38dc:	2b00      	cmp	r3, #0
    38de:	d132      	bne.n	3946 <usb_request_hook_cb+0x166>
          keyboard_protocol = ((usbp->setup[2]) != 0x00);   /* LSB(wValue) */
    38e0:	33d6      	adds	r3, #214	; 0xd6
    38e2:	5cc2      	ldrb	r2, [r0, r3]
    38e4:	0013      	movs	r3, r2
    38e6:	1e59      	subs	r1, r3, #1
    38e8:	418b      	sbcs	r3, r1
    38ea:	493a      	ldr	r1, [pc, #232]	; (39d4 <usb_request_hook_cb+0x1f4>)
    38ec:	b2db      	uxtb	r3, r3
    38ee:	700b      	strb	r3, [r1, #0]
          keyboard_nkro = !!keyboard_protocol;
    38f0:	4939      	ldr	r1, [pc, #228]	; (39d8 <usb_request_hook_cb+0x1f8>)
    38f2:	700b      	strb	r3, [r1, #0]
          if(!keyboard_nkro && keyboard_idle) {
    38f4:	2a00      	cmp	r2, #0
    38f6:	d126      	bne.n	3946 <usb_request_hook_cb+0x166>
    38f8:	4d38      	ldr	r5, [pc, #224]	; (39dc <usb_request_hook_cb+0x1fc>)
    38fa:	782b      	ldrb	r3, [r5, #0]
    38fc:	2b00      	cmp	r3, #0
    38fe:	d022      	beq.n	3946 <usb_request_hook_cb+0x166>
  __ASM volatile ("cpsid i" : : : "memory");
    3900:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    3902:	f7fd fb9d 	bl	1040 <_dbg_check_lock_from_isr>
            chVTSetI(&keyboard_idle_timer, 4*MS2ST(keyboard_idle), keyboard_idle_timer_cb, (void *)usbp);
    3906:	782b      	ldrb	r3, [r5, #0]
    3908:	0158      	lsls	r0, r3, #5
    390a:	1ac0      	subs	r0, r0, r3
    390c:	0080      	lsls	r0, r0, #2
    390e:	18c0      	adds	r0, r0, r3
    3910:	4b33      	ldr	r3, [pc, #204]	; (39e0 <usb_request_hook_cb+0x200>)
    3912:	21fa      	movs	r1, #250	; 0xfa
    3914:	469c      	mov	ip, r3
    3916:	00c0      	lsls	r0, r0, #3
    3918:	4460      	add	r0, ip
    391a:	0089      	lsls	r1, r1, #2
    391c:	f7fc fe06 	bl	52c <__udivsi3>
    3920:	0086      	lsls	r6, r0, #2
  chDbgCheckClassI();
    3922:	f7fd fbed 	bl	1100 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
    3926:	4d2f      	ldr	r5, [pc, #188]	; (39e4 <usb_request_hook_cb+0x204>)
  if (chVTIsArmedI(vtp)) {
    3928:	68eb      	ldr	r3, [r5, #12]
    392a:	2b00      	cmp	r3, #0
    392c:	d002      	beq.n	3934 <usb_request_hook_cb+0x154>
    chVTDoResetI(vtp);
    392e:	0028      	movs	r0, r5
    3930:	f7fd fc56 	bl	11e0 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
    3934:	0023      	movs	r3, r4
    3936:	4a2c      	ldr	r2, [pc, #176]	; (39e8 <usb_request_hook_cb+0x208>)
    3938:	0031      	movs	r1, r6
    393a:	0028      	movs	r0, r5
    393c:	f7fd fc20 	bl	1180 <chVTDoSetI>
  _dbg_check_unlock_from_isr();
    3940:	f7fd fb96 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    3944:	b662      	cpsie	i
        usbSetupTransfer(usbp, NULL, 0, NULL);
    3946:	2300      	movs	r3, #0
    3948:	22c8      	movs	r2, #200	; 0xc8
    394a:	50a3      	str	r3, [r4, r2]
    394c:	3204      	adds	r2, #4
    394e:	50a3      	str	r3, [r4, r2]
    3950:	3204      	adds	r2, #4
    3952:	50a3      	str	r3, [r4, r2]
        return TRUE;
    3954:	2001      	movs	r0, #1
    3956:	e76b      	b.n	3830 <usb_request_hook_cb+0x50>
        keyboard_idle = usbp->setup[3];     /* MSB(wValue) */
    3958:	23d7      	movs	r3, #215	; 0xd7
        if(!keyboard_nkro && keyboard_idle) {
    395a:	4a1f      	ldr	r2, [pc, #124]	; (39d8 <usb_request_hook_cb+0x1f8>)
        keyboard_idle = usbp->setup[3];     /* MSB(wValue) */
    395c:	5cc3      	ldrb	r3, [r0, r3]
    395e:	4d1f      	ldr	r5, [pc, #124]	; (39dc <usb_request_hook_cb+0x1fc>)
        if(!keyboard_nkro && keyboard_idle) {
    3960:	7812      	ldrb	r2, [r2, #0]
        keyboard_idle = usbp->setup[3];     /* MSB(wValue) */
    3962:	702b      	strb	r3, [r5, #0]
        if(!keyboard_nkro && keyboard_idle) {
    3964:	2a00      	cmp	r2, #0
    3966:	d1ee      	bne.n	3946 <usb_request_hook_cb+0x166>
    3968:	2b00      	cmp	r3, #0
    396a:	d0ec      	beq.n	3946 <usb_request_hook_cb+0x166>
  __ASM volatile ("cpsid i" : : : "memory");
    396c:	b672      	cpsid	i
  _dbg_check_lock_from_isr();
    396e:	f7fd fb67 	bl	1040 <_dbg_check_lock_from_isr>
          chVTSetI(&keyboard_idle_timer, 4*MS2ST(keyboard_idle), keyboard_idle_timer_cb, (void *)usbp);
    3972:	782a      	ldrb	r2, [r5, #0]
    3974:	0150      	lsls	r0, r2, #5
    3976:	1a80      	subs	r0, r0, r2
    3978:	0080      	lsls	r0, r0, #2
    397a:	1880      	adds	r0, r0, r2
    397c:	e7c8      	b.n	3910 <usb_request_hook_cb+0x130>
        if((usbp->setup[4] == KBD_INTERFACE) && (usbp->setup[5] == 0)) {   /* wIndex */
    397e:	23d8      	movs	r3, #216	; 0xd8
    3980:	5ac3      	ldrh	r3, [r0, r3]
    3982:	2b00      	cmp	r3, #0
    3984:	d000      	beq.n	3988 <usb_request_hook_cb+0x1a8>
    3986:	e734      	b.n	37f2 <usb_request_hook_cb+0x12>
          usbSetupTransfer(usbp, &keyboard_protocol, 1, NULL);
    3988:	22c8      	movs	r2, #200	; 0xc8
    398a:	4912      	ldr	r1, [pc, #72]	; (39d4 <usb_request_hook_cb+0x1f4>)
    398c:	5081      	str	r1, [r0, r2]
    398e:	2101      	movs	r1, #1
    3990:	3204      	adds	r2, #4
    3992:	5081      	str	r1, [r0, r2]
    3994:	3204      	adds	r2, #4
    3996:	5083      	str	r3, [r0, r2]
          return TRUE;
    3998:	2001      	movs	r0, #1
    399a:	e749      	b.n	3830 <usb_request_hook_cb+0x50>
        usbSetupTransfer(usbp, &keyboard_idle, 1, NULL);
    399c:	23c8      	movs	r3, #200	; 0xc8
    399e:	4a0f      	ldr	r2, [pc, #60]	; (39dc <usb_request_hook_cb+0x1fc>)
    39a0:	50c2      	str	r2, [r0, r3]
    39a2:	3304      	adds	r3, #4
    39a4:	2201      	movs	r2, #1
    39a6:	e73e      	b.n	3826 <usb_request_hook_cb+0x46>
                extra_report_blank[0] = REPORT_ID_SYSTEM;
    39a8:	4a09      	ldr	r2, [pc, #36]	; (39d0 <usb_request_hook_cb+0x1f0>)
    39aa:	7013      	strb	r3, [r2, #0]
                usbSetupTransfer(usbp, (uint8_t *)extra_report_blank, sizeof(extra_report_blank), NULL);
    39ac:	23c8      	movs	r3, #200	; 0xc8
    39ae:	50c2      	str	r2, [r0, r3]
    39b0:	3304      	adds	r3, #4
    39b2:	2203      	movs	r2, #3
    39b4:	e737      	b.n	3826 <usb_request_hook_cb+0x46>
    39b6:	46c0      	nop			; (mov r8, r8)
    39b8:	00000681 	.word	0x00000681
    39bc:	00008238 	.word	0x00008238
    39c0:	20000be8 	.word	0x20000be8
    39c4:	20000b54 	.word	0x20000b54
    39c8:	20000c10 	.word	0x20000c10
    39cc:	20000bec 	.word	0x20000bec
    39d0:	20000bb8 	.word	0x20000bb8
    39d4:	1ffffe00 	.word	0x1ffffe00
    39d8:	1ffffe31 	.word	0x1ffffe31
    39dc:	20000bd0 	.word	0x20000bd0
    39e0:	000003e7 	.word	0x000003e7
    39e4:	20000bd4 	.word	0x20000bd4
    39e8:	000036b1 	.word	0x000036b1
    39ec:	00000000 	.word	0x00000000

000039f0 <hook_usb_wakeup>:
void hook_usb_wakeup(void) {
    39f0:	b510      	push	{r4, lr}
    sleep_led_disable();
    39f2:	f003 ff6d 	bl	78d0 <sleep_led_disable>
    led_set(host_keyboard_leds());
    39f6:	f000 fcd3 	bl	43a0 <host_keyboard_leds>
    39fa:	f000 fcb1 	bl	4360 <led_set>
}
    39fe:	bd10      	pop	{r4, pc}

00003a00 <hook_usb_suspend_entry>:
void hook_usb_suspend_entry(void) {
    3a00:	b510      	push	{r4, lr}
    sleep_led_enable();
    3a02:	f003 ff5d 	bl	78c0 <sleep_led_enable>
}
    3a06:	bd10      	pop	{r4, pc}
	...

00003a10 <usb_event_cb>:
static void usb_event_cb(USBDriver *usbp, usbevent_t event) {
    3a10:	b510      	push	{r4, lr}
    3a12:	0004      	movs	r4, r0
  switch(event) {
    3a14:	2904      	cmp	r1, #4
    3a16:	d029      	beq.n	3a6c <usb_event_cb+0x5c>
    3a18:	2905      	cmp	r1, #5
    3a1a:	d022      	beq.n	3a62 <usb_event_cb+0x52>
    3a1c:	2902      	cmp	r1, #2
    3a1e:	d000      	beq.n	3a22 <usb_event_cb+0x12>
}
    3a20:	bd10      	pop	{r4, pc}
    3a22:	b672      	cpsid	i
    3a24:	f7fd fb0c 	bl	1040 <_dbg_check_lock_from_isr>
    usbInitEndpointI(usbp, KBD_ENDPOINT, &kbd_ep_config);
    3a28:	0020      	movs	r0, r4
    3a2a:	4a12      	ldr	r2, [pc, #72]	; (3a74 <usb_event_cb+0x64>)
    3a2c:	2101      	movs	r1, #1
    3a2e:	f7fe fbef 	bl	2210 <usbInitEndpointI>
    usbInitEndpointI(usbp, MOUSE_ENDPOINT, &mouse_ep_config);
    3a32:	0020      	movs	r0, r4
    3a34:	4a10      	ldr	r2, [pc, #64]	; (3a78 <usb_event_cb+0x68>)
    3a36:	2102      	movs	r1, #2
    3a38:	f7fe fbea 	bl	2210 <usbInitEndpointI>
    usbInitEndpointI(usbp, CONSOLE_ENDPOINT, &console_ep_config);
    3a3c:	0020      	movs	r0, r4
    3a3e:	4a0f      	ldr	r2, [pc, #60]	; (3a7c <usb_event_cb+0x6c>)
    3a40:	2103      	movs	r1, #3
    3a42:	f7fe fbe5 	bl	2210 <usbInitEndpointI>
    usbInitEndpointI(usbp, EXTRA_ENDPOINT, &extra_ep_config);
    3a46:	0020      	movs	r0, r4
    3a48:	4a0d      	ldr	r2, [pc, #52]	; (3a80 <usb_event_cb+0x70>)
    3a4a:	2104      	movs	r1, #4
    3a4c:	f7fe fbe0 	bl	2210 <usbInitEndpointI>
    usbInitEndpointI(usbp, NKRO_ENDPOINT, &nkro_ep_config);
    3a50:	4a0c      	ldr	r2, [pc, #48]	; (3a84 <usb_event_cb+0x74>)
    3a52:	2105      	movs	r1, #5
    3a54:	0020      	movs	r0, r4
    3a56:	f7fe fbdb 	bl	2210 <usbInitEndpointI>
  _dbg_check_unlock_from_isr();
    3a5a:	f7fd fb09 	bl	1070 <_dbg_check_unlock_from_isr>
  __ASM volatile ("cpsie i" : : : "memory");
    3a5e:	b662      	cpsie	i
    3a60:	e7de      	b.n	3a20 <usb_event_cb+0x10>
    suspend_wakeup_init();
    3a62:	f002 f975 	bl	5d50 <suspend_wakeup_init>
    hook_usb_wakeup();
    3a66:	f7ff ffc3 	bl	39f0 <hook_usb_wakeup>
    return;
    3a6a:	e7d9      	b.n	3a20 <usb_event_cb+0x10>
    hook_usb_suspend_entry();
    3a6c:	f7ff ffc8 	bl	3a00 <hook_usb_suspend_entry>
    return;
    3a70:	e7d6      	b.n	3a20 <usb_event_cb+0x10>
    3a72:	46c0      	nop			; (mov r8, r8)
    3a74:	000083b0 	.word	0x000083b0
    3a78:	00008424 	.word	0x00008424
    3a7c:	0000826c 	.word	0x0000826c
    3a80:	000082b8 	.word	0x000082b8
    3a84:	000084ac 	.word	0x000084ac
	...

00003a90 <init_usb_driver>:
void init_usb_driver(USBDriver *usbp) {
    3a90:	b530      	push	{r4, r5, lr}
  usbDisconnectBus(usbp);
    3a92:	4a17      	ldr	r2, [pc, #92]	; (3af0 <init_usb_driver+0x60>)
    3a94:	4b17      	ldr	r3, [pc, #92]	; (3af4 <init_usb_driver+0x64>)
void init_usb_driver(USBDriver *usbp) {
    3a96:	b085      	sub	sp, #20
  usbDisconnectBus(usbp);
    3a98:	58d3      	ldr	r3, [r2, r3]
void init_usb_driver(USBDriver *usbp) {
    3a9a:	0005      	movs	r5, r0
  usbDisconnectBus(usbp);
    3a9c:	035b      	lsls	r3, r3, #13
    3a9e:	d506      	bpl.n	3aae <init_usb_driver+0x1e>
    3aa0:	2284      	movs	r2, #132	; 0x84
    3aa2:	2010      	movs	r0, #16
    3aa4:	4914      	ldr	r1, [pc, #80]	; (3af8 <init_usb_driver+0x68>)
    3aa6:	0052      	lsls	r2, r2, #1
    3aa8:	5c8b      	ldrb	r3, [r1, r2]
    3aaa:	4383      	bics	r3, r0
    3aac:	548b      	strb	r3, [r1, r2]
  chThdSleepMilliseconds(1500);
    3aae:	4813      	ldr	r0, [pc, #76]	; (3afc <init_usb_driver+0x6c>)
    3ab0:	f7fd fe9e 	bl	17f0 <chThdSleep>
  usbStart(usbp, &usbcfg);
    3ab4:	0028      	movs	r0, r5
    3ab6:	4912      	ldr	r1, [pc, #72]	; (3b00 <init_usb_driver+0x70>)
    3ab8:	f7fe fb6a 	bl	2190 <usbStart>
  usbConnectBus(usbp);
    3abc:	2284      	movs	r2, #132	; 0x84
    3abe:	2010      	movs	r0, #16
  vtp->func = NULL;
    3ac0:	2400      	movs	r4, #0
    3ac2:	490d      	ldr	r1, [pc, #52]	; (3af8 <init_usb_driver+0x68>)
    3ac4:	0052      	lsls	r2, r2, #1
    3ac6:	5c8b      	ldrb	r3, [r1, r2]
    3ac8:	4303      	orrs	r3, r0
    3aca:	548b      	strb	r3, [r1, r2]
    3acc:	4b0d      	ldr	r3, [pc, #52]	; (3b04 <init_usb_driver+0x74>)
  obqObjectInit(&console_buf_queue, true, console_queue_buffer, CONSOLE_EPSIZE, CONSOLE_QUEUE_CAPACITY, console_queue_onotify, (void*)usbp);
    3ace:	4a0e      	ldr	r2, [pc, #56]	; (3b08 <init_usb_driver+0x78>)
    3ad0:	60dc      	str	r4, [r3, #12]
    3ad2:	4b0e      	ldr	r3, [pc, #56]	; (3b0c <init_usb_driver+0x7c>)
    3ad4:	9502      	str	r5, [sp, #8]
    3ad6:	9301      	str	r3, [sp, #4]
    3ad8:	2304      	movs	r3, #4
    3ada:	2101      	movs	r1, #1
    3adc:	9300      	str	r3, [sp, #0]
    3ade:	480c      	ldr	r0, [pc, #48]	; (3b10 <init_usb_driver+0x80>)
    3ae0:	330c      	adds	r3, #12
    3ae2:	f7fe f9ed 	bl	1ec0 <obqObjectInit>
    3ae6:	4b0b      	ldr	r3, [pc, #44]	; (3b14 <init_usb_driver+0x84>)
    3ae8:	60dc      	str	r4, [r3, #12]
}
    3aea:	b005      	add	sp, #20
    3aec:	bd30      	pop	{r4, r5, pc}
    3aee:	46c0      	nop			; (mov r8, r8)
    3af0:	40047000 	.word	0x40047000
    3af4:	00001034 	.word	0x00001034
    3af8:	40072000 	.word	0x40072000
    3afc:	000005dc 	.word	0x000005dc
    3b00:	0000858c 	.word	0x0000858c
    3b04:	20000bd4 	.word	0x20000bd4
    3b08:	20000b54 	.word	0x20000b54
    3b0c:	000035c1 	.word	0x000035c1
    3b10:	20000af4 	.word	0x20000af4
    3b14:	20000b40 	.word	0x20000b40
	...

00003b20 <send_remote_wakeup>:
void send_remote_wakeup(USBDriver *usbp) {
    3b20:	b570      	push	{r4, r5, r6, lr}
  USB0->CTL |= USBx_CTL_RESUME;
    3b22:	2494      	movs	r4, #148	; 0x94
    3b24:	2204      	movs	r2, #4
    3b26:	4d06      	ldr	r5, [pc, #24]	; (3b40 <send_remote_wakeup+0x20>)
  chThdSleepMilliseconds(15);
    3b28:	200f      	movs	r0, #15
  USB0->CTL |= USBx_CTL_RESUME;
    3b2a:	5d2b      	ldrb	r3, [r5, r4]
    3b2c:	4313      	orrs	r3, r2
    3b2e:	552b      	strb	r3, [r5, r4]
  chThdSleepMilliseconds(15);
    3b30:	f7fd fe5e 	bl	17f0 <chThdSleep>
  USB0->CTL &= ~USBx_CTL_RESUME;
    3b34:	2204      	movs	r2, #4
    3b36:	5d2b      	ldrb	r3, [r5, r4]
    3b38:	4393      	bics	r3, r2
    3b3a:	552b      	strb	r3, [r5, r4]
}
    3b3c:	bd70      	pop	{r4, r5, r6, pc}
    3b3e:	46c0      	nop			; (mov r8, r8)
    3b40:	40072000 	.word	0x40072000
	...

00003b50 <keyboard_leds>:
  return (uint8_t)(keyboard_led_stats & 0xFF);
    3b50:	4b01      	ldr	r3, [pc, #4]	; (3b58 <keyboard_leds+0x8>)
    3b52:	7818      	ldrb	r0, [r3, #0]
}
    3b54:	4770      	bx	lr
    3b56:	46c0      	nop			; (mov r8, r8)
    3b58:	20000be8 	.word	0x20000be8
    3b5c:	00000000 	.word	0x00000000

00003b60 <send_keyboard>:
void send_keyboard(report_keyboard_t *report) {
    3b60:	b570      	push	{r4, r5, r6, lr}
    3b62:	0006      	movs	r6, r0
  __ASM volatile ("cpsid i" : : : "memory");
    3b64:	b672      	cpsid	i
  _dbg_check_lock();
    3b66:	f7fd fa3b 	bl	fe0 <_dbg_check_lock>
  if(usbGetDriverStateI(&USB_DRIVER) != USB_ACTIVE) {
    3b6a:	4c32      	ldr	r4, [pc, #200]	; (3c34 <send_keyboard+0xd4>)
    3b6c:	7823      	ldrb	r3, [r4, #0]
    3b6e:	2b04      	cmp	r3, #4
    3b70:	d00c      	beq.n	3b8c <send_keyboard+0x2c>
  _dbg_check_unlock();
    3b72:	f7fd fa4d 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3b76:	4b30      	ldr	r3, [pc, #192]	; (3c38 <send_keyboard+0xd8>)
    3b78:	681a      	ldr	r2, [r3, #0]
    3b7a:	429a      	cmp	r2, r3
    3b7c:	d004      	beq.n	3b88 <send_keyboard+0x28>
    3b7e:	699b      	ldr	r3, [r3, #24]
    3b80:	6899      	ldr	r1, [r3, #8]
    3b82:	6893      	ldr	r3, [r2, #8]
    3b84:	4299      	cmp	r1, r3
    3b86:	d33b      	bcc.n	3c00 <send_keyboard+0xa0>
  __ASM volatile ("cpsie i" : : : "memory");
    3b88:	b662      	cpsie	i
}
    3b8a:	bd70      	pop	{r4, r5, r6, pc}
  _dbg_check_unlock();
    3b8c:	f7fd fa40 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3b90:	4d29      	ldr	r5, [pc, #164]	; (3c38 <send_keyboard+0xd8>)
    3b92:	682b      	ldr	r3, [r5, #0]
    3b94:	42ab      	cmp	r3, r5
    3b96:	d004      	beq.n	3ba2 <send_keyboard+0x42>
    3b98:	69aa      	ldr	r2, [r5, #24]
    3b9a:	689b      	ldr	r3, [r3, #8]
    3b9c:	6892      	ldr	r2, [r2, #8]
    3b9e:	429a      	cmp	r2, r3
    3ba0:	d332      	bcc.n	3c08 <send_keyboard+0xa8>
    3ba2:	b662      	cpsie	i
  if(keyboard_nkro) {  /* NKRO protocol */
    3ba4:	4b25      	ldr	r3, [pc, #148]	; (3c3c <send_keyboard+0xdc>)
    3ba6:	781b      	ldrb	r3, [r3, #0]
    3ba8:	2b00      	cmp	r3, #0
    3baa:	d11f      	bne.n	3bec <send_keyboard+0x8c>
  __ASM volatile ("cpsid i" : : : "memory");
    3bac:	b672      	cpsid	i
  _dbg_check_lock();
    3bae:	f7fd fa17 	bl	fe0 <_dbg_check_lock>
    if(usbGetTransmitStatusI(&USB_DRIVER, KBD_ENDPOINT)) {
    3bb2:	8923      	ldrh	r3, [r4, #8]
    3bb4:	079b      	lsls	r3, r3, #30
    3bb6:	d430      	bmi.n	3c1a <send_keyboard+0xba>
    usbStartTransmitI(&USB_DRIVER, KBD_ENDPOINT, (uint8_t *)report, KBD_EPSIZE);
    3bb8:	2308      	movs	r3, #8
    3bba:	0032      	movs	r2, r6
    3bbc:	2101      	movs	r1, #1
    3bbe:	0020      	movs	r0, r4
    3bc0:	f7fe fbd6 	bl	2370 <usbStartTransmitI>
  _dbg_check_unlock();
    3bc4:	f7fd fa24 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3bc8:	682b      	ldr	r3, [r5, #0]
    3bca:	42ab      	cmp	r3, r5
    3bcc:	d007      	beq.n	3bde <send_keyboard+0x7e>
    3bce:	69aa      	ldr	r2, [r5, #24]
    3bd0:	689b      	ldr	r3, [r3, #8]
    3bd2:	6892      	ldr	r2, [r2, #8]
    3bd4:	429a      	cmp	r2, r3
    3bd6:	d202      	bcs.n	3bde <send_keyboard+0x7e>
    3bd8:	4819      	ldr	r0, [pc, #100]	; (3c40 <send_keyboard+0xe0>)
    3bda:	f7fd f9b1 	bl	f40 <chSysHalt>
  __ASM volatile ("cpsie i" : : : "memory");
    3bde:	b662      	cpsie	i
  keyboard_report_sent = *report;
    3be0:	2210      	movs	r2, #16
    3be2:	0031      	movs	r1, r6
    3be4:	4817      	ldr	r0, [pc, #92]	; (3c44 <send_keyboard+0xe4>)
    3be6:	f003 fe7b 	bl	78e0 <memcpy>
    3bea:	e7ce      	b.n	3b8a <send_keyboard+0x2a>
  __ASM volatile ("cpsid i" : : : "memory");
    3bec:	b672      	cpsid	i
  _dbg_check_lock();
    3bee:	f7fd f9f7 	bl	fe0 <_dbg_check_lock>
    if(usbGetTransmitStatusI(&USB_DRIVER, NKRO_ENDPOINT)) {
    3bf2:	8923      	ldrh	r3, [r4, #8]
    3bf4:	069b      	lsls	r3, r3, #26
    3bf6:	d416      	bmi.n	3c26 <send_keyboard+0xc6>
    usbStartTransmitI(&USB_DRIVER, NKRO_ENDPOINT, (uint8_t *)report, sizeof(report_keyboard_t));
    3bf8:	2310      	movs	r3, #16
    3bfa:	0032      	movs	r2, r6
    3bfc:	2105      	movs	r1, #5
    3bfe:	e7de      	b.n	3bbe <send_keyboard+0x5e>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3c00:	480f      	ldr	r0, [pc, #60]	; (3c40 <send_keyboard+0xe0>)
    3c02:	f7fd f99d 	bl	f40 <chSysHalt>
    3c06:	e7bf      	b.n	3b88 <send_keyboard+0x28>
    3c08:	480d      	ldr	r0, [pc, #52]	; (3c40 <send_keyboard+0xe0>)
    3c0a:	f7fd f999 	bl	f40 <chSysHalt>
  __ASM volatile ("cpsie i" : : : "memory");
    3c0e:	b662      	cpsie	i
  if(keyboard_nkro) {  /* NKRO protocol */
    3c10:	4b0a      	ldr	r3, [pc, #40]	; (3c3c <send_keyboard+0xdc>)
    3c12:	781b      	ldrb	r3, [r3, #0]
    3c14:	2b00      	cmp	r3, #0
    3c16:	d0c9      	beq.n	3bac <send_keyboard+0x4c>
    3c18:	e7e8      	b.n	3bec <send_keyboard+0x8c>
      osalThreadSuspendS(&(&USB_DRIVER)->epc[KBD_ENDPOINT]->in_state->thread);
    3c1a:	6923      	ldr	r3, [r4, #16]
    3c1c:	6958      	ldr	r0, [r3, #20]
    3c1e:	300c      	adds	r0, #12
  return chThdSuspendS(trp);
    3c20:	f7fd fe0e 	bl	1840 <chThdSuspendS>
    3c24:	e7c8      	b.n	3bb8 <send_keyboard+0x58>
      osalThreadSuspendS(&(&USB_DRIVER)->epc[NKRO_ENDPOINT]->in_state->thread);
    3c26:	6a23      	ldr	r3, [r4, #32]
    3c28:	6958      	ldr	r0, [r3, #20]
    3c2a:	300c      	adds	r0, #12
    3c2c:	f7fd fe08 	bl	1840 <chThdSuspendS>
    3c30:	e7e2      	b.n	3bf8 <send_keyboard+0x98>
    3c32:	46c0      	nop			; (mov r8, r8)
    3c34:	20000180 	.word	0x20000180
    3c38:	200000d8 	.word	0x200000d8
    3c3c:	1ffffe31 	.word	0x1ffffe31
    3c40:	0000824c 	.word	0x0000824c
    3c44:	20000bec 	.word	0x20000bec
	...

00003c50 <send_mouse>:
void send_mouse(report_mouse_t *report) {
    3c50:	b570      	push	{r4, r5, r6, lr}
    3c52:	0006      	movs	r6, r0
  __ASM volatile ("cpsid i" : : : "memory");
    3c54:	b672      	cpsid	i
  _dbg_check_lock();
    3c56:	f7fd f9c3 	bl	fe0 <_dbg_check_lock>
  if(usbGetDriverStateI(&USB_DRIVER) != USB_ACTIVE) {
    3c5a:	4d1b      	ldr	r5, [pc, #108]	; (3cc8 <send_mouse+0x78>)
    3c5c:	782b      	ldrb	r3, [r5, #0]
    3c5e:	2b04      	cmp	r3, #4
    3c60:	d00c      	beq.n	3c7c <send_mouse+0x2c>
  _dbg_check_unlock();
    3c62:	f7fd f9d5 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3c66:	4b19      	ldr	r3, [pc, #100]	; (3ccc <send_mouse+0x7c>)
    3c68:	681a      	ldr	r2, [r3, #0]
    3c6a:	429a      	cmp	r2, r3
    3c6c:	d004      	beq.n	3c78 <send_mouse+0x28>
    3c6e:	699b      	ldr	r3, [r3, #24]
    3c70:	6899      	ldr	r1, [r3, #8]
    3c72:	6893      	ldr	r3, [r2, #8]
    3c74:	4299      	cmp	r1, r3
    3c76:	d323      	bcc.n	3cc0 <send_mouse+0x70>
  __ASM volatile ("cpsie i" : : : "memory");
    3c78:	b662      	cpsie	i
}
    3c7a:	bd70      	pop	{r4, r5, r6, pc}
  _dbg_check_unlock();
    3c7c:	f7fd f9c8 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3c80:	4c12      	ldr	r4, [pc, #72]	; (3ccc <send_mouse+0x7c>)
    3c82:	6823      	ldr	r3, [r4, #0]
    3c84:	42a3      	cmp	r3, r4
    3c86:	d007      	beq.n	3c98 <send_mouse+0x48>
    3c88:	69a2      	ldr	r2, [r4, #24]
    3c8a:	689b      	ldr	r3, [r3, #8]
    3c8c:	6892      	ldr	r2, [r2, #8]
    3c8e:	429a      	cmp	r2, r3
    3c90:	d202      	bcs.n	3c98 <send_mouse+0x48>
    3c92:	480f      	ldr	r0, [pc, #60]	; (3cd0 <send_mouse+0x80>)
    3c94:	f7fd f954 	bl	f40 <chSysHalt>
    3c98:	b662      	cpsie	i
  __ASM volatile ("cpsid i" : : : "memory");
    3c9a:	b672      	cpsid	i
  _dbg_check_lock();
    3c9c:	f7fd f9a0 	bl	fe0 <_dbg_check_lock>
  usbStartTransmitI(&USB_DRIVER, MOUSE_ENDPOINT, (uint8_t *)report, sizeof(report_mouse_t));
    3ca0:	2305      	movs	r3, #5
    3ca2:	0032      	movs	r2, r6
    3ca4:	2102      	movs	r1, #2
    3ca6:	0028      	movs	r0, r5
    3ca8:	f7fe fb62 	bl	2370 <usbStartTransmitI>
  _dbg_check_unlock();
    3cac:	f7fd f9b0 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3cb0:	6823      	ldr	r3, [r4, #0]
    3cb2:	42a3      	cmp	r3, r4
    3cb4:	d0e0      	beq.n	3c78 <send_mouse+0x28>
    3cb6:	69a2      	ldr	r2, [r4, #24]
    3cb8:	689b      	ldr	r3, [r3, #8]
    3cba:	6892      	ldr	r2, [r2, #8]
    3cbc:	429a      	cmp	r2, r3
    3cbe:	d2db      	bcs.n	3c78 <send_mouse+0x28>
    3cc0:	4803      	ldr	r0, [pc, #12]	; (3cd0 <send_mouse+0x80>)
    3cc2:	f7fd f93d 	bl	f40 <chSysHalt>
    3cc6:	e7d7      	b.n	3c78 <send_mouse+0x28>
    3cc8:	20000180 	.word	0x20000180
    3ccc:	200000d8 	.word	0x200000d8
    3cd0:	0000824c 	.word	0x0000824c
	...

00003ce0 <send_system>:
void send_system(uint16_t data) {
    3ce0:	b510      	push	{r4, lr}
    3ce2:	0004      	movs	r4, r0
    3ce4:	b082      	sub	sp, #8
    3ce6:	b672      	cpsid	i
  _dbg_check_lock();
    3ce8:	f7fd f97a 	bl	fe0 <_dbg_check_lock>
  if(usbGetDriverStateI(&USB_DRIVER) != USB_ACTIVE) {
    3cec:	4810      	ldr	r0, [pc, #64]	; (3d30 <send_system+0x50>)
    3cee:	7803      	ldrb	r3, [r0, #0]
    3cf0:	2b04      	cmp	r3, #4
    3cf2:	d10a      	bne.n	3d0a <send_system+0x2a>
  report_extra_t report = {
    3cf4:	2302      	movs	r3, #2
    3cf6:	aa01      	add	r2, sp, #4
    3cf8:	7013      	strb	r3, [r2, #0]
    3cfa:	466b      	mov	r3, sp
    3cfc:	715c      	strb	r4, [r3, #5]
    3cfe:	0a24      	lsrs	r4, r4, #8
    3d00:	719c      	strb	r4, [r3, #6]
  usbStartTransmitI(&USB_DRIVER, EXTRA_ENDPOINT, (uint8_t *)&report, sizeof(report_extra_t));
    3d02:	2104      	movs	r1, #4
    3d04:	2303      	movs	r3, #3
    3d06:	f7fe fb33 	bl	2370 <usbStartTransmitI>
  _dbg_check_unlock();
    3d0a:	f7fd f981 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3d0e:	4b09      	ldr	r3, [pc, #36]	; (3d34 <send_system+0x54>)
    3d10:	681a      	ldr	r2, [r3, #0]
    3d12:	429a      	cmp	r2, r3
    3d14:	d004      	beq.n	3d20 <send_system+0x40>
    3d16:	699b      	ldr	r3, [r3, #24]
    3d18:	6899      	ldr	r1, [r3, #8]
    3d1a:	6893      	ldr	r3, [r2, #8]
    3d1c:	4299      	cmp	r1, r3
    3d1e:	d302      	bcc.n	3d26 <send_system+0x46>
  __ASM volatile ("cpsie i" : : : "memory");
    3d20:	b662      	cpsie	i
}
    3d22:	b002      	add	sp, #8
    3d24:	bd10      	pop	{r4, pc}
    3d26:	4804      	ldr	r0, [pc, #16]	; (3d38 <send_system+0x58>)
    3d28:	f7fd f90a 	bl	f40 <chSysHalt>
    3d2c:	e7f8      	b.n	3d20 <send_system+0x40>
    3d2e:	46c0      	nop			; (mov r8, r8)
    3d30:	20000180 	.word	0x20000180
    3d34:	200000d8 	.word	0x200000d8
    3d38:	0000824c 	.word	0x0000824c
    3d3c:	00000000 	.word	0x00000000

00003d40 <send_consumer>:
void send_consumer(uint16_t data) {
    3d40:	b510      	push	{r4, lr}
    3d42:	0004      	movs	r4, r0
    3d44:	b082      	sub	sp, #8
  __ASM volatile ("cpsid i" : : : "memory");
    3d46:	b672      	cpsid	i
  _dbg_check_lock();
    3d48:	f7fd f94a 	bl	fe0 <_dbg_check_lock>
  if(usbGetDriverStateI(&USB_DRIVER) != USB_ACTIVE) {
    3d4c:	4810      	ldr	r0, [pc, #64]	; (3d90 <send_consumer+0x50>)
    3d4e:	7803      	ldrb	r3, [r0, #0]
    3d50:	2b04      	cmp	r3, #4
    3d52:	d10a      	bne.n	3d6a <send_consumer+0x2a>
  report_extra_t report = {
    3d54:	2303      	movs	r3, #3
    3d56:	aa01      	add	r2, sp, #4
    3d58:	7013      	strb	r3, [r2, #0]
    3d5a:	466b      	mov	r3, sp
    3d5c:	715c      	strb	r4, [r3, #5]
    3d5e:	0a24      	lsrs	r4, r4, #8
    3d60:	719c      	strb	r4, [r3, #6]
  usbStartTransmitI(&USB_DRIVER, EXTRA_ENDPOINT, (uint8_t *)&report, sizeof(report_extra_t));
    3d62:	2104      	movs	r1, #4
    3d64:	2303      	movs	r3, #3
    3d66:	f7fe fb03 	bl	2370 <usbStartTransmitI>
  _dbg_check_unlock();
    3d6a:	f7fd f951 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3d6e:	4b09      	ldr	r3, [pc, #36]	; (3d94 <send_consumer+0x54>)
    3d70:	681a      	ldr	r2, [r3, #0]
    3d72:	429a      	cmp	r2, r3
    3d74:	d004      	beq.n	3d80 <send_consumer+0x40>
    3d76:	699b      	ldr	r3, [r3, #24]
    3d78:	6899      	ldr	r1, [r3, #8]
    3d7a:	6893      	ldr	r3, [r2, #8]
    3d7c:	4299      	cmp	r1, r3
    3d7e:	d302      	bcc.n	3d86 <send_consumer+0x46>
  __ASM volatile ("cpsie i" : : : "memory");
    3d80:	b662      	cpsie	i
}
    3d82:	b002      	add	sp, #8
    3d84:	bd10      	pop	{r4, pc}
    3d86:	4804      	ldr	r0, [pc, #16]	; (3d98 <send_consumer+0x58>)
    3d88:	f7fd f8da 	bl	f40 <chSysHalt>
    3d8c:	e7f8      	b.n	3d80 <send_consumer+0x40>
    3d8e:	46c0      	nop			; (mov r8, r8)
    3d90:	20000180 	.word	0x20000180
    3d94:	200000d8 	.word	0x200000d8
    3d98:	0000824c 	.word	0x0000824c
    3d9c:	00000000 	.word	0x00000000

00003da0 <sendchar>:


int8_t sendchar(uint8_t c) {
    3da0:	b510      	push	{r4, lr}
    3da2:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
    3da4:	b672      	cpsid	i
  _dbg_check_lock();
    3da6:	f7fd f91b 	bl	fe0 <_dbg_check_lock>
  osalSysLock();
  if(usbGetDriverStateI(&USB_DRIVER) != USB_ACTIVE) {
    3daa:	4b1a      	ldr	r3, [pc, #104]	; (3e14 <sendchar+0x74>)
    3dac:	781b      	ldrb	r3, [r3, #0]
    3dae:	2b04      	cmp	r3, #4
    3db0:	d00d      	beq.n	3dce <sendchar+0x2e>
  _dbg_check_unlock();
    3db2:	f7fd f92d 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3db6:	4b18      	ldr	r3, [pc, #96]	; (3e18 <sendchar+0x78>)
    3db8:	681a      	ldr	r2, [r3, #0]
    3dba:	429a      	cmp	r2, r3
    3dbc:	d004      	beq.n	3dc8 <sendchar+0x28>
    3dbe:	699b      	ldr	r3, [r3, #24]
    3dc0:	6899      	ldr	r1, [r3, #8]
    3dc2:	6893      	ldr	r3, [r2, #8]
    3dc4:	4299      	cmp	r1, r3
    3dc6:	d315      	bcc.n	3df4 <sendchar+0x54>
  __ASM volatile ("cpsie i" : : : "memory");
    3dc8:	b662      	cpsie	i
    osalSysUnlock();
    return 0;
    3dca:	2000      	movs	r0, #0
   * dropped (i.e. the buffer is getting full too fast
   * for USB/HIDRAW to dequeue). Another possibility
   * for fixing this kind of thing is to increase
   * CONSOLE_QUEUE_CAPACITY. */
  return(obqPutTimeout(&console_buf_queue, c, US2ST(100)));
}
    3dcc:	bd10      	pop	{r4, pc}
  _dbg_check_unlock();
    3dce:	f7fd f91f 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    3dd2:	4b11      	ldr	r3, [pc, #68]	; (3e18 <sendchar+0x78>)
    3dd4:	681a      	ldr	r2, [r3, #0]
    3dd6:	429a      	cmp	r2, r3
    3dd8:	d004      	beq.n	3de4 <sendchar+0x44>
    3dda:	699b      	ldr	r3, [r3, #24]
    3ddc:	6899      	ldr	r1, [r3, #8]
    3dde:	6893      	ldr	r3, [r2, #8]
    3de0:	4299      	cmp	r1, r3
    3de2:	d30b      	bcc.n	3dfc <sendchar+0x5c>
    3de4:	b662      	cpsie	i
  return(obqPutTimeout(&console_buf_queue, c, US2ST(100)));
    3de6:	2201      	movs	r2, #1
    3de8:	0021      	movs	r1, r4
    3dea:	480c      	ldr	r0, [pc, #48]	; (3e1c <sendchar+0x7c>)
    3dec:	f7fe f930 	bl	2050 <obqPutTimeout>
    3df0:	b240      	sxtb	r0, r0
    3df2:	e7eb      	b.n	3dcc <sendchar+0x2c>
    3df4:	480a      	ldr	r0, [pc, #40]	; (3e20 <sendchar+0x80>)
    3df6:	f7fd f8a3 	bl	f40 <chSysHalt>
    3dfa:	e7e5      	b.n	3dc8 <sendchar+0x28>
    3dfc:	4808      	ldr	r0, [pc, #32]	; (3e20 <sendchar+0x80>)
    3dfe:	f7fd f89f 	bl	f40 <chSysHalt>
    3e02:	b662      	cpsie	i
    3e04:	2201      	movs	r2, #1
    3e06:	0021      	movs	r1, r4
    3e08:	4804      	ldr	r0, [pc, #16]	; (3e1c <sendchar+0x7c>)
    3e0a:	f7fe f921 	bl	2050 <obqPutTimeout>
    3e0e:	b240      	sxtb	r0, r0
    3e10:	e7dc      	b.n	3dcc <sendchar+0x2c>
    3e12:	46c0      	nop			; (mov r8, r8)
    3e14:	20000180 	.word	0x20000180
    3e18:	200000d8 	.word	0x200000d8
    3e1c:	20000af4 	.word	0x20000af4
    3e20:	0000824c 	.word	0x0000824c
	...

00003e30 <sendchar_pf>:
  (void)c;
  return 0;
}
#endif /* CONSOLE_ENABLE */

void sendchar_pf(void *p, char c) {
    3e30:	b510      	push	{r4, lr}
  (void)p;
  sendchar((uint8_t)c);
    3e32:	0008      	movs	r0, r1
    3e34:	f7ff ffb4 	bl	3da0 <sendchar>
}
    3e38:	bd10      	pop	{r4, pc}
    3e3a:	46c0      	nop			; (mov r8, r8)
    3e3c:	0000      	movs	r0, r0
	...

00003e40 <hook_early_init>:
  send_consumer
};

/* Default hooks definitions. */
__attribute__((weak))
void hook_early_init(void) {}
    3e40:	4770      	bx	lr
    3e42:	46c0      	nop			; (mov r8, r8)
	...

00003e50 <hook_late_init>:
    3e50:	4770      	bx	lr
    3e52:	46c0      	nop			; (mov r8, r8)
	...

00003e60 <hook_usb_suspend_loop>:

__attribute__((weak))
void hook_late_init(void) {}

__attribute__((weak))
void hook_usb_suspend_loop(void) {
    3e60:	b510      	push	{r4, lr}
  /* Do this in the suspended state */
  suspend_power_down(); // on AVR this deep sleeps for 15ms
    3e62:	f001 ff45 	bl	5cf0 <suspend_power_down>
  /* Remote wakeup */
  if((USB_DRIVER.status & 2) && suspend_wakeup_condition()) {
    3e66:	23dc      	movs	r3, #220	; 0xdc
    3e68:	4c06      	ldr	r4, [pc, #24]	; (3e84 <hook_usb_suspend_loop+0x24>)
    3e6a:	5ae3      	ldrh	r3, [r4, r3]
    3e6c:	079b      	lsls	r3, r3, #30
    3e6e:	d400      	bmi.n	3e72 <hook_usb_suspend_loop+0x12>
    send_remote_wakeup(&USB_DRIVER);
  }
}
    3e70:	bd10      	pop	{r4, pc}
  if((USB_DRIVER.status & 2) && suspend_wakeup_condition()) {
    3e72:	f001 ff55 	bl	5d20 <suspend_wakeup_condition>
    3e76:	2800      	cmp	r0, #0
    3e78:	d0fa      	beq.n	3e70 <hook_usb_suspend_loop+0x10>
    send_remote_wakeup(&USB_DRIVER);
    3e7a:	0020      	movs	r0, r4
    3e7c:	f7ff fe50 	bl	3b20 <send_remote_wakeup>
}
    3e80:	e7f6      	b.n	3e70 <hook_usb_suspend_loop+0x10>
    3e82:	46c0      	nop			; (mov r8, r8)
    3e84:	20000180 	.word	0x20000180
	...

00003e90 <main>:



/* Main thread
 */
int main(void) {
    3e90:	b570      	push	{r4, r5, r6, lr}
  /* ChibiOS/RT init */
  halInit();
    3e92:	f7fd fffd 	bl	1e90 <halInit>
  chSysInit();
    3e96:	f7fd f81b 	bl	ed0 <chSysInit>

  // TESTING
  // chThdCreateStatic(waBlinkerThread, sizeof(waBlinkerThread), NORMALPRIO, blinkerThread, NULL);

  hook_early_init();
    3e9a:	f7ff ffd1 	bl	3e40 <hook_early_init>

  /* Init USB */
  init_usb_driver(&USB_DRIVER);
    3e9e:	4c1d      	ldr	r4, [pc, #116]	; (3f14 <main+0x84>)
    3ea0:	0020      	movs	r0, r4
    3ea2:	f7ff fdf5 	bl	3a90 <init_usb_driver>

  /* init printf */
  init_printf(NULL,sendchar_pf);
    3ea6:	491c      	ldr	r1, [pc, #112]	; (3f18 <main+0x88>)
    3ea8:	2000      	movs	r0, #0
    3eaa:	f002 f961 	bl	6170 <init_printf>

  /* Wait until the USB is active */
  while(USB_DRIVER.state != USB_ACTIVE)
    3eae:	7823      	ldrb	r3, [r4, #0]
    3eb0:	2b04      	cmp	r3, #4
    3eb2:	d005      	beq.n	3ec0 <main+0x30>
    chThdSleepMilliseconds(50);
    3eb4:	2032      	movs	r0, #50	; 0x32
    3eb6:	f7fd fc9b 	bl	17f0 <chThdSleep>
  while(USB_DRIVER.state != USB_ACTIVE)
    3eba:	7823      	ldrb	r3, [r4, #0]
    3ebc:	2b04      	cmp	r3, #4
    3ebe:	d1f9      	bne.n	3eb4 <main+0x24>
  /* Do need to wait here!
   * Otherwise the next print might start a transfer on console EP
   * before the USB is completely ready, which sometimes causes
   * HardFaults.
   */
  chThdSleepMilliseconds(50);
    3ec0:	2032      	movs	r0, #50	; 0x32
    3ec2:	f7fd fc95 	bl	17f0 <chThdSleep>

  print("USB configured.\n");
    3ec6:	4815      	ldr	r0, [pc, #84]	; (3f1c <main+0x8c>)
    3ec8:	f002 f962 	bl	6190 <tfp_printf>

  /* init TMK modules */
  keyboard_init();
    3ecc:	f000 fb18 	bl	4500 <keyboard_init>
  host_set_driver(&chibios_driver);
    3ed0:	4813      	ldr	r0, [pc, #76]	; (3f20 <main+0x90>)
    3ed2:	f000 fa5d 	bl	4390 <host_set_driver>

#ifdef SLEEP_LED_ENABLE
  sleep_led_init();
    3ed6:	f003 fccb 	bl	7870 <sleep_led_init>
#endif

  print("Keyboard start.\n");
    3eda:	4812      	ldr	r0, [pc, #72]	; (3f24 <main+0x94>)
    3edc:	f002 f958 	bl	6190 <tfp_printf>

  hook_late_init();
    3ee0:	f7ff ffb6 	bl	3e50 <hook_late_init>
    3ee4:	4d10      	ldr	r5, [pc, #64]	; (3f28 <main+0x98>)
    3ee6:	e001      	b.n	3eec <main+0x5c>
#ifdef MOUSEKEY_ENABLE
      mousekey_send();
#endif /* MOUSEKEY_ENABLE */
    }

    keyboard_task();
    3ee8:	f000 fb12 	bl	4510 <keyboard_task>
    if(USB_DRIVER.state == USB_SUSPENDED) {
    3eec:	7823      	ldrb	r3, [r4, #0]
    3eee:	2b05      	cmp	r3, #5
    3ef0:	d1fa      	bne.n	3ee8 <main+0x58>
      print("[s]");
    3ef2:	0028      	movs	r0, r5
    3ef4:	f002 f94c 	bl	6190 <tfp_printf>
      while(USB_DRIVER.state == USB_SUSPENDED) {
    3ef8:	7823      	ldrb	r3, [r4, #0]
    3efa:	2b05      	cmp	r3, #5
    3efc:	d104      	bne.n	3f08 <main+0x78>
        hook_usb_suspend_loop();
    3efe:	f7ff ffaf 	bl	3e60 <hook_usb_suspend_loop>
      while(USB_DRIVER.state == USB_SUSPENDED) {
    3f02:	7823      	ldrb	r3, [r4, #0]
    3f04:	2b05      	cmp	r3, #5
    3f06:	d0fa      	beq.n	3efe <main+0x6e>
      send_keyboard_report();
    3f08:	f001 fc4a 	bl	57a0 <send_keyboard_report>
      mousekey_send();
    3f0c:	f002 fed8 	bl	6cc0 <mousekey_send>
    3f10:	e7ea      	b.n	3ee8 <main+0x58>
    3f12:	46c0      	nop			; (mov r8, r8)
    3f14:	20000180 	.word	0x20000180
    3f18:	00003e31 	.word	0x00003e31
    3f1c:	0000859c 	.word	0x0000859c
    3f20:	1ffffe1c 	.word	0x1ffffe1c
    3f24:	000085b0 	.word	0x000085b0
    3f28:	000085c4 	.word	0x000085c4
    3f2c:	00000000 	.word	0x00000000

00003f30 <action_get_macro>:
  GUI_RIGHT,
  ALT_DEL,
};

const macro_t *action_get_macro(keyrecord_t *record, uint8_t id, uint8_t opt) {
  switch (id) {
    3f30:	2901      	cmp	r1, #1
    3f32:	d00f      	beq.n	3f54 <action_get_macro+0x24>
    3f34:	2900      	cmp	r1, #0
    3f36:	d008      	beq.n	3f4a <action_get_macro+0x1a>
    3f38:	2902      	cmp	r1, #2
    3f3a:	d001      	beq.n	3f40 <action_get_macro+0x10>
      return (MACRO( D(LALT), D(BSPC), END ));
    } else {
      return (MACRO( U(LALT), U(BSPC), END ));
    }
  }
  return MACRO_NONE;
    3f3c:	2000      	movs	r0, #0
}
    3f3e:	4770      	bx	lr
    if (record->event.pressed) {
    3f40:	7883      	ldrb	r3, [r0, #2]
    3f42:	2b00      	cmp	r3, #0
    3f44:	d10f      	bne.n	3f66 <action_get_macro+0x36>
      return (MACRO( U(LALT), U(BSPC), END ));
    3f46:	4809      	ldr	r0, [pc, #36]	; (3f6c <action_get_macro+0x3c>)
    3f48:	e7f9      	b.n	3f3e <action_get_macro+0xe>
    if (record->event.pressed) {
    3f4a:	7883      	ldrb	r3, [r0, #2]
    3f4c:	2b00      	cmp	r3, #0
    3f4e:	d008      	beq.n	3f62 <action_get_macro+0x32>
      return (MACRO( D(LGUI), D(LEFT), END ));
    3f50:	4807      	ldr	r0, [pc, #28]	; (3f70 <action_get_macro+0x40>)
    3f52:	e7f4      	b.n	3f3e <action_get_macro+0xe>
    if (record->event.pressed) {
    3f54:	7883      	ldrb	r3, [r0, #2]
    3f56:	2b00      	cmp	r3, #0
    3f58:	d001      	beq.n	3f5e <action_get_macro+0x2e>
      return (MACRO( D(RGUI), D(RIGHT), END ));
    3f5a:	4806      	ldr	r0, [pc, #24]	; (3f74 <action_get_macro+0x44>)
    3f5c:	e7ef      	b.n	3f3e <action_get_macro+0xe>
      return (MACRO( U(RIGHT), U(RGUI), END ));
    3f5e:	4806      	ldr	r0, [pc, #24]	; (3f78 <action_get_macro+0x48>)
    3f60:	e7ed      	b.n	3f3e <action_get_macro+0xe>
      return (MACRO(U(LEFT), U(LGUI), END));
    3f62:	4806      	ldr	r0, [pc, #24]	; (3f7c <action_get_macro+0x4c>)
    3f64:	e7eb      	b.n	3f3e <action_get_macro+0xe>
      return (MACRO( D(LALT), D(BSPC), END ));
    3f66:	4806      	ldr	r0, [pc, #24]	; (3f80 <action_get_macro+0x50>)
    3f68:	e7e9      	b.n	3f3e <action_get_macro+0xe>
    3f6a:	46c0      	nop			; (mov r8, r8)
    3f6c:	000085f0 	.word	0x000085f0
    3f70:	000085c8 	.word	0x000085c8
    3f74:	000085d8 	.word	0x000085d8
    3f78:	000085e0 	.word	0x000085e0
    3f7c:	000085d0 	.word	0x000085d0
    3f80:	000085e8 	.word	0x000085e8
	...

00003f90 <unselect_rows>:
/* Row pin configuration
   row: 00 01 02 03
   pin: 06 05 19 20 FIX: Rows 5 and 6
 */
static void unselect_rows(void)
{
    3f90:	b510      	push	{r4, lr}
    palSetPadMode(TEENSY_PIN5_IOPORT, TEENSY_PIN5, PAL_MODE_INPUT); // hi-Z
    3f92:	4c0b      	ldr	r4, [pc, #44]	; (3fc0 <unselect_rows+0x30>)
    3f94:	2202      	movs	r2, #2
    3f96:	0020      	movs	r0, r4
    3f98:	2107      	movs	r1, #7
    3f9a:	f7fe fdb9 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN6_IOPORT, TEENSY_PIN6, PAL_MODE_INPUT); // hi-Z
    3f9e:	0020      	movs	r0, r4
    3fa0:	2202      	movs	r2, #2
    3fa2:	2104      	movs	r1, #4
    3fa4:	f7fe fdb4 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN19_IOPORT, TEENSY_PIN19, PAL_MODE_INPUT); // hi-Z
    3fa8:	2202      	movs	r2, #2
    3faa:	2102      	movs	r1, #2
    3fac:	4805      	ldr	r0, [pc, #20]	; (3fc4 <unselect_rows+0x34>)
    3fae:	f7fe fdaf 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN20_IOPORT, TEENSY_PIN20, PAL_MODE_INPUT); // hi-Z
    3fb2:	2202      	movs	r2, #2
    3fb4:	2105      	movs	r1, #5
    3fb6:	0020      	movs	r0, r4
    3fb8:	f7fe fdaa 	bl	2b10 <_pal_lld_setpadmode>
}
    3fbc:	bd10      	pop	{r4, pc}
    3fbe:	46c0      	nop			; (mov r8, r8)
    3fc0:	400ff0c0 	.word	0x400ff0c0
    3fc4:	400ff040 	.word	0x400ff040
	...

00003fd0 <matrix_init>:
{
    3fd0:	b570      	push	{r4, r5, r6, lr}
    palSetPadMode(TEENSY_PIN7_IOPORT, TEENSY_PIN7, PAL_MODE_INPUT_PULLUP);
    3fd2:	4d28      	ldr	r5, [pc, #160]	; (4074 <matrix_init+0xa4>)
    palSetPadMode(TEENSY_PIN9_IOPORT, TEENSY_PIN9, PAL_MODE_INPUT_PULLUP);
    3fd4:	4c28      	ldr	r4, [pc, #160]	; (4078 <matrix_init+0xa8>)
    unselect_rows();
    3fd6:	f7ff ffdb 	bl	3f90 <unselect_rows>
    palSetPadMode(TEENSY_PIN7_IOPORT, TEENSY_PIN7, PAL_MODE_INPUT_PULLUP);
    3fda:	0028      	movs	r0, r5
    3fdc:	2203      	movs	r2, #3
    3fde:	2102      	movs	r1, #2
    3fe0:	f7fe fd96 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN8_IOPORT, TEENSY_PIN8, PAL_MODE_INPUT_PULLUP);
    3fe4:	0028      	movs	r0, r5
    3fe6:	2203      	movs	r2, #3
    3fe8:	2103      	movs	r1, #3
    3fea:	f7fe fd91 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN9_IOPORT, TEENSY_PIN9, PAL_MODE_INPUT_PULLUP);
    3fee:	0020      	movs	r0, r4
    3ff0:	2203      	movs	r2, #3
    3ff2:	2103      	movs	r1, #3
    3ff4:	f7fe fd8c 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN10_IOPORT, TEENSY_PIN10, PAL_MODE_INPUT_PULLUP);
    3ff8:	0020      	movs	r0, r4
    3ffa:	2203      	movs	r2, #3
    3ffc:	2104      	movs	r1, #4
    3ffe:	f7fe fd87 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN11_IOPORT, TEENSY_PIN11, PAL_MODE_INPUT_PULLUP);
    4002:	0020      	movs	r0, r4
    4004:	2203      	movs	r2, #3
    4006:	2106      	movs	r1, #6
    4008:	f7fe fd82 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN12_IOPORT, TEENSY_PIN12, PAL_MODE_INPUT_PULLUP);
    400c:	0020      	movs	r0, r4
    400e:	2203      	movs	r2, #3
    4010:	2107      	movs	r1, #7
    4012:	f7fe fd7d 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN14_IOPORT, TEENSY_PIN14, PAL_MODE_INPUT_PULLUP);
    4016:	0028      	movs	r0, r5
    4018:	2203      	movs	r2, #3
    palSetPadMode(TEENSY_PIN16_IOPORT, TEENSY_PIN16, PAL_MODE_INPUT_PULLUP);
    401a:	4d18      	ldr	r5, [pc, #96]	; (407c <matrix_init+0xac>)
    palSetPadMode(TEENSY_PIN14_IOPORT, TEENSY_PIN14, PAL_MODE_INPUT_PULLUP);
    401c:	2101      	movs	r1, #1
    401e:	f7fe fd77 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN15_IOPORT, TEENSY_PIN15, PAL_MODE_INPUT_PULLUP);
    4022:	0020      	movs	r0, r4
    4024:	2203      	movs	r2, #3
    4026:	2100      	movs	r1, #0
    4028:	f7fe fd72 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN16_IOPORT, TEENSY_PIN16, PAL_MODE_INPUT_PULLUP);
    402c:	0028      	movs	r0, r5
    402e:	2203      	movs	r2, #3
    4030:	2100      	movs	r1, #0
    4032:	f7fe fd6d 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN17_IOPORT, TEENSY_PIN17, PAL_MODE_INPUT_PULLUP);
    4036:	0028      	movs	r0, r5
    4038:	2203      	movs	r2, #3
    403a:	2101      	movs	r1, #1
    403c:	f7fe fd68 	bl	2b10 <_pal_lld_setpadmode>
    palSetPadMode(TEENSY_PIN18_IOPORT, TEENSY_PIN18, PAL_MODE_INPUT_PULLUP);
    4040:	0028      	movs	r0, r5
    4042:	2203      	movs	r2, #3
    4044:	2103      	movs	r1, #3
    4046:	f7fe fd63 	bl	2b10 <_pal_lld_setpadmode>
        matrix[i] = 0;
    404a:	2300      	movs	r3, #0
    debug_matrix = true;
    404c:	2102      	movs	r1, #2
    LED_ON();
    404e:	2520      	movs	r5, #32
    wait_ms(500);
    4050:	20fa      	movs	r0, #250	; 0xfa
        matrix[i] = 0;
    4052:	4a0b      	ldr	r2, [pc, #44]	; (4080 <matrix_init+0xb0>)
    wait_ms(500);
    4054:	0040      	lsls	r0, r0, #1
        matrix[i] = 0;
    4056:	6013      	str	r3, [r2, #0]
    4058:	6053      	str	r3, [r2, #4]
        matrix_debouncing[i] = 0;
    405a:	4a0a      	ldr	r2, [pc, #40]	; (4084 <matrix_init+0xb4>)
    405c:	6013      	str	r3, [r2, #0]
    405e:	6053      	str	r3, [r2, #4]
    debug_matrix = true;
    4060:	4a09      	ldr	r2, [pc, #36]	; (4088 <matrix_init+0xb8>)
    4062:	7813      	ldrb	r3, [r2, #0]
    4064:	430b      	orrs	r3, r1
    4066:	7013      	strb	r3, [r2, #0]
    LED_ON();
    4068:	6065      	str	r5, [r4, #4]
    wait_ms(500);
    406a:	f7fd fbc1 	bl	17f0 <chThdSleep>
    LED_OFF();
    406e:	60a5      	str	r5, [r4, #8]
}
    4070:	bd70      	pop	{r4, r5, r6, pc}
    4072:	46c0      	nop			; (mov r8, r8)
    4074:	400ff0c0 	.word	0x400ff0c0
    4078:	400ff080 	.word	0x400ff080
    407c:	400ff040 	.word	0x400ff040
    4080:	20000c2c 	.word	0x20000c2c
    4084:	20000c34 	.word	0x20000c34
    4088:	20000cb8 	.word	0x20000cb8
    408c:	00000000 	.word	0x00000000

00004090 <matrix_scan>:
{
    4090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4092:	4657      	mov	r7, sl
    4094:	464e      	mov	r6, r9
    4096:	4645      	mov	r5, r8
    4098:	46de      	mov	lr, fp
        case 1:
          palSetPadMode(TEENSY_PIN6_IOPORT, TEENSY_PIN6, PAL_MODE_OUTPUT_PUSHPULL);
          palClearPad(TEENSY_PIN6_IOPORT, TEENSY_PIN6);
          break;
        case 2:
          palSetPadMode(TEENSY_PIN19_IOPORT, TEENSY_PIN19, PAL_MODE_OUTPUT_PUSHPULL);
    409a:	4b77      	ldr	r3, [pc, #476]	; (4278 <matrix_scan+0x1e8>)
    409c:	4c77      	ldr	r4, [pc, #476]	; (427c <matrix_scan+0x1ec>)
    409e:	469a      	mov	sl, r3
          palClearPad(TEENSY_PIN19_IOPORT, TEENSY_PIN19);
          break;
        case 3:
          palSetPadMode(TEENSY_PIN20_IOPORT, TEENSY_PIN20, PAL_MODE_OUTPUT_PUSHPULL);
    40a0:	4b77      	ldr	r3, [pc, #476]	; (4280 <matrix_scan+0x1f0>)
{
    40a2:	b5e0      	push	{r5, r6, r7, lr}
          palSetPadMode(TEENSY_PIN20_IOPORT, TEENSY_PIN20, PAL_MODE_OUTPUT_PUSHPULL);
    40a4:	4699      	mov	r9, r3
			LED_TGL(); // toggle the onboard LED attached to pin 13
    40a6:	4b77      	ldr	r3, [pc, #476]	; (4284 <matrix_scan+0x1f4>)
    40a8:	0027      	movs	r7, r4
    for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
    40aa:	2600      	movs	r6, #0
			LED_TGL(); // toggle the onboard LED attached to pin 13
    40ac:	4698      	mov	r8, r3
    40ae:	4d76      	ldr	r5, [pc, #472]	; (4288 <matrix_scan+0x1f8>)
          palSetPadMode(TEENSY_PIN19_IOPORT, TEENSY_PIN19, PAL_MODE_OUTPUT_PUSHPULL);
    40b0:	2206      	movs	r2, #6
    switch (row) {
    40b2:	2e02      	cmp	r6, #2
    40b4:	d100      	bne.n	40b8 <matrix_scan+0x28>
    40b6:	e0b1      	b.n	421c <matrix_scan+0x18c>
    40b8:	2e03      	cmp	r6, #3
    40ba:	d100      	bne.n	40be <matrix_scan+0x2e>
    40bc:	e0d3      	b.n	4266 <matrix_scan+0x1d6>
    40be:	2e01      	cmp	r6, #1
    40c0:	d100      	bne.n	40c4 <matrix_scan+0x34>
    40c2:	e0c8      	b.n	4256 <matrix_scan+0x1c6>
          palSetPadMode(TEENSY_PIN5_IOPORT, TEENSY_PIN5, PAL_MODE_OUTPUT_PUSHPULL);
    40c4:	2107      	movs	r1, #7
    40c6:	486e      	ldr	r0, [pc, #440]	; (4280 <matrix_scan+0x1f0>)
    40c8:	f7fe fd22 	bl	2b10 <_pal_lld_setpadmode>
          palClearPad(TEENSY_PIN5_IOPORT, TEENSY_PIN5);
    40cc:	2380      	movs	r3, #128	; 0x80
    40ce:	464a      	mov	r2, r9
    40d0:	6093      	str	r3, [r2, #8]
			LED_TGL(); // toggle the onboard LED attached to pin 13
    40d2:	2320      	movs	r3, #32
    40d4:	4642      	mov	r2, r8
     return ((palReadPad(TEENSY_PIN7_IOPORT, TEENSY_PIN7)==PAL_HIGH) ? 0 : (1<<10))
    40d6:	2102      	movs	r1, #2
			LED_TGL(); // toggle the onboard LED attached to pin 13
    40d8:	60d3      	str	r3, [r2, #12]
     return ((palReadPad(TEENSY_PIN7_IOPORT, TEENSY_PIN7)==PAL_HIGH) ? 0 : (1<<10))
    40da:	4869      	ldr	r0, [pc, #420]	; (4280 <matrix_scan+0x1f0>)
    40dc:	f7fe fd10 	bl	2b00 <_pal_lld_readpad>
         | ((palReadPad(TEENSY_PIN8_IOPORT, TEENSY_PIN8)==PAL_HIGH) ? 0 : (1<<9))
    40e0:	3801      	subs	r0, #1
    40e2:	1e43      	subs	r3, r0, #1
    40e4:	4198      	sbcs	r0, r3
    40e6:	2103      	movs	r1, #3
    40e8:	0283      	lsls	r3, r0, #10
    40ea:	4865      	ldr	r0, [pc, #404]	; (4280 <matrix_scan+0x1f0>)
    40ec:	469b      	mov	fp, r3
    40ee:	f7fe fd07 	bl	2b00 <_pal_lld_readpad>
    40f2:	2801      	cmp	r0, #1
    40f4:	d004      	beq.n	4100 <matrix_scan+0x70>
    40f6:	2380      	movs	r3, #128	; 0x80
    40f8:	465a      	mov	r2, fp
    40fa:	009b      	lsls	r3, r3, #2
    40fc:	431a      	orrs	r2, r3
    40fe:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN9_IOPORT, TEENSY_PIN9)==PAL_HIGH) ? 0 : (1<<8))
    4100:	2103      	movs	r1, #3
    4102:	4860      	ldr	r0, [pc, #384]	; (4284 <matrix_scan+0x1f4>)
    4104:	f7fe fcfc 	bl	2b00 <_pal_lld_readpad>
    4108:	2801      	cmp	r0, #1
    410a:	d004      	beq.n	4116 <matrix_scan+0x86>
    410c:	2380      	movs	r3, #128	; 0x80
    410e:	465a      	mov	r2, fp
    4110:	005b      	lsls	r3, r3, #1
    4112:	431a      	orrs	r2, r3
    4114:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN10_IOPORT, TEENSY_PIN10)==PAL_HIGH) ? 0 : (1<<7))
    4116:	2104      	movs	r1, #4
    4118:	485a      	ldr	r0, [pc, #360]	; (4284 <matrix_scan+0x1f4>)
    411a:	f7fe fcf1 	bl	2b00 <_pal_lld_readpad>
    411e:	2801      	cmp	r0, #1
    4120:	d003      	beq.n	412a <matrix_scan+0x9a>
    4122:	465a      	mov	r2, fp
    4124:	2380      	movs	r3, #128	; 0x80
    4126:	431a      	orrs	r2, r3
    4128:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN11_IOPORT, TEENSY_PIN11)==PAL_HIGH) ? 0 : (1<<6))
    412a:	2106      	movs	r1, #6
    412c:	4855      	ldr	r0, [pc, #340]	; (4284 <matrix_scan+0x1f4>)
    412e:	f7fe fce7 	bl	2b00 <_pal_lld_readpad>
    4132:	2801      	cmp	r0, #1
    4134:	d003      	beq.n	413e <matrix_scan+0xae>
    4136:	465a      	mov	r2, fp
    4138:	2340      	movs	r3, #64	; 0x40
    413a:	431a      	orrs	r2, r3
    413c:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN12_IOPORT, TEENSY_PIN12)==PAL_HIGH) ? 0 : (1<<5))
    413e:	2107      	movs	r1, #7
    4140:	4850      	ldr	r0, [pc, #320]	; (4284 <matrix_scan+0x1f4>)
    4142:	f7fe fcdd 	bl	2b00 <_pal_lld_readpad>
    4146:	2801      	cmp	r0, #1
    4148:	d003      	beq.n	4152 <matrix_scan+0xc2>
    414a:	465a      	mov	r2, fp
    414c:	2320      	movs	r3, #32
    414e:	431a      	orrs	r2, r3
    4150:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN14_IOPORT, TEENSY_PIN14)==PAL_HIGH) ? 0 : (1<<4))
    4152:	2101      	movs	r1, #1
    4154:	484a      	ldr	r0, [pc, #296]	; (4280 <matrix_scan+0x1f0>)
    4156:	f7fe fcd3 	bl	2b00 <_pal_lld_readpad>
    415a:	2801      	cmp	r0, #1
    415c:	d003      	beq.n	4166 <matrix_scan+0xd6>
    415e:	465a      	mov	r2, fp
    4160:	2310      	movs	r3, #16
    4162:	431a      	orrs	r2, r3
    4164:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN15_IOPORT, TEENSY_PIN15)==PAL_HIGH) ? 0 : (1<<3))
    4166:	2100      	movs	r1, #0
    4168:	4846      	ldr	r0, [pc, #280]	; (4284 <matrix_scan+0x1f4>)
    416a:	f7fe fcc9 	bl	2b00 <_pal_lld_readpad>
    416e:	2801      	cmp	r0, #1
    4170:	d003      	beq.n	417a <matrix_scan+0xea>
    4172:	465a      	mov	r2, fp
    4174:	2308      	movs	r3, #8
    4176:	431a      	orrs	r2, r3
    4178:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN16_IOPORT, TEENSY_PIN16)==PAL_HIGH) ? 0 : (1<<2))
    417a:	2100      	movs	r1, #0
    417c:	483e      	ldr	r0, [pc, #248]	; (4278 <matrix_scan+0x1e8>)
    417e:	f7fe fcbf 	bl	2b00 <_pal_lld_readpad>
    4182:	2801      	cmp	r0, #1
    4184:	d003      	beq.n	418e <matrix_scan+0xfe>
    4186:	465a      	mov	r2, fp
    4188:	2304      	movs	r3, #4
    418a:	431a      	orrs	r2, r3
    418c:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN17_IOPORT, TEENSY_PIN17)==PAL_HIGH) ? 0 : (1<<1))
    418e:	2101      	movs	r1, #1
    4190:	4839      	ldr	r0, [pc, #228]	; (4278 <matrix_scan+0x1e8>)
    4192:	f7fe fcb5 	bl	2b00 <_pal_lld_readpad>
    4196:	2801      	cmp	r0, #1
    4198:	d003      	beq.n	41a2 <matrix_scan+0x112>
    419a:	465a      	mov	r2, fp
    419c:	2302      	movs	r3, #2
    419e:	431a      	orrs	r2, r3
    41a0:	4693      	mov	fp, r2
         | ((palReadPad(TEENSY_PIN18_IOPORT, TEENSY_PIN18)==PAL_HIGH) ? 0 : (1<<0));
    41a2:	2103      	movs	r1, #3
    41a4:	4834      	ldr	r0, [pc, #208]	; (4278 <matrix_scan+0x1e8>)
    41a6:	f7fe fcab 	bl	2b00 <_pal_lld_readpad>
    41aa:	1e43      	subs	r3, r0, #1
    41ac:	1e58      	subs	r0, r3, #1
    41ae:	4183      	sbcs	r3, r0
    41b0:	465a      	mov	r2, fp
    41b2:	431a      	orrs	r2, r3
    41b4:	b293      	uxth	r3, r2
        if (matrix_debouncing[i] != cols) {
    41b6:	883a      	ldrh	r2, [r7, #0]
    41b8:	429a      	cmp	r2, r3
    41ba:	d00b      	beq.n	41d4 <matrix_scan+0x144>
            matrix_debouncing[i] = cols;
    41bc:	803b      	strh	r3, [r7, #0]
            if (debouncing) {
    41be:	782b      	ldrb	r3, [r5, #0]
    41c0:	2b00      	cmp	r3, #0
    41c2:	d005      	beq.n	41d0 <matrix_scan+0x140>
                debug("bounce!: "); debug_hex(debouncing); debug("\n");
    41c4:	2201      	movs	r2, #1
    41c6:	4b31      	ldr	r3, [pc, #196]	; (428c <matrix_scan+0x1fc>)
    41c8:	469b      	mov	fp, r3
    41ca:	781b      	ldrb	r3, [r3, #0]
    41cc:	421a      	tst	r2, r3
    41ce:	d12d      	bne.n	422c <matrix_scan+0x19c>
            debouncing = DEBOUNCE;
    41d0:	2305      	movs	r3, #5
    41d2:	702b      	strb	r3, [r5, #0]
    for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
    41d4:	3601      	adds	r6, #1
    41d6:	b2f6      	uxtb	r6, r6
        unselect_rows();
    41d8:	f7ff feda 	bl	3f90 <unselect_rows>
    41dc:	3702      	adds	r7, #2
    for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
    41de:	2e04      	cmp	r6, #4
    41e0:	d000      	beq.n	41e4 <matrix_scan+0x154>
    41e2:	e765      	b.n	40b0 <matrix_scan+0x20>
    if (debouncing) {
    41e4:	782b      	ldrb	r3, [r5, #0]
    41e6:	2b00      	cmp	r3, #0
    41e8:	d00d      	beq.n	4206 <matrix_scan+0x176>
        if (--debouncing) {
    41ea:	3b01      	subs	r3, #1
    41ec:	b2db      	uxtb	r3, r3
    41ee:	702b      	strb	r3, [r5, #0]
    41f0:	2b00      	cmp	r3, #0
    41f2:	d10f      	bne.n	4214 <matrix_scan+0x184>
                matrix[i] = matrix_debouncing[i];
    41f4:	4b26      	ldr	r3, [pc, #152]	; (4290 <matrix_scan+0x200>)
    41f6:	8822      	ldrh	r2, [r4, #0]
    41f8:	801a      	strh	r2, [r3, #0]
    41fa:	8862      	ldrh	r2, [r4, #2]
    41fc:	805a      	strh	r2, [r3, #2]
    41fe:	88a2      	ldrh	r2, [r4, #4]
    4200:	809a      	strh	r2, [r3, #4]
    4202:	88e2      	ldrh	r2, [r4, #6]
    4204:	80da      	strh	r2, [r3, #6]
}
    4206:	2001      	movs	r0, #1
    4208:	bc3c      	pop	{r2, r3, r4, r5}
    420a:	4690      	mov	r8, r2
    420c:	4699      	mov	r9, r3
    420e:	46a2      	mov	sl, r4
    4210:	46ab      	mov	fp, r5
    4212:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            wait_ms(1);
    4214:	2001      	movs	r0, #1
    4216:	f7fd faeb 	bl	17f0 <chThdSleep>
    421a:	e7f4      	b.n	4206 <matrix_scan+0x176>
          palSetPadMode(TEENSY_PIN19_IOPORT, TEENSY_PIN19, PAL_MODE_OUTPUT_PUSHPULL);
    421c:	2102      	movs	r1, #2
    421e:	4816      	ldr	r0, [pc, #88]	; (4278 <matrix_scan+0x1e8>)
    4220:	f7fe fc76 	bl	2b10 <_pal_lld_setpadmode>
          palClearPad(TEENSY_PIN19_IOPORT, TEENSY_PIN19);
    4224:	2304      	movs	r3, #4
    4226:	4652      	mov	r2, sl
    4228:	6093      	str	r3, [r2, #8]
    422a:	e752      	b.n	40d2 <matrix_scan+0x42>
                debug("bounce!: "); debug_hex(debouncing); debug("\n");
    422c:	4819      	ldr	r0, [pc, #100]	; (4294 <matrix_scan+0x204>)
    422e:	f001 ffaf 	bl	6190 <tfp_printf>
    4232:	465b      	mov	r3, fp
    4234:	2201      	movs	r2, #1
    4236:	781b      	ldrb	r3, [r3, #0]
    4238:	421a      	tst	r2, r3
    423a:	d0c9      	beq.n	41d0 <matrix_scan+0x140>
    423c:	7829      	ldrb	r1, [r5, #0]
    423e:	4816      	ldr	r0, [pc, #88]	; (4298 <matrix_scan+0x208>)
    4240:	f001 ffa6 	bl	6190 <tfp_printf>
    4244:	465b      	mov	r3, fp
    4246:	2201      	movs	r2, #1
    4248:	781b      	ldrb	r3, [r3, #0]
    424a:	421a      	tst	r2, r3
    424c:	d0c0      	beq.n	41d0 <matrix_scan+0x140>
    424e:	4813      	ldr	r0, [pc, #76]	; (429c <matrix_scan+0x20c>)
    4250:	f001 ff9e 	bl	6190 <tfp_printf>
    4254:	e7bc      	b.n	41d0 <matrix_scan+0x140>
          palSetPadMode(TEENSY_PIN6_IOPORT, TEENSY_PIN6, PAL_MODE_OUTPUT_PUSHPULL);
    4256:	2104      	movs	r1, #4
    4258:	4809      	ldr	r0, [pc, #36]	; (4280 <matrix_scan+0x1f0>)
    425a:	f7fe fc59 	bl	2b10 <_pal_lld_setpadmode>
          palClearPad(TEENSY_PIN6_IOPORT, TEENSY_PIN6);
    425e:	2310      	movs	r3, #16
    4260:	464a      	mov	r2, r9
    4262:	6093      	str	r3, [r2, #8]
    4264:	e735      	b.n	40d2 <matrix_scan+0x42>
          palSetPadMode(TEENSY_PIN20_IOPORT, TEENSY_PIN20, PAL_MODE_OUTPUT_PUSHPULL);
    4266:	2105      	movs	r1, #5
    4268:	4805      	ldr	r0, [pc, #20]	; (4280 <matrix_scan+0x1f0>)
    426a:	f7fe fc51 	bl	2b10 <_pal_lld_setpadmode>
          palClearPad(TEENSY_PIN20_IOPORT, TEENSY_PIN20);
    426e:	2320      	movs	r3, #32
    4270:	464a      	mov	r2, r9
    4272:	6093      	str	r3, [r2, #8]
    4274:	e72d      	b.n	40d2 <matrix_scan+0x42>
    4276:	46c0      	nop			; (mov r8, r8)
    4278:	400ff040 	.word	0x400ff040
    427c:	20000c34 	.word	0x20000c34
    4280:	400ff0c0 	.word	0x400ff0c0
    4284:	400ff080 	.word	0x400ff080
    4288:	1ffffe30 	.word	0x1ffffe30
    428c:	20000cb8 	.word	0x20000cb8
    4290:	20000c2c 	.word	0x20000c2c
    4294:	00008788 	.word	0x00008788
    4298:	00008794 	.word	0x00008794
    429c:	00009100 	.word	0x00009100

000042a0 <matrix_get_row>:
    return matrix[row];
    42a0:	4b01      	ldr	r3, [pc, #4]	; (42a8 <matrix_get_row+0x8>)
    42a2:	0040      	lsls	r0, r0, #1
    42a4:	5a18      	ldrh	r0, [r3, r0]
}
    42a6:	4770      	bx	lr
    42a8:	20000c2c 	.word	0x20000c2c
    42ac:	00000000 	.word	0x00000000

000042b0 <matrix_print>:
{
    42b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    42b2:	46ce      	mov	lr, r9
    42b4:	4647      	mov	r7, r8
    print("\nr/c 0123456789ABCDEF\n");
    42b6:	4812      	ldr	r0, [pc, #72]	; (4300 <matrix_print+0x50>)
{
    42b8:	b580      	push	{r7, lr}
    print("\nr/c 0123456789ABCDEF\n");
    42ba:	f001 ff69 	bl	6190 <tfp_printf>
    42be:	4b11      	ldr	r3, [pc, #68]	; (4304 <matrix_print+0x54>)
    42c0:	2400      	movs	r4, #0
    42c2:	4699      	mov	r9, r3
    42c4:	4b10      	ldr	r3, [pc, #64]	; (4308 <matrix_print+0x58>)
    42c6:	4f11      	ldr	r7, [pc, #68]	; (430c <matrix_print+0x5c>)
    42c8:	4698      	mov	r8, r3
    42ca:	4e11      	ldr	r6, [pc, #68]	; (4310 <matrix_print+0x60>)
    42cc:	4d11      	ldr	r5, [pc, #68]	; (4314 <matrix_print+0x64>)
        phex(row); print(": ");
    42ce:	0021      	movs	r1, r4
    42d0:	4648      	mov	r0, r9
    42d2:	f001 ff5d 	bl	6190 <tfp_printf>
    42d6:	4640      	mov	r0, r8
    42d8:	f001 ff5a 	bl	6190 <tfp_printf>
    return matrix[row];
    42dc:	0063      	lsls	r3, r4, #1
        pbin_reverse16(matrix_get_row(row));
    42de:	5af8      	ldrh	r0, [r7, r3]
    42e0:	f001 fcae 	bl	5c40 <bitrev16>
    42e4:	0001      	movs	r1, r0
    42e6:	0030      	movs	r0, r6
    42e8:	f001 ff52 	bl	6190 <tfp_printf>
    42ec:	3401      	adds	r4, #1
        print("\n");
    42ee:	0028      	movs	r0, r5
    42f0:	f001 ff4e 	bl	6190 <tfp_printf>
    for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
    42f4:	2c04      	cmp	r4, #4
    42f6:	d1ea      	bne.n	42ce <matrix_print+0x1e>
}
    42f8:	bc0c      	pop	{r2, r3}
    42fa:	4690      	mov	r8, r2
    42fc:	4699      	mov	r9, r3
    42fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4300:	00008768 	.word	0x00008768
    4304:	00008794 	.word	0x00008794
    4308:	00009138 	.word	0x00009138
    430c:	20000c2c 	.word	0x20000c2c
    4310:	00008780 	.word	0x00008780
    4314:	00009100 	.word	0x00009100
	...

00004320 <keymap_key_to_keycode>:
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include "keymap_common.h"
                                    /* translates key to keycode */
uint8_t keymap_key_to_keycode(uint8_t layer, keypos_t key)
{
    4320:	040a      	lsls	r2, r1, #16
  return pgm_read_byte(&keymaps[(layer)][(key.row)][(key.col)]);
    4322:	0e12      	lsrs	r2, r2, #24
    4324:	0093      	lsls	r3, r2, #2
    4326:	189b      	adds	r3, r3, r2
    4328:	005b      	lsls	r3, r3, #1
    432a:	189b      	adds	r3, r3, r2
    432c:	222c      	movs	r2, #44	; 0x2c
    432e:	4350      	muls	r0, r2
    4330:	1818      	adds	r0, r3, r0
    4332:	4b03      	ldr	r3, [pc, #12]	; (4340 <keymap_key_to_keycode+0x20>)
    4334:	b2c9      	uxtb	r1, r1
    4336:	1818      	adds	r0, r3, r0
    4338:	5c40      	ldrb	r0, [r0, r1]
{
    433a:	b082      	sub	sp, #8
}
    433c:	b002      	add	sp, #8
    433e:	4770      	bx	lr
    4340:	00008634 	.word	0x00008634
	...

00004350 <keymap_fn_to_action>:

/* translates Fn keycode to action */
action_t keymap_fn_to_action(uint8_t keycode)
{
  return (action_t){ .code = pgm_read_word(&fn_actions[FN_INDEX(keycode)]) };
    4350:	4b02      	ldr	r3, [pc, #8]	; (435c <keymap_fn_to_action+0xc>)
    4352:	38c0      	subs	r0, #192	; 0xc0
    4354:	0040      	lsls	r0, r0, #1
    4356:	5a18      	ldrh	r0, [r3, r0]
}
    4358:	4770      	bx	lr
    435a:	46c0      	nop			; (mov r8, r8)
    435c:	000085f8 	.word	0x000085f8

00004360 <led_set>:
#include "hal.h"

#include "led.h"


void led_set(uint8_t usb_led) {
    4360:	b510      	push	{r4, lr}
    if (usb_led & (1<<USB_LED_CAPS_LOCK)) {
    4362:	0783      	lsls	r3, r0, #30
    4364:	d405      	bmi.n	4372 <led_set+0x12>
        // output high
        palSetPadMode(TEENSY_PIN13_IOPORT, TEENSY_PIN13, PAL_MODE_OUTPUT_PUSHPULL);
        palSetPad(TEENSY_PIN13_IOPORT, TEENSY_PIN13);
    } else {
        // Hi-Z
        palSetPadMode(TEENSY_PIN13_IOPORT, TEENSY_PIN13, PAL_MODE_INPUT);
    4366:	2202      	movs	r2, #2
    4368:	2105      	movs	r1, #5
    436a:	4806      	ldr	r0, [pc, #24]	; (4384 <led_set+0x24>)
    436c:	f7fe fbd0 	bl	2b10 <_pal_lld_setpadmode>
    }
}
    4370:	bd10      	pop	{r4, pc}
        palSetPadMode(TEENSY_PIN13_IOPORT, TEENSY_PIN13, PAL_MODE_OUTPUT_PUSHPULL);
    4372:	4c04      	ldr	r4, [pc, #16]	; (4384 <led_set+0x24>)
    4374:	2206      	movs	r2, #6
    4376:	2105      	movs	r1, #5
    4378:	0020      	movs	r0, r4
    437a:	f7fe fbc9 	bl	2b10 <_pal_lld_setpadmode>
        palSetPad(TEENSY_PIN13_IOPORT, TEENSY_PIN13);
    437e:	2320      	movs	r3, #32
    4380:	6063      	str	r3, [r4, #4]
    4382:	e7f5      	b.n	4370 <led_set+0x10>
    4384:	400ff080 	.word	0x400ff080
	...

00004390 <host_set_driver>:
static uint16_t last_consumer_report = 0;


void host_set_driver(host_driver_t *d)
{
    driver = d;
    4390:	4b01      	ldr	r3, [pc, #4]	; (4398 <host_set_driver+0x8>)
    4392:	6018      	str	r0, [r3, #0]
}
    4394:	4770      	bx	lr
    4396:	46c0      	nop			; (mov r8, r8)
    4398:	20000c3c 	.word	0x20000c3c
    439c:	00000000 	.word	0x00000000

000043a0 <host_keyboard_leds>:
    return driver;
}

uint8_t host_keyboard_leds(void)
{
    if (!driver) return 0;
    43a0:	4b04      	ldr	r3, [pc, #16]	; (43b4 <host_keyboard_leds+0x14>)
{
    43a2:	b510      	push	{r4, lr}
    if (!driver) return 0;
    43a4:	681b      	ldr	r3, [r3, #0]
    43a6:	2b00      	cmp	r3, #0
    43a8:	d002      	beq.n	43b0 <host_keyboard_leds+0x10>
    return (*driver->keyboard_leds)();
    43aa:	681b      	ldr	r3, [r3, #0]
    43ac:	4798      	blx	r3
}
    43ae:	bd10      	pop	{r4, pc}
    if (!driver) return 0;
    43b0:	2000      	movs	r0, #0
    43b2:	e7fc      	b.n	43ae <host_keyboard_leds+0xe>
    43b4:	20000c3c 	.word	0x20000c3c
	...

000043c0 <host_keyboard_send>:
/* send report */
void host_keyboard_send(report_keyboard_t *report)
{
    43c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    43c2:	46c6      	mov	lr, r8
    if (!driver) return;
    43c4:	4b18      	ldr	r3, [pc, #96]	; (4428 <host_keyboard_send+0x68>)
{
    43c6:	b500      	push	{lr}
    if (!driver) return;
    43c8:	681b      	ldr	r3, [r3, #0]
{
    43ca:	0004      	movs	r4, r0
    if (!driver) return;
    43cc:	2b00      	cmp	r3, #0
    43ce:	d01f      	beq.n	4410 <host_keyboard_send+0x50>
    (*driver->send_keyboard)(report);
    43d0:	685b      	ldr	r3, [r3, #4]
    43d2:	4798      	blx	r3

    if (debug_keyboard) {
    43d4:	4f15      	ldr	r7, [pc, #84]	; (442c <host_keyboard_send+0x6c>)
    43d6:	783a      	ldrb	r2, [r7, #0]
    43d8:	0753      	lsls	r3, r2, #29
    43da:	d519      	bpl.n	4410 <host_keyboard_send+0x50>
        dprint("keyboard: ");
    43dc:	07d3      	lsls	r3, r2, #31
    43de:	d41e      	bmi.n	441e <host_keyboard_send+0x5e>
    43e0:	0026      	movs	r6, r4
        for (uint8_t i = 0; i < KEYBOARD_REPORT_SIZE; i++) {
            dprintf("%02X ", report->raw[i]);
    43e2:	4b13      	ldr	r3, [pc, #76]	; (4430 <host_keyboard_send+0x70>)
    43e4:	3610      	adds	r6, #16
    43e6:	2501      	movs	r5, #1
    43e8:	4698      	mov	r8, r3
    43ea:	e002      	b.n	43f2 <host_keyboard_send+0x32>
    43ec:	3401      	adds	r4, #1
        for (uint8_t i = 0; i < KEYBOARD_REPORT_SIZE; i++) {
    43ee:	42a6      	cmp	r6, r4
    43f0:	d00c      	beq.n	440c <host_keyboard_send+0x4c>
            dprintf("%02X ", report->raw[i]);
    43f2:	002b      	movs	r3, r5
    43f4:	4013      	ands	r3, r2
    43f6:	d0f9      	beq.n	43ec <host_keyboard_send+0x2c>
    43f8:	7821      	ldrb	r1, [r4, #0]
    43fa:	4640      	mov	r0, r8
    43fc:	f001 fec8 	bl	6190 <tfp_printf>
    4400:	002b      	movs	r3, r5
    4402:	783a      	ldrb	r2, [r7, #0]
    4404:	3401      	adds	r4, #1
    4406:	4013      	ands	r3, r2
        for (uint8_t i = 0; i < KEYBOARD_REPORT_SIZE; i++) {
    4408:	42a6      	cmp	r6, r4
    440a:	d1f2      	bne.n	43f2 <host_keyboard_send+0x32>
        }
        dprint("\n");
    440c:	2b00      	cmp	r3, #0
    440e:	d102      	bne.n	4416 <host_keyboard_send+0x56>
    }
}
    4410:	bc04      	pop	{r2}
    4412:	4690      	mov	r8, r2
    4414:	bdf0      	pop	{r4, r5, r6, r7, pc}
        dprint("\n");
    4416:	4807      	ldr	r0, [pc, #28]	; (4434 <host_keyboard_send+0x74>)
    4418:	f001 feba 	bl	6190 <tfp_printf>
    441c:	e7f8      	b.n	4410 <host_keyboard_send+0x50>
        dprint("keyboard: ");
    441e:	4806      	ldr	r0, [pc, #24]	; (4438 <host_keyboard_send+0x78>)
    4420:	f001 feb6 	bl	6190 <tfp_printf>
    4424:	783a      	ldrb	r2, [r7, #0]
    4426:	e7db      	b.n	43e0 <host_keyboard_send+0x20>
    4428:	20000c3c 	.word	0x20000c3c
    442c:	20000cb8 	.word	0x20000cb8
    4430:	000087b8 	.word	0x000087b8
    4434:	00009100 	.word	0x00009100
    4438:	000087ac 	.word	0x000087ac
    443c:	00000000 	.word	0x00000000

00004440 <host_mouse_send>:

void host_mouse_send(report_mouse_t *report)
{
    if (!driver) return;
    4440:	4b03      	ldr	r3, [pc, #12]	; (4450 <host_mouse_send+0x10>)
{
    4442:	b510      	push	{r4, lr}
    if (!driver) return;
    4444:	681b      	ldr	r3, [r3, #0]
    4446:	2b00      	cmp	r3, #0
    4448:	d001      	beq.n	444e <host_mouse_send+0xe>
    (*driver->send_mouse)(report);
    444a:	689b      	ldr	r3, [r3, #8]
    444c:	4798      	blx	r3
}
    444e:	bd10      	pop	{r4, pc}
    4450:	20000c3c 	.word	0x20000c3c
	...

00004460 <host_system_send>:

void host_system_send(uint16_t report)
{
    if (report == last_system_report) return;
    4460:	4b0c      	ldr	r3, [pc, #48]	; (4494 <host_system_send+0x34>)
{
    4462:	b510      	push	{r4, lr}
    if (report == last_system_report) return;
    4464:	881a      	ldrh	r2, [r3, #0]
{
    4466:	0004      	movs	r4, r0
    if (report == last_system_report) return;
    4468:	4282      	cmp	r2, r0
    446a:	d00c      	beq.n	4486 <host_system_send+0x26>
    last_system_report = report;
    446c:	8018      	strh	r0, [r3, #0]

    if (!driver) return;
    446e:	4b0a      	ldr	r3, [pc, #40]	; (4498 <host_system_send+0x38>)
    4470:	681b      	ldr	r3, [r3, #0]
    4472:	2b00      	cmp	r3, #0
    4474:	d007      	beq.n	4486 <host_system_send+0x26>
    (*driver->send_system)(report);
    4476:	68db      	ldr	r3, [r3, #12]
    4478:	4798      	blx	r3

    if (debug_keyboard) {
    447a:	4b08      	ldr	r3, [pc, #32]	; (449c <host_system_send+0x3c>)
        dprintf("system: %04X\n", report);
    447c:	781a      	ldrb	r2, [r3, #0]
    447e:	2305      	movs	r3, #5
    4480:	4013      	ands	r3, r2
    4482:	2b05      	cmp	r3, #5
    4484:	d000      	beq.n	4488 <host_system_send+0x28>
    }
}
    4486:	bd10      	pop	{r4, pc}
        dprintf("system: %04X\n", report);
    4488:	0021      	movs	r1, r4
    448a:	4805      	ldr	r0, [pc, #20]	; (44a0 <host_system_send+0x40>)
    448c:	f001 fe80 	bl	6190 <tfp_printf>
    4490:	e7f9      	b.n	4486 <host_system_send+0x26>
    4492:	46c0      	nop			; (mov r8, r8)
    4494:	20000c42 	.word	0x20000c42
    4498:	20000c3c 	.word	0x20000c3c
    449c:	20000cb8 	.word	0x20000cb8
    44a0:	000087c0 	.word	0x000087c0
	...

000044b0 <host_consumer_send>:

void host_consumer_send(uint16_t report)
{
    if (report == last_consumer_report) return;
    44b0:	4b0c      	ldr	r3, [pc, #48]	; (44e4 <host_consumer_send+0x34>)
{
    44b2:	b510      	push	{r4, lr}
    if (report == last_consumer_report) return;
    44b4:	881a      	ldrh	r2, [r3, #0]
{
    44b6:	0004      	movs	r4, r0
    if (report == last_consumer_report) return;
    44b8:	4282      	cmp	r2, r0
    44ba:	d00c      	beq.n	44d6 <host_consumer_send+0x26>
    last_consumer_report = report;
    44bc:	8018      	strh	r0, [r3, #0]

    if (!driver) return;
    44be:	4b0a      	ldr	r3, [pc, #40]	; (44e8 <host_consumer_send+0x38>)
    44c0:	681b      	ldr	r3, [r3, #0]
    44c2:	2b00      	cmp	r3, #0
    44c4:	d007      	beq.n	44d6 <host_consumer_send+0x26>
    (*driver->send_consumer)(report);
    44c6:	691b      	ldr	r3, [r3, #16]
    44c8:	4798      	blx	r3

    if (debug_keyboard) {
    44ca:	4b08      	ldr	r3, [pc, #32]	; (44ec <host_consumer_send+0x3c>)
        dprintf("consumer: %04X\n", report);
    44cc:	781a      	ldrb	r2, [r3, #0]
    44ce:	2305      	movs	r3, #5
    44d0:	4013      	ands	r3, r2
    44d2:	2b05      	cmp	r3, #5
    44d4:	d000      	beq.n	44d8 <host_consumer_send+0x28>
    }
}
    44d6:	bd10      	pop	{r4, pc}
        dprintf("consumer: %04X\n", report);
    44d8:	0021      	movs	r1, r4
    44da:	4805      	ldr	r0, [pc, #20]	; (44f0 <host_consumer_send+0x40>)
    44dc:	f001 fe58 	bl	6190 <tfp_printf>
    44e0:	e7f9      	b.n	44d6 <host_consumer_send+0x26>
    44e2:	46c0      	nop			; (mov r8, r8)
    44e4:	20000c40 	.word	0x20000c40
    44e8:	20000c3c 	.word	0x20000c3c
    44ec:	20000cb8 	.word	0x20000cb8
    44f0:	0000879c 	.word	0x0000879c
	...

00004500 <keyboard_init>:
{
    matrix_setup();
}

void keyboard_init(void)
{
    4500:	b510      	push	{r4, lr}
    timer_init();
    4502:	f001 fe5d 	bl	61c0 <timer_init>
    matrix_init();
    4506:	f7ff fd63 	bl	3fd0 <matrix_init>
    adb_mouse_init();
#endif


#ifdef BOOTMAGIC_ENABLE
    bootmagic();
    450a:	f001 ff39 	bl	6380 <bootmagic>
#endif

#ifdef BACKLIGHT_ENABLE
    backlight_init();
#endif
}
    450e:	bd10      	pop	{r4, pc}

00004510 <keyboard_task>:
/*
 * Do keyboard routine jobs: scan mantrix, light LEDs, ...
 * This is repeatedly called as fast as possible.
 */
void keyboard_task(void)
{
    4510:	b5f0      	push	{r4, r5, r6, r7, lr}
    4512:	46de      	mov	lr, fp
    4514:	4657      	mov	r7, sl
    4516:	464e      	mov	r6, r9
    4518:	4645      	mov	r5, r8
    451a:	b5e0      	push	{r5, r6, r7, lr}
    451c:	b083      	sub	sp, #12
#endif
    static uint8_t led_status = 0;
    matrix_row_t matrix_row = 0;
    matrix_row_t matrix_change = 0;

    matrix_scan();
    451e:	f7ff fdb7 	bl	4090 <matrix_scan>
    4522:	4b3c      	ldr	r3, [pc, #240]	; (4614 <keyboard_task+0x104>)
    4524:	2500      	movs	r5, #0
    4526:	469a      	mov	sl, r3
                matrix_ghost[r] = matrix_row;
                continue;
            }
            matrix_ghost[r] = matrix_row;
#endif
            if (debug_matrix) matrix_print();
    4528:	4b3b      	ldr	r3, [pc, #236]	; (4618 <keyboard_task+0x108>)
            for (uint8_t c = 0; c < MATRIX_COLS; c++) {
                if (matrix_change & ((matrix_row_t)1<<c)) {
    452a:	2601      	movs	r6, #1
            if (debug_matrix) matrix_print();
    452c:	469b      	mov	fp, r3
    452e:	b2eb      	uxtb	r3, r5
        matrix_row = matrix_get_row(r);
    4530:	0018      	movs	r0, r3
    4532:	4699      	mov	r9, r3
    4534:	f7ff feb4 	bl	42a0 <matrix_get_row>
        matrix_change = matrix_row ^ matrix_prev[r];
    4538:	006b      	lsls	r3, r5, #1
    453a:	4698      	mov	r8, r3
    453c:	4653      	mov	r3, sl
    453e:	4642      	mov	r2, r8
    4540:	5a9c      	ldrh	r4, [r3, r2]
        matrix_row = matrix_get_row(r);
    4542:	0007      	movs	r7, r0
        if (matrix_change) {
    4544:	4284      	cmp	r4, r0
    4546:	d00f      	beq.n	4568 <keyboard_task+0x58>
            if (debug_matrix) matrix_print();
    4548:	465b      	mov	r3, fp
    454a:	2202      	movs	r2, #2
    454c:	781b      	ldrb	r3, [r3, #0]
    454e:	421a      	tst	r2, r3
    4550:	d157      	bne.n	4602 <keyboard_task+0xf2>
        matrix_change = matrix_row ^ matrix_prev[r];
    4552:	2300      	movs	r3, #0
    4554:	407c      	eors	r4, r7
    4556:	b2a4      	uxth	r4, r4
                if (matrix_change & ((matrix_row_t)1<<c)) {
    4558:	0022      	movs	r2, r4
    455a:	411a      	asrs	r2, r3
    455c:	b2d9      	uxtb	r1, r3
    455e:	4216      	tst	r6, r2
    4560:	d131      	bne.n	45c6 <keyboard_task+0xb6>
    4562:	3301      	adds	r3, #1
            for (uint8_t c = 0; c < MATRIX_COLS; c++) {
    4564:	2b0b      	cmp	r3, #11
    4566:	d1f7      	bne.n	4558 <keyboard_task+0x48>
    4568:	3501      	adds	r5, #1
    for (uint8_t r = 0; r < MATRIX_ROWS; r++) {
    456a:	2d04      	cmp	r5, #4
    456c:	d1df      	bne.n	452e <keyboard_task+0x1e>
                }
            }
        }
    }
    // call with pseudo tick event when no real key event.
    action_exec(TICK);
    456e:	2301      	movs	r3, #1
    4570:	466a      	mov	r2, sp
    4572:	425b      	negs	r3, r3
    4574:	8013      	strh	r3, [r2, #0]
    4576:	2300      	movs	r3, #0
    4578:	7093      	strb	r3, [r2, #2]
    457a:	f001 fe29 	bl	61d0 <timer_read>
    457e:	2301      	movs	r3, #1
    4580:	4318      	orrs	r0, r3
    4582:	466b      	mov	r3, sp
    4584:	8098      	strh	r0, [r3, #4]
    4586:	9901      	ldr	r1, [sp, #4]
    4588:	9800      	ldr	r0, [sp, #0]
    458a:	f000 f859 	bl	4640 <action_exec>

MATRIX_LOOP_END:

    hook_keyboard_loop();
    458e:	f001 fb7f 	bl	5c90 <hook_keyboard_loop>

#ifdef MOUSEKEY_ENABLE
    // mousekey repeat & acceleration
    mousekey_task();
    4592:	f002 fc05 	bl	6da0 <mousekey_task>
#ifdef ADB_MOUSE_ENABLE
        adb_mouse_task();
#endif

    // update LED
    if (led_status != host_keyboard_leds()) {
    4596:	f7ff ff03 	bl	43a0 <host_keyboard_leds>
    459a:	4c20      	ldr	r4, [pc, #128]	; (461c <keyboard_task+0x10c>)
    459c:	7823      	ldrb	r3, [r4, #0]
    459e:	4283      	cmp	r3, r0
    45a0:	d00a      	beq.n	45b8 <keyboard_task+0xa8>
        led_status = host_keyboard_leds();
    45a2:	f7ff fefd 	bl	43a0 <host_keyboard_leds>
        if (debug_keyboard) dprintf("LED: %02X\n", led_status);
    45a6:	4b1c      	ldr	r3, [pc, #112]	; (4618 <keyboard_task+0x108>)
        led_status = host_keyboard_leds();
    45a8:	7020      	strb	r0, [r4, #0]
        if (debug_keyboard) dprintf("LED: %02X\n", led_status);
    45aa:	781a      	ldrb	r2, [r3, #0]
    45ac:	2305      	movs	r3, #5
    45ae:	4013      	ands	r3, r2
    45b0:	2b05      	cmp	r3, #5
    45b2:	d029      	beq.n	4608 <keyboard_task+0xf8>
        hook_keyboard_leds_change(led_status);
    45b4:	f001 fb8c 	bl	5cd0 <hook_keyboard_leds_change>
    }
}
    45b8:	b003      	add	sp, #12
    45ba:	bc3c      	pop	{r2, r3, r4, r5}
    45bc:	4690      	mov	r8, r2
    45be:	4699      	mov	r9, r3
    45c0:	46a2      	mov	sl, r4
    45c2:	46ab      	mov	fp, r5
    45c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        .pressed = (matrix_row & ((matrix_row_t)1<<c)),
    45c6:	409e      	lsls	r6, r3
                    keyevent_t e = (keyevent_t){
    45c8:	466a      	mov	r2, sp
                        .pressed = (matrix_row & ((matrix_row_t)1<<c)),
    45ca:	4037      	ands	r7, r6
                    keyevent_t e = (keyevent_t){
    45cc:	7011      	strb	r1, [r2, #0]
                        .pressed = (matrix_row & ((matrix_row_t)1<<c)),
    45ce:	1e7b      	subs	r3, r7, #1
    45d0:	419f      	sbcs	r7, r3
                    keyevent_t e = (keyevent_t){
    45d2:	4649      	mov	r1, r9
    45d4:	7097      	strb	r7, [r2, #2]
    45d6:	7051      	strb	r1, [r2, #1]
                        .time = (timer_read() | 1) /* time should not be 0 */
    45d8:	f001 fdfa 	bl	61d0 <timer_read>
                    keyevent_t e = (keyevent_t){
    45dc:	2301      	movs	r3, #1
    45de:	4318      	orrs	r0, r3
    45e0:	466b      	mov	r3, sp
    45e2:	8098      	strh	r0, [r3, #4]
                    action_exec(e);
    45e4:	9901      	ldr	r1, [sp, #4]
    45e6:	9800      	ldr	r0, [sp, #0]
    45e8:	f000 f82a 	bl	4640 <action_exec>
                    hook_matrix_change(e);
    45ec:	9800      	ldr	r0, [sp, #0]
    45ee:	9901      	ldr	r1, [sp, #4]
    45f0:	f001 fb56 	bl	5ca0 <hook_matrix_change>
                    matrix_prev[r] ^= ((matrix_row_t)1<<c);
    45f4:	4642      	mov	r2, r8
    45f6:	4653      	mov	r3, sl
    45f8:	5a9b      	ldrh	r3, [r3, r2]
    45fa:	405e      	eors	r6, r3
    45fc:	4653      	mov	r3, sl
    45fe:	529e      	strh	r6, [r3, r2]
    4600:	e7c5      	b.n	458e <keyboard_task+0x7e>
            if (debug_matrix) matrix_print();
    4602:	f7ff fe55 	bl	42b0 <matrix_print>
    4606:	e7a4      	b.n	4552 <keyboard_task+0x42>
        if (debug_keyboard) dprintf("LED: %02X\n", led_status);
    4608:	0001      	movs	r1, r0
    460a:	4805      	ldr	r0, [pc, #20]	; (4620 <keyboard_task+0x110>)
    460c:	f001 fdc0 	bl	6190 <tfp_printf>
    4610:	7820      	ldrb	r0, [r4, #0]
    4612:	e7cf      	b.n	45b4 <keyboard_task+0xa4>
    4614:	20000c48 	.word	0x20000c48
    4618:	20000cb8 	.word	0x20000cb8
    461c:	20000c44 	.word	0x20000c44
    4620:	000087d0 	.word	0x000087d0
	...

00004630 <keyboard_set_leds>:

void keyboard_set_leds(uint8_t leds)
{
    4630:	b510      	push	{r4, lr}
    led_set(leds);
    4632:	f7ff fe95 	bl	4360 <led_set>
}
    4636:	bd10      	pop	{r4, pc}
	...

00004640 <action_exec>:
#include "nodebug.h"
#endif


void action_exec(keyevent_t event)
{
    4640:	b500      	push	{lr}
    4642:	b087      	sub	sp, #28
    4644:	9101      	str	r1, [sp, #4]
    4646:	b28b      	uxth	r3, r1
    4648:	4669      	mov	r1, sp
    464a:	9000      	str	r0, [sp, #0]
    464c:	8188      	strh	r0, [r1, #12]

/* Rules for No Event:
 * 1) (time == 0) to handle (keyevent_t){} as empty event
 * 2) Matrix(255, 255) to make TICK event available
 */
static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 && event.key.col == 255); }
    464e:	2b00      	cmp	r3, #0
    4650:	d007      	beq.n	4662 <action_exec+0x22>
    4652:	4b0b      	ldr	r3, [pc, #44]	; (4680 <action_exec+0x40>)
    4654:	b282      	uxth	r2, r0
    4656:	429a      	cmp	r2, r3
    4658:	d003      	beq.n	4662 <action_exec+0x22>
    if (!IS_NOEVENT(event)) {
        dprint("\n---- action_exec: start -----\n");
        dprint("EVENT: "); debug_event(event); dprintln();
        hook_matrix_change(event);
    465a:	9800      	ldr	r0, [sp, #0]
    465c:	9901      	ldr	r1, [sp, #4]
    465e:	f001 fb1f 	bl	5ca0 <hook_matrix_change>
    }

    keyrecord_t record = { .event = event };
    4662:	2200      	movs	r2, #0
    4664:	ab04      	add	r3, sp, #16
    4666:	80da      	strh	r2, [r3, #6]
    4668:	9a00      	ldr	r2, [sp, #0]
    466a:	9204      	str	r2, [sp, #16]
    466c:	466a      	mov	r2, sp
    466e:	8892      	ldrh	r2, [r2, #4]
    4670:	809a      	strh	r2, [r3, #4]

#ifndef NO_ACTION_TAPPING
    action_tapping_process(record);
    4672:	9800      	ldr	r0, [sp, #0]
    4674:	9905      	ldr	r1, [sp, #20]
    4676:	f000 fe93 	bl	53a0 <action_tapping_process>
    process_action(&record);
    if (!IS_NOEVENT(record.event)) {
        dprint("processed: "); debug_record(record); dprintln();
    }
#endif
}
    467a:	b007      	add	sp, #28
    467c:	bd00      	pop	{pc}
    467e:	46c0      	nop			; (mov r8, r8)
    4680:	0000ffff 	.word	0x0000ffff
	...

00004690 <register_code>:

/*
 * Utilities for actions.
 */
void register_code(uint8_t code)
{
    4690:	b510      	push	{r4, lr}
    4692:	1e04      	subs	r4, r0, #0
    if (code == KC_NO) {
    4694:	d01e      	beq.n	46d4 <register_code+0x44>
        return;
    }

#ifdef LOCKING_SUPPORT_ENABLE
    else if (KC_LOCKING_CAPS == code) {
    4696:	2882      	cmp	r0, #130	; 0x82
    4698:	d01d      	beq.n	46d6 <register_code+0x46>
        wait_ms(100);
        del_key(KC_CAPSLOCK);
        send_keyboard_report();
    }

    else if (KC_LOCKING_NUM == code) {
    469a:	2883      	cmp	r0, #131	; 0x83
    469c:	d037      	beq.n	470e <register_code+0x7e>
        wait_ms(100);
        del_key(KC_NUMLOCK);
        send_keyboard_report();
    }

    else if (KC_LOCKING_SCROLL == code) {
    469e:	2884      	cmp	r0, #132	; 0x84
    46a0:	d047      	beq.n	4732 <register_code+0xa2>
        del_key(KC_SCROLLLOCK);
        send_keyboard_report();
    }
#endif

    else if IS_KEY(code) {
    46a2:	1f03      	subs	r3, r0, #4
    46a4:	b2db      	uxtb	r3, r3
    46a6:	2ba0      	cmp	r3, #160	; 0xa0
    46a8:	d927      	bls.n	46fa <register_code+0x6a>
        {
            add_key(code);
            send_keyboard_report();
        }
    }
    else if IS_MOD(code) {
    46aa:	0003      	movs	r3, r0
    46ac:	3320      	adds	r3, #32
    46ae:	b2db      	uxtb	r3, r3
    46b0:	2b07      	cmp	r3, #7
    46b2:	d800      	bhi.n	46b6 <register_code+0x26>
    46b4:	e085      	b.n	47c2 <register_code+0x132>
        add_mods(MOD_BIT(code));
        send_keyboard_report();
    }
    else if IS_SYSTEM(code) {
    46b6:	0003      	movs	r3, r0
    46b8:	335b      	adds	r3, #91	; 0x5b
    46ba:	b2db      	uxtb	r3, r3
    46bc:	2b02      	cmp	r3, #2
    46be:	d84a      	bhi.n	4756 <register_code+0xc6>
        host_system_send(KEYCODE2SYSTEM(code));
    46c0:	28a5      	cmp	r0, #165	; 0xa5
    46c2:	d100      	bne.n	46c6 <register_code+0x36>
    46c4:	e087      	b.n	47d6 <register_code+0x146>
    46c6:	3ca6      	subs	r4, #166	; 0xa6
    46c8:	0020      	movs	r0, r4
    46ca:	1e44      	subs	r4, r0, #1
    46cc:	41a0      	sbcs	r0, r4
    46ce:	3082      	adds	r0, #130	; 0x82
    46d0:	f7ff fec6 	bl	4460 <host_system_send>
    }
    else if IS_CONSUMER(code) {
        host_consumer_send(KEYCODE2CONSUMER(code));
    }
}
    46d4:	bd10      	pop	{r4, pc}
        if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
    46d6:	f7ff fe63 	bl	43a0 <host_keyboard_leds>
    46da:	0783      	lsls	r3, r0, #30
    46dc:	d4fa      	bmi.n	46d4 <register_code+0x44>
        add_key(KC_CAPSLOCK);
    46de:	2039      	movs	r0, #57	; 0x39
    46e0:	f001 f88e 	bl	5800 <add_key>
        send_keyboard_report();
    46e4:	f001 f85c 	bl	57a0 <send_keyboard_report>
        wait_ms(100);
    46e8:	2064      	movs	r0, #100	; 0x64
    46ea:	f7fd f881 	bl	17f0 <chThdSleep>
        del_key(KC_CAPSLOCK);
    46ee:	2039      	movs	r0, #57	; 0x39
    46f0:	f001 f8d6 	bl	58a0 <del_key>
        send_keyboard_report();
    46f4:	f001 f854 	bl	57a0 <send_keyboard_report>
    46f8:	e7ec      	b.n	46d4 <register_code+0x44>
        if (command_proc(code)) return;
    46fa:	f002 ff49 	bl	7590 <command_proc>
    46fe:	2800      	cmp	r0, #0
    4700:	d1e8      	bne.n	46d4 <register_code+0x44>
            add_key(code);
    4702:	0020      	movs	r0, r4
    4704:	f001 f87c 	bl	5800 <add_key>
            send_keyboard_report();
    4708:	f001 f84a 	bl	57a0 <send_keyboard_report>
    470c:	e7e2      	b.n	46d4 <register_code+0x44>
        if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
    470e:	f7ff fe47 	bl	43a0 <host_keyboard_leds>
    4712:	07c3      	lsls	r3, r0, #31
    4714:	d4de      	bmi.n	46d4 <register_code+0x44>
        add_key(KC_NUMLOCK);
    4716:	2053      	movs	r0, #83	; 0x53
    4718:	f001 f872 	bl	5800 <add_key>
        send_keyboard_report();
    471c:	f001 f840 	bl	57a0 <send_keyboard_report>
        wait_ms(100);
    4720:	2064      	movs	r0, #100	; 0x64
    4722:	f7fd f865 	bl	17f0 <chThdSleep>
        del_key(KC_NUMLOCK);
    4726:	2053      	movs	r0, #83	; 0x53
    4728:	f001 f8ba 	bl	58a0 <del_key>
        send_keyboard_report();
    472c:	f001 f838 	bl	57a0 <send_keyboard_report>
    4730:	e7d0      	b.n	46d4 <register_code+0x44>
        if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
    4732:	f7ff fe35 	bl	43a0 <host_keyboard_leds>
    4736:	0743      	lsls	r3, r0, #29
    4738:	d4cc      	bmi.n	46d4 <register_code+0x44>
        add_key(KC_SCROLLLOCK);
    473a:	2047      	movs	r0, #71	; 0x47
    473c:	f001 f860 	bl	5800 <add_key>
        send_keyboard_report();
    4740:	f001 f82e 	bl	57a0 <send_keyboard_report>
        wait_ms(100);
    4744:	2064      	movs	r0, #100	; 0x64
    4746:	f7fd f853 	bl	17f0 <chThdSleep>
        del_key(KC_SCROLLLOCK);
    474a:	2047      	movs	r0, #71	; 0x47
    474c:	f001 f8a8 	bl	58a0 <del_key>
        send_keyboard_report();
    4750:	f001 f826 	bl	57a0 <send_keyboard_report>
    4754:	e7be      	b.n	46d4 <register_code+0x44>
    else if IS_CONSUMER(code) {
    4756:	0003      	movs	r3, r0
    4758:	3358      	adds	r3, #88	; 0x58
    475a:	b2db      	uxtb	r3, r3
    475c:	2b14      	cmp	r3, #20
    475e:	d8b9      	bhi.n	46d4 <register_code+0x44>
        host_consumer_send(KEYCODE2CONSUMER(code));
    4760:	28a8      	cmp	r0, #168	; 0xa8
    4762:	d03a      	beq.n	47da <register_code+0x14a>
    4764:	28a9      	cmp	r0, #169	; 0xa9
    4766:	d03a      	beq.n	47de <register_code+0x14e>
    4768:	28aa      	cmp	r0, #170	; 0xaa
    476a:	d03a      	beq.n	47e2 <register_code+0x152>
    476c:	28ab      	cmp	r0, #171	; 0xab
    476e:	d03a      	beq.n	47e6 <register_code+0x156>
    4770:	28ac      	cmp	r0, #172	; 0xac
    4772:	d03a      	beq.n	47ea <register_code+0x15a>
    4774:	28ad      	cmp	r0, #173	; 0xad
    4776:	d03a      	beq.n	47ee <register_code+0x15e>
    4778:	28ae      	cmp	r0, #174	; 0xae
    477a:	d03a      	beq.n	47f2 <register_code+0x162>
    477c:	28af      	cmp	r0, #175	; 0xaf
    477e:	d03a      	beq.n	47f6 <register_code+0x166>
    4780:	28b1      	cmp	r0, #177	; 0xb1
    4782:	d03a      	beq.n	47fa <register_code+0x16a>
    4784:	28b0      	cmp	r0, #176	; 0xb0
    4786:	d03a      	beq.n	47fe <register_code+0x16e>
    4788:	28b2      	cmp	r0, #178	; 0xb2
    478a:	d03a      	beq.n	4802 <register_code+0x172>
    478c:	28b3      	cmp	r0, #179	; 0xb3
    478e:	d03b      	beq.n	4808 <register_code+0x178>
    4790:	28b4      	cmp	r0, #180	; 0xb4
    4792:	d03f      	beq.n	4814 <register_code+0x184>
    4794:	28b5      	cmp	r0, #181	; 0xb5
    4796:	d03a      	beq.n	480e <register_code+0x17e>
    4798:	28b6      	cmp	r0, #182	; 0xb6
    479a:	d040      	beq.n	481e <register_code+0x18e>
    479c:	28b7      	cmp	r0, #183	; 0xb7
    479e:	d03c      	beq.n	481a <register_code+0x18a>
    47a0:	28b8      	cmp	r0, #184	; 0xb8
    47a2:	d044      	beq.n	482e <register_code+0x19e>
    47a4:	28b9      	cmp	r0, #185	; 0xb9
    47a6:	d040      	beq.n	482a <register_code+0x19a>
    47a8:	28ba      	cmp	r0, #186	; 0xba
    47aa:	d03c      	beq.n	4826 <register_code+0x196>
    47ac:	28bb      	cmp	r0, #187	; 0xbb
    47ae:	d038      	beq.n	4822 <register_code+0x192>
    47b0:	3cbc      	subs	r4, #188	; 0xbc
    47b2:	4260      	negs	r0, r4
    47b4:	4160      	adcs	r0, r4
    47b6:	4b1f      	ldr	r3, [pc, #124]	; (4834 <register_code+0x1a4>)
    47b8:	4240      	negs	r0, r0
    47ba:	4018      	ands	r0, r3
    47bc:	f7ff fe78 	bl	44b0 <host_consumer_send>
    47c0:	e788      	b.n	46d4 <register_code+0x44>
        add_mods(MOD_BIT(code));
    47c2:	2307      	movs	r3, #7
    47c4:	2001      	movs	r0, #1
    47c6:	401c      	ands	r4, r3
    47c8:	40a0      	lsls	r0, r4
    47ca:	b2c0      	uxtb	r0, r0
    47cc:	f001 f8b8 	bl	5940 <add_mods>
        send_keyboard_report();
    47d0:	f000 ffe6 	bl	57a0 <send_keyboard_report>
    47d4:	e77e      	b.n	46d4 <register_code+0x44>
        host_system_send(KEYCODE2SYSTEM(code));
    47d6:	2081      	movs	r0, #129	; 0x81
    47d8:	e77a      	b.n	46d0 <register_code+0x40>
        host_consumer_send(KEYCODE2CONSUMER(code));
    47da:	20e2      	movs	r0, #226	; 0xe2
    47dc:	e7ee      	b.n	47bc <register_code+0x12c>
    47de:	20e9      	movs	r0, #233	; 0xe9
    47e0:	e7ec      	b.n	47bc <register_code+0x12c>
    47e2:	20ea      	movs	r0, #234	; 0xea
    47e4:	e7ea      	b.n	47bc <register_code+0x12c>
    47e6:	20b5      	movs	r0, #181	; 0xb5
    47e8:	e7e8      	b.n	47bc <register_code+0x12c>
    47ea:	20b6      	movs	r0, #182	; 0xb6
    47ec:	e7e6      	b.n	47bc <register_code+0x12c>
    47ee:	20b3      	movs	r0, #179	; 0xb3
    47f0:	e7e4      	b.n	47bc <register_code+0x12c>
    47f2:	20b4      	movs	r0, #180	; 0xb4
    47f4:	e7e2      	b.n	47bc <register_code+0x12c>
    47f6:	20b7      	movs	r0, #183	; 0xb7
    47f8:	e7e0      	b.n	47bc <register_code+0x12c>
    47fa:	20cc      	movs	r0, #204	; 0xcc
    47fc:	e7de      	b.n	47bc <register_code+0x12c>
    47fe:	20cd      	movs	r0, #205	; 0xcd
    4800:	e7dc      	b.n	47bc <register_code+0x12c>
    4802:	2084      	movs	r0, #132	; 0x84
    4804:	30ff      	adds	r0, #255	; 0xff
    4806:	e7d9      	b.n	47bc <register_code+0x12c>
    4808:	20c5      	movs	r0, #197	; 0xc5
    480a:	0040      	lsls	r0, r0, #1
    480c:	e7d6      	b.n	47bc <register_code+0x12c>
    480e:	20ca      	movs	r0, #202	; 0xca
    4810:	0040      	lsls	r0, r0, #1
    4812:	e7d3      	b.n	47bc <register_code+0x12c>
    4814:	20c9      	movs	r0, #201	; 0xc9
    4816:	0040      	lsls	r0, r0, #1
    4818:	e7d0      	b.n	47bc <register_code+0x12c>
    481a:	4807      	ldr	r0, [pc, #28]	; (4838 <register_code+0x1a8>)
    481c:	e7ce      	b.n	47bc <register_code+0x12c>
    481e:	4807      	ldr	r0, [pc, #28]	; (483c <register_code+0x1ac>)
    4820:	e7cc      	b.n	47bc <register_code+0x12c>
    4822:	4807      	ldr	r0, [pc, #28]	; (4840 <register_code+0x1b0>)
    4824:	e7ca      	b.n	47bc <register_code+0x12c>
    4826:	4807      	ldr	r0, [pc, #28]	; (4844 <register_code+0x1b4>)
    4828:	e7c8      	b.n	47bc <register_code+0x12c>
    482a:	4807      	ldr	r0, [pc, #28]	; (4848 <register_code+0x1b8>)
    482c:	e7c6      	b.n	47bc <register_code+0x12c>
    482e:	2089      	movs	r0, #137	; 0x89
    4830:	0080      	lsls	r0, r0, #2
    4832:	e7c3      	b.n	47bc <register_code+0x12c>
    4834:	0000022a 	.word	0x0000022a
    4838:	00000223 	.word	0x00000223
    483c:	00000221 	.word	0x00000221
    4840:	00000227 	.word	0x00000227
    4844:	00000226 	.word	0x00000226
    4848:	00000225 	.word	0x00000225
    484c:	00000000 	.word	0x00000000

00004850 <unregister_code>:

void unregister_code(uint8_t code)
{
    4850:	b510      	push	{r4, lr}
    if (code == KC_NO) {
    4852:	2800      	cmp	r0, #0
    4854:	d017      	beq.n	4886 <unregister_code+0x36>
        return;
    }

#ifdef LOCKING_SUPPORT_ENABLE
    else if (KC_LOCKING_CAPS == code) {
    4856:	2882      	cmp	r0, #130	; 0x82
    4858:	d016      	beq.n	4888 <unregister_code+0x38>
        wait_ms(100);
        del_key(KC_CAPSLOCK);
        send_keyboard_report();
    }

    else if (KC_LOCKING_NUM == code) {
    485a:	2883      	cmp	r0, #131	; 0x83
    485c:	d02b      	beq.n	48b6 <unregister_code+0x66>
        wait_ms(100);
        del_key(KC_NUMLOCK);
        send_keyboard_report();
    }

    else if (KC_LOCKING_SCROLL == code) {
    485e:	2884      	cmp	r0, #132	; 0x84
    4860:	d03b      	beq.n	48da <unregister_code+0x8a>
        del_key(KC_SCROLLLOCK);
        send_keyboard_report();
    }
#endif

    else if IS_KEY(code) {
    4862:	1f03      	subs	r3, r0, #4
    4864:	b2db      	uxtb	r3, r3
    4866:	2ba0      	cmp	r3, #160	; 0xa0
    4868:	d920      	bls.n	48ac <unregister_code+0x5c>
        del_key(code);
        send_keyboard_report();
    }
    else if IS_MOD(code) {
    486a:	0003      	movs	r3, r0
    486c:	3320      	adds	r3, #32
    486e:	b2db      	uxtb	r3, r3
    4870:	2b07      	cmp	r3, #7
    4872:	d944      	bls.n	48fe <unregister_code+0xae>
        del_mods(MOD_BIT(code));
        send_keyboard_report();
    }
    else if IS_SYSTEM(code) {
    4874:	0003      	movs	r3, r0
    4876:	335b      	adds	r3, #91	; 0x5b
    4878:	b2db      	uxtb	r3, r3
    487a:	2b02      	cmp	r3, #2
    487c:	d94d      	bls.n	491a <unregister_code+0xca>
        host_system_send(0);
    }
    else if IS_CONSUMER(code) {
    487e:	3058      	adds	r0, #88	; 0x58
    4880:	b2c0      	uxtb	r0, r0
    4882:	2814      	cmp	r0, #20
    4884:	d945      	bls.n	4912 <unregister_code+0xc2>
        host_consumer_send(0);
    }
}
    4886:	bd10      	pop	{r4, pc}
        if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
    4888:	f7ff fd8a 	bl	43a0 <host_keyboard_leds>
    488c:	0783      	lsls	r3, r0, #30
    488e:	d5fa      	bpl.n	4886 <unregister_code+0x36>
        add_key(KC_CAPSLOCK);
    4890:	2039      	movs	r0, #57	; 0x39
    4892:	f000 ffb5 	bl	5800 <add_key>
        send_keyboard_report();
    4896:	f000 ff83 	bl	57a0 <send_keyboard_report>
        wait_ms(100);
    489a:	2064      	movs	r0, #100	; 0x64
    489c:	f7fc ffa8 	bl	17f0 <chThdSleep>
        del_key(KC_CAPSLOCK);
    48a0:	2039      	movs	r0, #57	; 0x39
    48a2:	f000 fffd 	bl	58a0 <del_key>
        send_keyboard_report();
    48a6:	f000 ff7b 	bl	57a0 <send_keyboard_report>
    48aa:	e7ec      	b.n	4886 <unregister_code+0x36>
        del_key(code);
    48ac:	f000 fff8 	bl	58a0 <del_key>
        send_keyboard_report();
    48b0:	f000 ff76 	bl	57a0 <send_keyboard_report>
    48b4:	e7e7      	b.n	4886 <unregister_code+0x36>
        if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
    48b6:	f7ff fd73 	bl	43a0 <host_keyboard_leds>
    48ba:	07c3      	lsls	r3, r0, #31
    48bc:	d5e3      	bpl.n	4886 <unregister_code+0x36>
        add_key(KC_NUMLOCK);
    48be:	2053      	movs	r0, #83	; 0x53
    48c0:	f000 ff9e 	bl	5800 <add_key>
        send_keyboard_report();
    48c4:	f000 ff6c 	bl	57a0 <send_keyboard_report>
        wait_ms(100);
    48c8:	2064      	movs	r0, #100	; 0x64
    48ca:	f7fc ff91 	bl	17f0 <chThdSleep>
        del_key(KC_NUMLOCK);
    48ce:	2053      	movs	r0, #83	; 0x53
    48d0:	f000 ffe6 	bl	58a0 <del_key>
        send_keyboard_report();
    48d4:	f000 ff64 	bl	57a0 <send_keyboard_report>
    48d8:	e7d5      	b.n	4886 <unregister_code+0x36>
        if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
    48da:	f7ff fd61 	bl	43a0 <host_keyboard_leds>
    48de:	0743      	lsls	r3, r0, #29
    48e0:	d5d1      	bpl.n	4886 <unregister_code+0x36>
        add_key(KC_SCROLLLOCK);
    48e2:	2047      	movs	r0, #71	; 0x47
    48e4:	f000 ff8c 	bl	5800 <add_key>
        send_keyboard_report();
    48e8:	f000 ff5a 	bl	57a0 <send_keyboard_report>
        wait_ms(100);
    48ec:	2064      	movs	r0, #100	; 0x64
    48ee:	f7fc ff7f 	bl	17f0 <chThdSleep>
        del_key(KC_SCROLLLOCK);
    48f2:	2047      	movs	r0, #71	; 0x47
    48f4:	f000 ffd4 	bl	58a0 <del_key>
        send_keyboard_report();
    48f8:	f000 ff52 	bl	57a0 <send_keyboard_report>
    48fc:	e7c3      	b.n	4886 <unregister_code+0x36>
        del_mods(MOD_BIT(code));
    48fe:	2307      	movs	r3, #7
    4900:	4003      	ands	r3, r0
    4902:	2001      	movs	r0, #1
    4904:	4098      	lsls	r0, r3
    4906:	b2c0      	uxtb	r0, r0
    4908:	f001 f822 	bl	5950 <del_mods>
        send_keyboard_report();
    490c:	f000 ff48 	bl	57a0 <send_keyboard_report>
    4910:	e7b9      	b.n	4886 <unregister_code+0x36>
        host_consumer_send(0);
    4912:	2000      	movs	r0, #0
    4914:	f7ff fdcc 	bl	44b0 <host_consumer_send>
    4918:	e7b5      	b.n	4886 <unregister_code+0x36>
        host_system_send(0);
    491a:	2000      	movs	r0, #0
    491c:	f7ff fda0 	bl	4460 <host_system_send>
    4920:	e7b1      	b.n	4886 <unregister_code+0x36>
    4922:	46c0      	nop			; (mov r8, r8)
	...

00004930 <process_action>:
{
    4930:	b5f0      	push	{r4, r5, r6, r7, lr}
    4932:	46c6      	mov	lr, r8
    4934:	b500      	push	{lr}
    4936:	b084      	sub	sp, #16
    4938:	0004      	movs	r4, r0
    keyevent_t event = record->event;
    493a:	ad02      	add	r5, sp, #8
    493c:	0001      	movs	r1, r0
    493e:	2206      	movs	r2, #6
    4940:	0028      	movs	r0, r5
    4942:	f002 ffcd 	bl	78e0 <memcpy>
    4946:	4669      	mov	r1, sp
    uint8_t tap_count = record->tap.count;
    4948:	79a6      	ldrb	r6, [r4, #6]
    494a:	882a      	ldrh	r2, [r5, #0]
    keyevent_t event = record->event;
    494c:	88a3      	ldrh	r3, [r4, #4]
    494e:	78a7      	ldrb	r7, [r4, #2]
    uint8_t tap_count = record->tap.count;
    4950:	0936      	lsrs	r6, r6, #4
    4952:	808a      	strh	r2, [r1, #4]
    4954:	2b00      	cmp	r3, #0
    4956:	d035      	beq.n	49c4 <process_action+0x94>
    4958:	4bb6      	ldr	r3, [pc, #728]	; (4c34 <process_action+0x304>)
    495a:	b292      	uxth	r2, r2
    495c:	429a      	cmp	r2, r3
    495e:	d031      	beq.n	49c4 <process_action+0x94>
    action_t action = layer_switch_get_action(event.key);
    4960:	6828      	ldr	r0, [r5, #0]
    4962:	f000 fef5 	bl	5750 <layer_switch_get_action>
    4966:	1c05      	adds	r5, r0, #0
    dprint(" layer_state: "); layer_debug();
    4968:	f000 feea 	bl	5740 <layer_debug>
    dprint(" default_layer_state: "); default_layer_debug();
    496c:	f000 fe20 	bl	55b0 <default_layer_debug>
    switch (action.kind.id) {
    4970:	042a      	lsls	r2, r5, #16
    4972:	0f13      	lsrs	r3, r2, #28
    4974:	49b0      	ldr	r1, [pc, #704]	; (4c38 <process_action+0x308>)
    4976:	009b      	lsls	r3, r3, #2
    4978:	58cb      	ldr	r3, [r1, r3]
    497a:	469f      	mov	pc, r3
    497c:	05aa      	lsls	r2, r5, #22
    497e:	0f92      	lsrs	r2, r2, #30
    4980:	b2d3      	uxtb	r3, r2
                if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
    4982:	085b      	lsrs	r3, r3, #1
    4984:	2f00      	cmp	r7, #0
    4986:	d001      	beq.n	498c <process_action+0x5c>
    4988:	2301      	movs	r3, #1
    498a:	4013      	ands	r3, r2
    498c:	2b00      	cmp	r3, #0
    498e:	d019      	beq.n	49c4 <process_action+0x94>
                    uint8_t shift = action.layer_bitop.part*4;
    4990:	062b      	lsls	r3, r5, #24
    4992:	0f5b      	lsrs	r3, r3, #29
                    uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
    4994:	0728      	lsls	r0, r5, #28
    4996:	009b      	lsls	r3, r3, #2
    4998:	0f00      	lsrs	r0, r0, #28
    499a:	4098      	lsls	r0, r3
    499c:	0004      	movs	r4, r0
                    uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
    499e:	2000      	movs	r0, #0
    49a0:	06ea      	lsls	r2, r5, #27
    49a2:	d502      	bpl.n	49aa <process_action+0x7a>
    49a4:	300f      	adds	r0, #15
    49a6:	4098      	lsls	r0, r3
    49a8:	43c0      	mvns	r0, r0
                    switch (action.layer_bitop.op) {
    49aa:	052d      	lsls	r5, r5, #20
    49ac:	0fad      	lsrs	r5, r5, #30
    49ae:	2d02      	cmp	r5, #2
    49b0:	d100      	bne.n	49b4 <process_action+0x84>
    49b2:	e15e      	b.n	4c72 <process_action+0x342>
    49b4:	d900      	bls.n	49b8 <process_action+0x88>
    49b6:	e12d      	b.n	4c14 <process_action+0x2e4>
                        case OP_BIT_OR:  layer_or(bits | mask);  break;
    49b8:	4320      	orrs	r0, r4
                    switch (action.layer_bitop.op) {
    49ba:	2d01      	cmp	r5, #1
    49bc:	d100      	bne.n	49c0 <process_action+0x90>
    49be:	e12c      	b.n	4c1a <process_action+0x2ea>
                        case OP_BIT_AND: layer_and(bits | mask); break;
    49c0:	f000 fe9e 	bl	5700 <layer_and>
}
    49c4:	b004      	add	sp, #16
    49c6:	bc04      	pop	{r2}
    49c8:	4690      	mov	r8, r2
    49ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
            action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
    49cc:	052a      	lsls	r2, r5, #20
    49ce:	0f12      	lsrs	r2, r2, #28
    49d0:	b2e9      	uxtb	r1, r5
    49d2:	0020      	movs	r0, r4
    49d4:	f7ff faac 	bl	3f30 <action_get_macro>
    49d8:	f000 fd52 	bl	5480 <action_macro_play>
            break;
    49dc:	e7f2      	b.n	49c4 <process_action+0x94>
                uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
    49de:	230f      	movs	r3, #15
    49e0:	052c      	lsls	r4, r5, #20
    49e2:	0e12      	lsrs	r2, r2, #24
    49e4:	0f24      	lsrs	r4, r4, #28
    49e6:	439a      	bics	r2, r3
    49e8:	d000      	beq.n	49ec <process_action+0xbc>
    49ea:	0124      	lsls	r4, r4, #4
    49ec:	b2ed      	uxtb	r5, r5
                if (event.pressed) {
    49ee:	2f00      	cmp	r7, #0
    49f0:	d100      	bne.n	49f4 <process_action+0xc4>
    49f2:	e0dc      	b.n	4bae <process_action+0x27e>
                    if (mods) {
    49f4:	2c00      	cmp	r4, #0
    49f6:	d000      	beq.n	49fa <process_action+0xca>
    49f8:	e0e5      	b.n	4bc6 <process_action+0x296>
                    register_code(action.key.code);
    49fa:	0028      	movs	r0, r5
    49fc:	f7ff fe48 	bl	4690 <register_code>
    4a00:	e7e0      	b.n	49c4 <process_action+0x94>
    4a02:	052b      	lsls	r3, r5, #20
    4a04:	0f1b      	lsrs	r3, r3, #28
    4a06:	4698      	mov	r8, r3
                uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
    4a08:	230f      	movs	r3, #15
    4a0a:	0e12      	lsrs	r2, r2, #24
    4a0c:	439a      	bics	r2, r3
    4a0e:	2a20      	cmp	r2, #32
    4a10:	d002      	beq.n	4a18 <process_action+0xe8>
    4a12:	4643      	mov	r3, r8
    4a14:	011b      	lsls	r3, r3, #4
    4a16:	4698      	mov	r8, r3
                switch (action.key.code) {
    4a18:	b2e8      	uxtb	r0, r5
    4a1a:	2800      	cmp	r0, #0
    4a1c:	d100      	bne.n	4a20 <process_action+0xf0>
    4a1e:	e0bb      	b.n	4b98 <process_action+0x268>
    4a20:	2801      	cmp	r0, #1
    4a22:	d000      	beq.n	4a26 <process_action+0xf6>
    4a24:	e0a4      	b.n	4b70 <process_action+0x240>
                        if (event.pressed) {
    4a26:	2f00      	cmp	r7, #0
    4a28:	d100      	bne.n	4a2c <process_action+0xfc>
    4a2a:	e0e2      	b.n	4bf2 <process_action+0x2c2>
                            if (tap_count <= TAPPING_TOGGLE) {
    4a2c:	2e05      	cmp	r6, #5
    4a2e:	d8c9      	bhi.n	49c4 <process_action+0x94>
                                if (mods & get_mods()) {
    4a30:	f000 ff7e 	bl	5930 <get_mods>
    4a34:	4643      	mov	r3, r8
    4a36:	4203      	tst	r3, r0
    4a38:	d100      	bne.n	4a3c <process_action+0x10c>
    4a3a:	e0b3      	b.n	4ba4 <process_action+0x274>
}

void unregister_mods(uint8_t mods)
{
    if (mods) {
        del_mods(mods);
    4a3c:	4640      	mov	r0, r8
    4a3e:	f000 ff87 	bl	5950 <del_mods>
        send_keyboard_report();
    4a42:	f000 fead 	bl	57a0 <send_keyboard_report>
    4a46:	e7bd      	b.n	49c4 <process_action+0x94>
            switch (action.usage.page) {
    4a48:	052b      	lsls	r3, r5, #20
    4a4a:	0f9b      	lsrs	r3, r3, #30
    4a4c:	d100      	bne.n	4a50 <process_action+0x120>
    4a4e:	e088      	b.n	4b62 <process_action+0x232>
    4a50:	2b01      	cmp	r3, #1
    4a52:	d1b7      	bne.n	49c4 <process_action+0x94>
                    if (event.pressed) {
    4a54:	2f00      	cmp	r7, #0
    4a56:	d100      	bne.n	4a5a <process_action+0x12a>
    4a58:	e0c7      	b.n	4bea <process_action+0x2ba>
                        host_consumer_send(action.usage.code);
    4a5a:	05a8      	lsls	r0, r5, #22
    4a5c:	0d80      	lsrs	r0, r0, #22
    4a5e:	f7ff fd27 	bl	44b0 <host_consumer_send>
    4a62:	e7af      	b.n	49c4 <process_action+0x94>
    4a64:	b2e8      	uxtb	r0, r5
            if (event.pressed) {
    4a66:	2f00      	cmp	r7, #0
    4a68:	d076      	beq.n	4b58 <process_action+0x228>
                mousekey_on(action.key.code);
    4a6a:	f002 f811 	bl	6a90 <mousekey_on>
                mousekey_send();
    4a6e:	f002 f927 	bl	6cc0 <mousekey_send>
    4a72:	e7a7      	b.n	49c4 <process_action+0x94>
            if (action.layer_bitop.on == 0) {
    4a74:	0192      	lsls	r2, r2, #6
    4a76:	0f92      	lsrs	r2, r2, #30
    4a78:	d000      	beq.n	4a7c <process_action+0x14c>
    4a7a:	e77f      	b.n	497c <process_action+0x4c>
                if (!event.pressed) {
    4a7c:	2f00      	cmp	r7, #0
    4a7e:	d1a1      	bne.n	49c4 <process_action+0x94>
                    uint8_t shift = action.layer_bitop.part*4;
    4a80:	062b      	lsls	r3, r5, #24
    4a82:	0f5b      	lsrs	r3, r3, #29
                    uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
    4a84:	0728      	lsls	r0, r5, #28
    4a86:	009b      	lsls	r3, r3, #2
    4a88:	0f00      	lsrs	r0, r0, #28
    4a8a:	4098      	lsls	r0, r3
    4a8c:	0004      	movs	r4, r0
                    uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
    4a8e:	2000      	movs	r0, #0
    4a90:	06ea      	lsls	r2, r5, #27
    4a92:	d502      	bpl.n	4a9a <process_action+0x16a>
    4a94:	300f      	adds	r0, #15
    4a96:	4098      	lsls	r0, r3
    4a98:	43c0      	mvns	r0, r0
                    switch (action.layer_bitop.op) {
    4a9a:	052d      	lsls	r5, r5, #20
    4a9c:	0fad      	lsrs	r5, r5, #30
    4a9e:	2d02      	cmp	r5, #2
    4aa0:	d100      	bne.n	4aa4 <process_action+0x174>
    4aa2:	e0e2      	b.n	4c6a <process_action+0x33a>
    4aa4:	d900      	bls.n	4aa8 <process_action+0x178>
    4aa6:	e0bb      	b.n	4c20 <process_action+0x2f0>
                        case OP_BIT_OR:  default_layer_or(bits | mask);  break;
    4aa8:	4320      	orrs	r0, r4
                    switch (action.layer_bitop.op) {
    4aaa:	2d01      	cmp	r5, #1
    4aac:	d100      	bne.n	4ab0 <process_action+0x180>
    4aae:	e0ba      	b.n	4c26 <process_action+0x2f6>
                        case OP_BIT_AND: default_layer_and(bits | mask); break;
    4ab0:	f000 fda6 	bl	5600 <default_layer_and>
    4ab4:	e786      	b.n	49c4 <process_action+0x94>
            switch (action.layer_tap.code) {
    4ab6:	b2ec      	uxtb	r4, r5
    4ab8:	0023      	movs	r3, r4
    4aba:	3340      	adds	r3, #64	; 0x40
    4abc:	b2db      	uxtb	r3, r3
    4abe:	2b33      	cmp	r3, #51	; 0x33
    4ac0:	d840      	bhi.n	4b44 <process_action+0x214>
    4ac2:	4a5e      	ldr	r2, [pc, #376]	; (4c3c <process_action+0x30c>)
    4ac4:	009b      	lsls	r3, r3, #2
    4ac6:	58d3      	ldr	r3, [r2, r3]
    4ac8:	469f      	mov	pc, r3
            action_function(record, action.func.id, action.func.opt);
    4aca:	052a      	lsls	r2, r5, #20
    4acc:	0f12      	lsrs	r2, r2, #28
    4ace:	b2e9      	uxtb	r1, r5
    4ad0:	0020      	movs	r0, r4
    4ad2:	f001 f83d 	bl	5b50 <action_function>
            break;
    4ad6:	e775      	b.n	49c4 <process_action+0x94>
                    event.pressed ? layer_move(action.layer_tap.val) :
    4ad8:	2f00      	cmp	r7, #0
    4ada:	d100      	bne.n	4ade <process_action+0x1ae>
    4adc:	e0c2      	b.n	4c64 <process_action+0x334>
    4ade:	04e8      	lsls	r0, r5, #19
    4ae0:	0ec0      	lsrs	r0, r0, #27
    4ae2:	f000 fdbd 	bl	5660 <layer_move>
    4ae6:	e76d      	b.n	49c4 <process_action+0x94>
    4ae8:	04e8      	lsls	r0, r5, #19
    4aea:	0ec0      	lsrs	r0, r0, #27
                    event.pressed ? layer_off(action.layer_tap.val) :
    4aec:	2f00      	cmp	r7, #0
    4aee:	d006      	beq.n	4afe <process_action+0x1ce>
                            layer_off(action.layer_tap.val);
    4af0:	f000 fdd6 	bl	56a0 <layer_off>
    4af4:	e766      	b.n	49c4 <process_action+0x94>
    4af6:	04e8      	lsls	r0, r5, #19
    4af8:	0ec0      	lsrs	r0, r0, #27
                    event.pressed ? layer_on(action.layer_tap.val) :
    4afa:	2f00      	cmp	r7, #0
    4afc:	d0f8      	beq.n	4af0 <process_action+0x1c0>
                            layer_on(action.layer_tap.val);
    4afe:	f000 fdbf 	bl	5680 <layer_on>
    4b02:	e75f      	b.n	49c4 <process_action+0x94>
    4b04:	2610      	movs	r6, #16
    4b06:	04e8      	lsls	r0, r5, #19
    4b08:	0ec0      	lsrs	r0, r0, #27
    4b0a:	4026      	ands	r6, r4
                    if (event.pressed) {
    4b0c:	2f00      	cmp	r7, #0
    4b0e:	d100      	bne.n	4b12 <process_action+0x1e2>
    4b10:	e096      	b.n	4c40 <process_action+0x310>
                        layer_on(action.layer_tap.val);
    4b12:	f000 fdb5 	bl	5680 <layer_on>
                        register_mods((action.layer_tap.code & 0x10) ?
    4b16:	2e00      	cmp	r6, #0
    4b18:	d100      	bne.n	4b1c <process_action+0x1ec>
    4b1a:	e0ae      	b.n	4c7a <process_action+0x34a>
                                (action.layer_tap.code & 0x0f) << 4 :
    4b1c:	0124      	lsls	r4, r4, #4
                        register_mods((action.layer_tap.code & 0x10) ?
    4b1e:	b2e0      	uxtb	r0, r4
    if (mods) {
    4b20:	2800      	cmp	r0, #0
    4b22:	d100      	bne.n	4b26 <process_action+0x1f6>
    4b24:	e74e      	b.n	49c4 <process_action+0x94>
        add_mods(mods);
    4b26:	f000 ff0b 	bl	5940 <add_mods>
        send_keyboard_report();
    4b2a:	f000 fe39 	bl	57a0 <send_keyboard_report>
    4b2e:	e749      	b.n	49c4 <process_action+0x94>
                    if (event.pressed) {
    4b30:	2f00      	cmp	r7, #0
    4b32:	d07b      	beq.n	4c2c <process_action+0x2fc>
                        if (tap_count < TAPPING_TOGGLE) {
    4b34:	2e04      	cmp	r6, #4
    4b36:	d900      	bls.n	4b3a <process_action+0x20a>
    4b38:	e744      	b.n	49c4 <process_action+0x94>
                            layer_invert(action.layer_tap.val);
    4b3a:	04e8      	lsls	r0, r5, #19
    4b3c:	0ec0      	lsrs	r0, r0, #27
    4b3e:	f000 fdbf 	bl	56c0 <layer_invert>
    4b42:	e73f      	b.n	49c4 <process_action+0x94>
                    if (event.pressed) {
    4b44:	2f00      	cmp	r7, #0
    4b46:	d100      	bne.n	4b4a <process_action+0x21a>
    4b48:	e088      	b.n	4c5c <process_action+0x32c>
                        if (tap_count > 0) {
    4b4a:	2e00      	cmp	r6, #0
    4b4c:	d100      	bne.n	4b50 <process_action+0x220>
    4b4e:	e097      	b.n	4c80 <process_action+0x350>
                            register_code(action.layer_tap.code);
    4b50:	0020      	movs	r0, r4
    4b52:	f7ff fd9d 	bl	4690 <register_code>
    4b56:	e735      	b.n	49c4 <process_action+0x94>
                mousekey_off(action.key.code);
    4b58:	f002 f822 	bl	6ba0 <mousekey_off>
                mousekey_send();
    4b5c:	f002 f8b0 	bl	6cc0 <mousekey_send>
    4b60:	e730      	b.n	49c4 <process_action+0x94>
                    if (event.pressed) {
    4b62:	2f00      	cmp	r7, #0
    4b64:	d04d      	beq.n	4c02 <process_action+0x2d2>
                        host_system_send(action.usage.code);
    4b66:	05a8      	lsls	r0, r5, #22
    4b68:	0d80      	lsrs	r0, r0, #22
    4b6a:	f7ff fc79 	bl	4460 <host_system_send>
    4b6e:	e729      	b.n	49c4 <process_action+0x94>
                        if (event.pressed) {
    4b70:	2f00      	cmp	r7, #0
    4b72:	d04a      	beq.n	4c0a <process_action+0x2da>
                            if (tap_count > 0) {
    4b74:	2e00      	cmp	r6, #0
    4b76:	d015      	beq.n	4ba4 <process_action+0x274>
                                if (record->tap.interrupted) {
    4b78:	79a2      	ldrb	r2, [r4, #6]
    4b7a:	07d3      	lsls	r3, r2, #31
    4b7c:	d5e9      	bpl.n	4b52 <process_action+0x222>
                                    record->tap.count = 0;
    4b7e:	230f      	movs	r3, #15
    4b80:	4013      	ands	r3, r2
    4b82:	71a3      	strb	r3, [r4, #6]
    if (mods) {
    4b84:	4643      	mov	r3, r8
    4b86:	2b00      	cmp	r3, #0
    4b88:	d100      	bne.n	4b8c <process_action+0x25c>
    4b8a:	e71b      	b.n	49c4 <process_action+0x94>
        add_mods(mods);
    4b8c:	4640      	mov	r0, r8
    4b8e:	f000 fed7 	bl	5940 <add_mods>
        send_keyboard_report();
    4b92:	f000 fe05 	bl	57a0 <send_keyboard_report>
    4b96:	e715      	b.n	49c4 <process_action+0x94>
                        if (event.pressed) {
    4b98:	2f00      	cmp	r7, #0
    4b9a:	d01a      	beq.n	4bd2 <process_action+0x2a2>
                            if (tap_count == 0) {
    4b9c:	2e00      	cmp	r6, #0
    4b9e:	d001      	beq.n	4ba4 <process_action+0x274>
                            else if (tap_count == 1) {
    4ba0:	2e01      	cmp	r6, #1
    4ba2:	d076      	beq.n	4c92 <process_action+0x362>
    if (mods) {
    4ba4:	4643      	mov	r3, r8
    4ba6:	2b00      	cmp	r3, #0
    4ba8:	d100      	bne.n	4bac <process_action+0x27c>
    4baa:	e70b      	b.n	49c4 <process_action+0x94>
    4bac:	e7ee      	b.n	4b8c <process_action+0x25c>
                    unregister_code(action.key.code);
    4bae:	0028      	movs	r0, r5
    4bb0:	f7ff fe4e 	bl	4850 <unregister_code>
                    if (mods) {
    4bb4:	2c00      	cmp	r4, #0
    4bb6:	d100      	bne.n	4bba <process_action+0x28a>
    4bb8:	e704      	b.n	49c4 <process_action+0x94>
                        del_weak_mods(mods);
    4bba:	0020      	movs	r0, r4
    4bbc:	f000 fee8 	bl	5990 <del_weak_mods>
                        send_keyboard_report();
    4bc0:	f000 fdee 	bl	57a0 <send_keyboard_report>
    4bc4:	e6fe      	b.n	49c4 <process_action+0x94>
                        add_weak_mods(mods);
    4bc6:	0020      	movs	r0, r4
    4bc8:	f000 feda 	bl	5980 <add_weak_mods>
                        send_keyboard_report();
    4bcc:	f000 fde8 	bl	57a0 <send_keyboard_report>
    4bd0:	e713      	b.n	49fa <process_action+0xca>
                            if (tap_count == 0) {
    4bd2:	2e00      	cmp	r6, #0
    4bd4:	d002      	beq.n	4bdc <process_action+0x2ac>
                            else if (tap_count == 1) {
    4bd6:	2e01      	cmp	r6, #1
    4bd8:	d100      	bne.n	4bdc <process_action+0x2ac>
    4bda:	e6f3      	b.n	49c4 <process_action+0x94>
                                clear_oneshot_mods();
    4bdc:	f000 fef0 	bl	59c0 <clear_oneshot_mods>
    if (mods) {
    4be0:	4643      	mov	r3, r8
    4be2:	2b00      	cmp	r3, #0
    4be4:	d100      	bne.n	4be8 <process_action+0x2b8>
    4be6:	e6ed      	b.n	49c4 <process_action+0x94>
    4be8:	e728      	b.n	4a3c <process_action+0x10c>
                        host_consumer_send(0);
    4bea:	2000      	movs	r0, #0
    4bec:	f7ff fc60 	bl	44b0 <host_consumer_send>
    4bf0:	e6e8      	b.n	49c4 <process_action+0x94>
                            if (tap_count < TAPPING_TOGGLE) {
    4bf2:	2e04      	cmp	r6, #4
    4bf4:	d900      	bls.n	4bf8 <process_action+0x2c8>
    4bf6:	e6e5      	b.n	49c4 <process_action+0x94>
    if (mods) {
    4bf8:	4643      	mov	r3, r8
    4bfa:	2b00      	cmp	r3, #0
    4bfc:	d100      	bne.n	4c00 <process_action+0x2d0>
    4bfe:	e6e1      	b.n	49c4 <process_action+0x94>
    4c00:	e71c      	b.n	4a3c <process_action+0x10c>
                        host_system_send(0);
    4c02:	2000      	movs	r0, #0
    4c04:	f7ff fc2c 	bl	4460 <host_system_send>
    4c08:	e6dc      	b.n	49c4 <process_action+0x94>
                            if (tap_count > 0) {
    4c0a:	2e00      	cmp	r6, #0
    4c0c:	d0f4      	beq.n	4bf8 <process_action+0x2c8>
                            unregister_code(action.layer_tap.code);
    4c0e:	f7ff fe1f 	bl	4850 <unregister_code>
    4c12:	e6d7      	b.n	49c4 <process_action+0x94>
                        case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
    4c14:	f000 fd74 	bl	5700 <layer_and>
    4c18:	0020      	movs	r0, r4
    4c1a:	f000 fd61 	bl	56e0 <layer_or>
    4c1e:	e6d1      	b.n	49c4 <process_action+0x94>
                        case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
    4c20:	f000 fcee 	bl	5600 <default_layer_and>
    4c24:	0020      	movs	r0, r4
    4c26:	f000 fcdb 	bl	55e0 <default_layer_or>
    4c2a:	e6cb      	b.n	49c4 <process_action+0x94>
                        if (tap_count <= TAPPING_TOGGLE) {
    4c2c:	2e05      	cmp	r6, #5
    4c2e:	d900      	bls.n	4c32 <process_action+0x302>
    4c30:	e6c8      	b.n	49c4 <process_action+0x94>
    4c32:	e782      	b.n	4b3a <process_action+0x20a>
    4c34:	0000ffff 	.word	0x0000ffff
    4c38:	000087dc 	.word	0x000087dc
    4c3c:	0000881c 	.word	0x0000881c
                        layer_off(action.layer_tap.val);
    4c40:	f000 fd2e 	bl	56a0 <layer_off>
                        unregister_mods((action.layer_tap.code & 0x10) ?
    4c44:	2e00      	cmp	r6, #0
    4c46:	d01e      	beq.n	4c86 <process_action+0x356>
                                (action.layer_tap.code & 0x0f) << 4 :
    4c48:	0124      	lsls	r4, r4, #4
                        unregister_mods((action.layer_tap.code & 0x10) ?
    4c4a:	b2e0      	uxtb	r0, r4
    if (mods) {
    4c4c:	2800      	cmp	r0, #0
    4c4e:	d100      	bne.n	4c52 <process_action+0x322>
    4c50:	e6b8      	b.n	49c4 <process_action+0x94>
        del_mods(mods);
    4c52:	f000 fe7d 	bl	5950 <del_mods>
        send_keyboard_report();
    4c56:	f000 fda3 	bl	57a0 <send_keyboard_report>
    4c5a:	e6b3      	b.n	49c4 <process_action+0x94>
                        if (tap_count > 0) {
    4c5c:	2e00      	cmp	r6, #0
    4c5e:	d015      	beq.n	4c8c <process_action+0x35c>
                            unregister_code(action.layer_tap.code);
    4c60:	0020      	movs	r0, r4
    4c62:	e7d4      	b.n	4c0e <process_action+0x2de>
                                    layer_clear();
    4c64:	f000 fcec 	bl	5640 <layer_clear>
    4c68:	e6ac      	b.n	49c4 <process_action+0x94>
                        case OP_BIT_XOR: default_layer_xor(bits | mask); break;
    4c6a:	4320      	orrs	r0, r4
    4c6c:	f000 fcd8 	bl	5620 <default_layer_xor>
    4c70:	e6a8      	b.n	49c4 <process_action+0x94>
                        case OP_BIT_XOR: layer_xor(bits | mask); break;
    4c72:	4320      	orrs	r0, r4
    4c74:	f000 fd54 	bl	5720 <layer_xor>
    4c78:	e6a4      	b.n	49c4 <process_action+0x94>
                        register_mods((action.layer_tap.code & 0x10) ?
    4c7a:	200f      	movs	r0, #15
    4c7c:	4020      	ands	r0, r4
    4c7e:	e74f      	b.n	4b20 <process_action+0x1f0>
                            layer_on(action.layer_tap.val);
    4c80:	04e8      	lsls	r0, r5, #19
    4c82:	0ec0      	lsrs	r0, r0, #27
    4c84:	e73b      	b.n	4afe <process_action+0x1ce>
                        unregister_mods((action.layer_tap.code & 0x10) ?
    4c86:	200f      	movs	r0, #15
    4c88:	4020      	ands	r0, r4
    4c8a:	e7df      	b.n	4c4c <process_action+0x31c>
                            layer_off(action.layer_tap.val);
    4c8c:	04e8      	lsls	r0, r5, #19
    4c8e:	0ec0      	lsrs	r0, r0, #27
    4c90:	e72e      	b.n	4af0 <process_action+0x1c0>
                                set_oneshot_mods(mods);
    4c92:	4640      	mov	r0, r8
    4c94:	f000 fe8c 	bl	59b0 <set_oneshot_mods>
    4c98:	e694      	b.n	49c4 <process_action+0x94>
    4c9a:	46c0      	nop			; (mov r8, r8)
    4c9c:	0000      	movs	r0, r0
	...

00004ca0 <clear_keyboard_but_mods>:
    clear_mods();
    clear_keyboard_but_mods();
}

void clear_keyboard_but_mods(void)
{
    4ca0:	b510      	push	{r4, lr}
    clear_weak_mods();
    4ca2:	f000 fe7d 	bl	59a0 <clear_weak_mods>
    clear_keys();
    4ca6:	f000 fe33 	bl	5910 <clear_keys>
    send_keyboard_report();
    4caa:	f000 fd79 	bl	57a0 <send_keyboard_report>
#ifdef MOUSEKEY_ENABLE
    mousekey_clear();
    4cae:	f002 f907 	bl	6ec0 <mousekey_clear>
    mousekey_send();
    4cb2:	f002 f805 	bl	6cc0 <mousekey_send>
#endif
#ifdef EXTRAKEY_ENABLE
    host_system_send(0);
    4cb6:	2000      	movs	r0, #0
    4cb8:	f7ff fbd2 	bl	4460 <host_system_send>
    host_consumer_send(0);
    4cbc:	2000      	movs	r0, #0
    4cbe:	f7ff fbf7 	bl	44b0 <host_consumer_send>
#endif
}
    4cc2:	bd10      	pop	{r4, pc}
	...

00004cd0 <clear_keyboard>:
{
    4cd0:	b510      	push	{r4, lr}
    clear_mods();
    4cd2:	f000 fe4d 	bl	5970 <clear_mods>
    clear_keyboard_but_mods();
    4cd6:	f7ff ffe3 	bl	4ca0 <clear_keyboard_but_mods>
}
    4cda:	bd10      	pop	{r4, pc}
    4cdc:	0000      	movs	r0, r0
	...

00004ce0 <is_tap_key>:

bool is_tap_key(keypos_t key)
{
    4ce0:	b510      	push	{r4, lr}
    4ce2:	b082      	sub	sp, #8
    4ce4:	ab01      	add	r3, sp, #4
    4ce6:	8018      	strh	r0, [r3, #0]
    action_t action = layer_switch_get_action(key);
    4ce8:	9801      	ldr	r0, [sp, #4]
    4cea:	f000 fd31 	bl	5750 <layer_switch_get_action>
    4cee:	2101      	movs	r1, #1
    4cf0:	000c      	movs	r4, r1

    switch (action.kind.id) {
    4cf2:	0403      	lsls	r3, r0, #16
    4cf4:	0f1b      	lsrs	r3, r3, #28
    4cf6:	409c      	lsls	r4, r3
    4cf8:	0023      	movs	r3, r4
    4cfa:	2490      	movs	r4, #144	; 0x90
    4cfc:	0224      	lsls	r4, r4, #8
    action_t action = layer_switch_get_action(key);
    4cfe:	b2c2      	uxtb	r2, r0
    4d00:	4223      	tst	r3, r4
    4d02:	d117      	bne.n	4d34 <is_tap_key+0x54>
    4d04:	21c0      	movs	r1, #192	; 0xc0
    4d06:	0109      	lsls	r1, r1, #4
    4d08:	420b      	tst	r3, r1
    4d0a:	d109      	bne.n	4d20 <is_tap_key+0x40>
    4d0c:	210c      	movs	r1, #12
        case ACT_MACRO:
        case ACT_FUNCTION:
            if (action.func.opt & FUNC_TAP) { return true; }
            return false;
    }
    return false;
    4d0e:	2000      	movs	r0, #0
    4d10:	4219      	tst	r1, r3
    4d12:	d011      	beq.n	4d38 <is_tap_key+0x58>
            switch (action.key.code) {
    4d14:	2aa4      	cmp	r2, #164	; 0xa4
    4d16:	d815      	bhi.n	4d44 <is_tap_key+0x64>
    4d18:	2a04      	cmp	r2, #4
    4d1a:	d211      	bcs.n	4d40 <is_tap_key+0x60>
    4d1c:	2a01      	cmp	r2, #1
    4d1e:	d90f      	bls.n	4d40 <is_tap_key+0x60>
            switch (action.layer_tap.code) {
    4d20:	2ae7      	cmp	r2, #231	; 0xe7
    4d22:	d80b      	bhi.n	4d3c <is_tap_key+0x5c>
    4d24:	2ae0      	cmp	r2, #224	; 0xe0
    4d26:	d20b      	bcs.n	4d40 <is_tap_key+0x60>
    4d28:	3a04      	subs	r2, #4
    4d2a:	b2d2      	uxtb	r2, r2
    4d2c:	2aa0      	cmp	r2, #160	; 0xa0
    4d2e:	d907      	bls.n	4d40 <is_tap_key+0x60>
                    return false;
    4d30:	2000      	movs	r0, #0
    4d32:	e001      	b.n	4d38 <is_tap_key+0x58>
            if (action.func.opt & FUNC_TAP) { return true; }
    4d34:	0ac0      	lsrs	r0, r0, #11
    4d36:	4008      	ands	r0, r1
}
    4d38:	b002      	add	sp, #8
    4d3a:	bd10      	pop	{r4, pc}
            switch (action.layer_tap.code) {
    4d3c:	2af0      	cmp	r2, #240	; 0xf0
    4d3e:	d1f7      	bne.n	4d30 <is_tap_key+0x50>
                    return true;
    4d40:	2001      	movs	r0, #1
    4d42:	e7f9      	b.n	4d38 <is_tap_key+0x58>
            switch (action.key.code) {
    4d44:	0013      	movs	r3, r2
    4d46:	3320      	adds	r3, #32
    4d48:	b2db      	uxtb	r3, r3
    4d4a:	2b07      	cmp	r3, #7
    4d4c:	d8e8      	bhi.n	4d20 <is_tap_key+0x40>
    4d4e:	e7f7      	b.n	4d40 <is_tap_key+0x60>

00004d50 <debug_event>:

/*
 * debug print
 */
void debug_event(keyevent_t event)
{
    4d50:	b082      	sub	sp, #8
    dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.time);
}
    4d52:	b002      	add	sp, #8
    4d54:	4770      	bx	lr
    4d56:	46c0      	nop			; (mov r8, r8)
	...

00004d60 <debug_record>:

void debug_record(keyrecord_t record)
{
    4d60:	b082      	sub	sp, #8
    debug_event(record.event);
#ifndef NO_ACTION_TAPPING
    dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
#endif
}
    4d62:	b002      	add	sp, #8
    4d64:	4770      	bx	lr
    4d66:	46c0      	nop			; (mov r8, r8)
	...

00004d70 <debug_waiting_buffer>:
{
    debug("TAPPING_KEY="); debug_record(tapping_key); debug("\n");
}

static void debug_waiting_buffer(void)
{
    4d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    debug("{ ");
    for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SIZE) {
    4d72:	4b0a      	ldr	r3, [pc, #40]	; (4d9c <debug_waiting_buffer+0x2c>)
    4d74:	4e0a      	ldr	r6, [pc, #40]	; (4da0 <debug_waiting_buffer+0x30>)
    4d76:	781c      	ldrb	r4, [r3, #0]
    4d78:	7833      	ldrb	r3, [r6, #0]
    4d7a:	42a3      	cmp	r3, r4
    4d7c:	d00c      	beq.n	4d98 <debug_waiting_buffer+0x28>
    4d7e:	2707      	movs	r7, #7
    4d80:	4d08      	ldr	r5, [pc, #32]	; (4da4 <debug_waiting_buffer+0x34>)
        debug("["); debug_dec(i); debug("]="); debug_record(waiting_buffer[i]); debug(" ");
    4d82:	00e3      	lsls	r3, r4, #3
    4d84:	58e8      	ldr	r0, [r5, r3]
    4d86:	18eb      	adds	r3, r5, r3
    4d88:	6859      	ldr	r1, [r3, #4]
    4d8a:	f7ff ffe9 	bl	4d60 <debug_record>
    for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SIZE) {
    4d8e:	7833      	ldrb	r3, [r6, #0]
    4d90:	3401      	adds	r4, #1
    4d92:	403c      	ands	r4, r7
    4d94:	42a3      	cmp	r3, r4
    4d96:	d1f4      	bne.n	4d82 <debug_waiting_buffer+0x12>
    }
    debug("}\n");
}
    4d98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4d9a:	46c0      	nop			; (mov r8, r8)
    4d9c:	20000c99 	.word	0x20000c99
    4da0:	20000c98 	.word	0x20000c98
    4da4:	20000c58 	.word	0x20000c58
	...

00004db0 <waiting_buffer_scan_tap.part.3>:
void waiting_buffer_scan_tap(void)
    4db0:	b5f0      	push	{r4, r5, r6, r7, lr}
    4db2:	46de      	mov	lr, fp
    4db4:	4657      	mov	r7, sl
    4db6:	464e      	mov	r6, r9
    4db8:	4645      	mov	r5, r8
    4dba:	b5e0      	push	{r5, r6, r7, lr}
    for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SIZE) {
    4dbc:	4b39      	ldr	r3, [pc, #228]	; (4ea4 <waiting_buffer_scan_tap.part.3+0xf4>)
    4dbe:	4a3a      	ldr	r2, [pc, #232]	; (4ea8 <waiting_buffer_scan_tap.part.3+0xf8>)
    4dc0:	781b      	ldrb	r3, [r3, #0]
    4dc2:	7811      	ldrb	r1, [r2, #0]
void waiting_buffer_scan_tap(void)
    4dc4:	b087      	sub	sp, #28
    for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SIZE) {
    4dc6:	428b      	cmp	r3, r1
    4dc8:	d056      	beq.n	4e78 <waiting_buffer_scan_tap.part.3+0xc8>
    4dca:	4a38      	ldr	r2, [pc, #224]	; (4eac <waiting_buffer_scan_tap.part.3+0xfc>)
    4dcc:	4c38      	ldr	r4, [pc, #224]	; (4eb0 <waiting_buffer_scan_tap.part.3+0x100>)
    4dce:	8890      	ldrh	r0, [r2, #4]
    4dd0:	7856      	ldrb	r6, [r2, #1]
    4dd2:	4693      	mov	fp, r2
    4dd4:	7812      	ldrb	r2, [r2, #0]
    4dd6:	46a0      	mov	r8, r4
                WITHIN_TAPPING_TERM(waiting_buffer[i].event)) {
    4dd8:	1a24      	subs	r4, r4, r0
    4dda:	4694      	mov	ip, r2
    4ddc:	9403      	str	r4, [sp, #12]
    4dde:	aa05      	add	r2, sp, #20
    for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SIZE) {
    4de0:	9602      	str	r6, [sp, #8]
    4de2:	9001      	str	r0, [sp, #4]
    4de4:	e004      	b.n	4df0 <waiting_buffer_scan_tap.part.3+0x40>
    4de6:	2007      	movs	r0, #7
    4de8:	3301      	adds	r3, #1
    4dea:	4003      	ands	r3, r0
    4dec:	428b      	cmp	r3, r1
    4dee:	d043      	beq.n	4e78 <waiting_buffer_scan_tap.part.3+0xc8>
    4df0:	9801      	ldr	r0, [sp, #4]
    4df2:	2800      	cmp	r0, #0
    4df4:	d0f7      	beq.n	4de6 <waiting_buffer_scan_tap.part.3+0x36>
    4df6:	4668      	mov	r0, sp
    4df8:	4664      	mov	r4, ip
    4dfa:	7a00      	ldrb	r0, [r0, #8]
    4dfc:	7014      	strb	r4, [r2, #0]
    4dfe:	7050      	strb	r0, [r2, #1]
    4e00:	8814      	ldrh	r4, [r2, #0]
    4e02:	4544      	cmp	r4, r8
    4e04:	d0ef      	beq.n	4de6 <waiting_buffer_scan_tap.part.3+0x36>
        if (IS_TAPPING_KEY(waiting_buffer[i].event.key) &&
    4e06:	482b      	ldr	r0, [pc, #172]	; (4eb4 <waiting_buffer_scan_tap.part.3+0x104>)
    4e08:	00dc      	lsls	r4, r3, #3
    4e0a:	1906      	adds	r6, r0, r4
    4e0c:	46b1      	mov	r9, r6
    4e0e:	9802      	ldr	r0, [sp, #8]
    4e10:	7876      	ldrb	r6, [r6, #1]
    4e12:	4286      	cmp	r6, r0
    4e14:	d1e7      	bne.n	4de6 <waiting_buffer_scan_tap.part.3+0x36>
    4e16:	4827      	ldr	r0, [pc, #156]	; (4eb4 <waiting_buffer_scan_tap.part.3+0x104>)
    4e18:	5d06      	ldrb	r6, [r0, r4]
    4e1a:	4566      	cmp	r6, ip
    4e1c:	d1e3      	bne.n	4de6 <waiting_buffer_scan_tap.part.3+0x36>
    4e1e:	464e      	mov	r6, r9
    4e20:	78b6      	ldrb	r6, [r6, #2]
    4e22:	0030      	movs	r0, r6
    4e24:	1e37      	subs	r7, r6, #0
    4e26:	d1de      	bne.n	4de6 <waiting_buffer_scan_tap.part.3+0x36>
                WITHIN_TAPPING_TERM(waiting_buffer[i].event)) {
    4e28:	464e      	mov	r6, r9
    4e2a:	88b6      	ldrh	r6, [r6, #4]
    4e2c:	9d01      	ldr	r5, [sp, #4]
    4e2e:	46b2      	mov	sl, r6
    4e30:	45aa      	cmp	sl, r5
    4e32:	d228      	bcs.n	4e86 <waiting_buffer_scan_tap.part.3+0xd6>
    4e34:	9803      	ldr	r0, [sp, #12]
    4e36:	003e      	movs	r6, r7
    4e38:	4681      	mov	r9, r0
    4e3a:	44ca      	add	sl, r9
    4e3c:	4650      	mov	r0, sl
    4e3e:	25c7      	movs	r5, #199	; 0xc7
    4e40:	4657      	mov	r7, sl
    4e42:	0fc0      	lsrs	r0, r0, #31
    4e44:	42bd      	cmp	r5, r7
    4e46:	4146      	adcs	r6, r0
    4e48:	b2f0      	uxtb	r0, r6
    4e4a:	4681      	mov	r9, r0
                !waiting_buffer[i].event.pressed &&
    4e4c:	464e      	mov	r6, r9
    4e4e:	2e00      	cmp	r6, #0
    4e50:	d0c9      	beq.n	4de6 <waiting_buffer_scan_tap.part.3+0x36>
            tapping_key.tap.count = 1;
    4e52:	465b      	mov	r3, fp
    4e54:	799a      	ldrb	r2, [r3, #6]
    4e56:	230f      	movs	r3, #15
    4e58:	2110      	movs	r1, #16
    4e5a:	4658      	mov	r0, fp
    4e5c:	401a      	ands	r2, r3
    4e5e:	430a      	orrs	r2, r1
    4e60:	7182      	strb	r2, [r0, #6]
            waiting_buffer[i].tap.count = 1;
    4e62:	4a14      	ldr	r2, [pc, #80]	; (4eb4 <waiting_buffer_scan_tap.part.3+0x104>)
    4e64:	4694      	mov	ip, r2
    4e66:	4464      	add	r4, ip
    4e68:	79a2      	ldrb	r2, [r4, #6]
    4e6a:	4013      	ands	r3, r2
    4e6c:	430b      	orrs	r3, r1
    4e6e:	71a3      	strb	r3, [r4, #6]
            process_action(&tapping_key);
    4e70:	f7ff fd5e 	bl	4930 <process_action>
            debug_waiting_buffer();
    4e74:	f7ff ff7c 	bl	4d70 <debug_waiting_buffer>
}
    4e78:	b007      	add	sp, #28
    4e7a:	bc3c      	pop	{r2, r3, r4, r5}
    4e7c:	4690      	mov	r8, r2
    4e7e:	4699      	mov	r9, r3
    4e80:	46a2      	mov	sl, r4
    4e82:	46ab      	mov	fp, r5
    4e84:	bdf0      	pop	{r4, r5, r6, r7, pc}
                WITHIN_TAPPING_TERM(waiting_buffer[i].event)) {
    4e86:	4656      	mov	r6, sl
    4e88:	1b76      	subs	r6, r6, r5
    4e8a:	46b2      	mov	sl, r6
    4e8c:	0ff6      	lsrs	r6, r6, #31
    4e8e:	46b1      	mov	r9, r6
    4e90:	25c7      	movs	r5, #199	; 0xc7
    4e92:	0006      	movs	r6, r0
    4e94:	464f      	mov	r7, r9
    4e96:	4650      	mov	r0, sl
    4e98:	4285      	cmp	r5, r0
    4e9a:	417e      	adcs	r6, r7
    4e9c:	b2f0      	uxtb	r0, r6
    4e9e:	4681      	mov	r9, r0
    4ea0:	e7d4      	b.n	4e4c <waiting_buffer_scan_tap.part.3+0x9c>
    4ea2:	46c0      	nop			; (mov r8, r8)
    4ea4:	20000c99 	.word	0x20000c99
    4ea8:	20000c98 	.word	0x20000c98
    4eac:	20000c50 	.word	0x20000c50
    4eb0:	0000ffff 	.word	0x0000ffff
    4eb4:	20000c58 	.word	0x20000c58
	...

00004ec0 <process_tapping>:
{
    4ec0:	b5f0      	push	{r4, r5, r6, r7, lr}
    4ec2:	4645      	mov	r5, r8
    4ec4:	46de      	mov	lr, fp
    4ec6:	4657      	mov	r7, sl
    4ec8:	464e      	mov	r6, r9
    4eca:	0004      	movs	r4, r0
    4ecc:	b5e0      	push	{r5, r6, r7, lr}
    4ece:	b091      	sub	sp, #68	; 0x44
    keyevent_t event = keyp->event;
    4ed0:	0001      	movs	r1, r0
    4ed2:	2206      	movs	r2, #6
    4ed4:	a80a      	add	r0, sp, #40	; 0x28
    4ed6:	f002 fd03 	bl	78e0 <memcpy>
    4eda:	88a1      	ldrh	r1, [r4, #4]
    4edc:	4dc9      	ldr	r5, [pc, #804]	; (5204 <process_tapping+0x344>)
    4ede:	7823      	ldrb	r3, [r4, #0]
    4ee0:	4688      	mov	r8, r1
    4ee2:	88ae      	ldrh	r6, [r5, #4]
    4ee4:	8829      	ldrh	r1, [r5, #0]
    4ee6:	a802      	add	r0, sp, #8
    4ee8:	9300      	str	r3, [sp, #0]
    4eea:	78a7      	ldrb	r7, [r4, #2]
    4eec:	7863      	ldrb	r3, [r4, #1]
    4eee:	8081      	strh	r1, [r0, #4]
    4ef0:	2e00      	cmp	r6, #0
    4ef2:	d059      	beq.n	4fa8 <process_tapping+0xe8>
    4ef4:	7868      	ldrb	r0, [r5, #1]
    4ef6:	782a      	ldrb	r2, [r5, #0]
    4ef8:	4684      	mov	ip, r0
    4efa:	b288      	uxth	r0, r1
    4efc:	4681      	mov	r9, r0
    4efe:	48c2      	ldr	r0, [pc, #776]	; (5208 <process_tapping+0x348>)
    4f00:	9201      	str	r2, [sp, #4]
    4f02:	4682      	mov	sl, r0
    4f04:	4581      	cmp	r9, r0
    4f06:	d043      	beq.n	4f90 <process_tapping+0xd0>
    if (IS_TAPPING_PRESSED()) {
    4f08:	78a8      	ldrb	r0, [r5, #2]
    4f0a:	4681      	mov	r9, r0
    4f0c:	2800      	cmp	r0, #0
    4f0e:	d100      	bne.n	4f12 <process_tapping+0x52>
    4f10:	e079      	b.n	5006 <process_tapping+0x146>
        if (WITHIN_TAPPING_TERM(event)) {
    4f12:	45b0      	cmp	r8, r6
    4f14:	d300      	bcc.n	4f18 <process_tapping+0x58>
    4f16:	e0c4      	b.n	50a2 <process_tapping+0x1e2>
    4f18:	4652      	mov	r2, sl
    4f1a:	1b90      	subs	r0, r2, r6
    4f1c:	22c7      	movs	r2, #199	; 0xc7
    4f1e:	4692      	mov	sl, r2
    4f20:	2200      	movs	r2, #0
    4f22:	4651      	mov	r1, sl
    4f24:	4440      	add	r0, r8
    4f26:	0fc6      	lsrs	r6, r0, #31
    4f28:	4281      	cmp	r1, r0
    4f2a:	4156      	adcs	r6, r2
    4f2c:	b2f6      	uxtb	r6, r6
    4f2e:	79a8      	ldrb	r0, [r5, #6]
    4f30:	4682      	mov	sl, r0
    4f32:	200f      	movs	r0, #15
    4f34:	4683      	mov	fp, r0
    4f36:	4650      	mov	r0, sl
    4f38:	4659      	mov	r1, fp
    4f3a:	4388      	bics	r0, r1
    4f3c:	2e00      	cmp	r6, #0
    4f3e:	d100      	bne.n	4f42 <process_tapping+0x82>
    4f40:	e0ee      	b.n	5120 <process_tapping+0x260>
            if (tapping_key.tap.count == 0) {
    4f42:	2800      	cmp	r0, #0
    4f44:	d000      	beq.n	4f48 <process_tapping+0x88>
    4f46:	e12a      	b.n	519e <process_tapping+0x2de>
    4f48:	466a      	mov	r2, sp
    4f4a:	7912      	ldrb	r2, [r2, #4]
    4f4c:	a804      	add	r0, sp, #16
    4f4e:	7002      	strb	r2, [r0, #0]
    4f50:	4662      	mov	r2, ip
    4f52:	7042      	strb	r2, [r0, #1]
    4f54:	8800      	ldrh	r0, [r0, #0]
    4f56:	49ac      	ldr	r1, [pc, #688]	; (5208 <process_tapping+0x348>)
    4f58:	4288      	cmp	r0, r1
    4f5a:	d100      	bne.n	4f5e <process_tapping+0x9e>
    4f5c:	e0ac      	b.n	50b8 <process_tapping+0x1f8>
                if (IS_TAPPING_KEY(event.key) && !event.pressed) {
    4f5e:	2020      	movs	r0, #32
    4f60:	aa02      	add	r2, sp, #8
    4f62:	1812      	adds	r2, r2, r0
    4f64:	4668      	mov	r0, sp
    4f66:	7800      	ldrb	r0, [r0, #0]
    4f68:	8829      	ldrh	r1, [r5, #0]
    4f6a:	7010      	strb	r0, [r2, #0]
    4f6c:	2021      	movs	r0, #33	; 0x21
    4f6e:	aa02      	add	r2, sp, #8
    4f70:	1812      	adds	r2, r2, r0
    4f72:	7013      	strb	r3, [r2, #0]
    4f74:	aa02      	add	r2, sp, #8
    4f76:	8c10      	ldrh	r0, [r2, #32]
    4f78:	4288      	cmp	r0, r1
    4f7a:	d000      	beq.n	4f7e <process_tapping+0xbe>
    4f7c:	e09c      	b.n	50b8 <process_tapping+0x1f8>
    4f7e:	2f00      	cmp	r7, #0
    4f80:	d100      	bne.n	4f84 <process_tapping+0xc4>
    4f82:	e1f5      	b.n	5370 <process_tapping+0x4b0>
                        tapping_key.tap.interrupted = true;
    4f84:	2201      	movs	r2, #1
    4f86:	79ab      	ldrb	r3, [r5, #6]
    4f88:	4313      	orrs	r3, r2
    4f8a:	71ab      	strb	r3, [r5, #6]
                    return false;
    4f8c:	2600      	movs	r6, #0
    4f8e:	e011      	b.n	4fb4 <process_tapping+0xf4>
    4f90:	466a      	mov	r2, sp
    4f92:	4661      	mov	r1, ip
    4f94:	7912      	ldrb	r2, [r2, #4]
    4f96:	a808      	add	r0, sp, #32
    4f98:	7002      	strb	r2, [r0, #0]
    4f9a:	7041      	strb	r1, [r0, #1]
    4f9c:	8800      	ldrh	r0, [r0, #0]
    4f9e:	4548      	cmp	r0, r9
    4fa0:	d002      	beq.n	4fa8 <process_tapping+0xe8>
    } else if (IS_TAPPING_RELEASED()) {
    4fa2:	78a8      	ldrb	r0, [r5, #2]
    4fa4:	2800      	cmp	r0, #0
    4fa6:	d037      	beq.n	5018 <process_tapping+0x158>
        if (event.pressed && is_tap_key(event.key)) {
    4fa8:	2f00      	cmp	r7, #0
    4faa:	d10b      	bne.n	4fc4 <process_tapping+0x104>
                    process_action(keyp);
    4fac:	0020      	movs	r0, r4
    4fae:	f7ff fcbf 	bl	4930 <process_action>
                    return true;
    4fb2:	2601      	movs	r6, #1
}
    4fb4:	0030      	movs	r0, r6
    4fb6:	b011      	add	sp, #68	; 0x44
    4fb8:	bc3c      	pop	{r2, r3, r4, r5}
    4fba:	4690      	mov	r8, r2
    4fbc:	4699      	mov	r9, r3
    4fbe:	46a2      	mov	sl, r4
    4fc0:	46ab      	mov	fp, r5
    4fc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (event.pressed && is_tap_key(event.key)) {
    4fc4:	466a      	mov	r2, sp
    4fc6:	2020      	movs	r0, #32
    4fc8:	7812      	ldrb	r2, [r2, #0]
    4fca:	a902      	add	r1, sp, #8
    4fcc:	1809      	adds	r1, r1, r0
    4fce:	700a      	strb	r2, [r1, #0]
    4fd0:	2121      	movs	r1, #33	; 0x21
    4fd2:	aa02      	add	r2, sp, #8
    4fd4:	1852      	adds	r2, r2, r1
    4fd6:	7013      	strb	r3, [r2, #0]
    4fd8:	980a      	ldr	r0, [sp, #40]	; 0x28
    4fda:	f7ff fe81 	bl	4ce0 <is_tap_key>
    4fde:	2800      	cmp	r0, #0
    4fe0:	d0e4      	beq.n	4fac <process_tapping+0xec>
            tapping_key = *keyp;
    4fe2:	2208      	movs	r2, #8
    4fe4:	0021      	movs	r1, r4
    4fe6:	0028      	movs	r0, r5
    4fe8:	f002 fc7a 	bl	78e0 <memcpy>
    if (tapping_key.tap.count > 0) return;
    4fec:	220f      	movs	r2, #15
    4fee:	79ab      	ldrb	r3, [r5, #6]
    4ff0:	4393      	bics	r3, r2
    4ff2:	d103      	bne.n	4ffc <process_tapping+0x13c>
    if (!tapping_key.event.pressed) return;
    4ff4:	78ab      	ldrb	r3, [r5, #2]
    4ff6:	2b00      	cmp	r3, #0
    4ff8:	d000      	beq.n	4ffc <process_tapping+0x13c>
    4ffa:	e12b      	b.n	5254 <process_tapping+0x394>
    debug("TAPPING_KEY="); debug_record(tapping_key); debug("\n");
    4ffc:	cd03      	ldmia	r5!, {r0, r1}
    4ffe:	f7ff feaf 	bl	4d60 <debug_record>
                    return true;
    5002:	2601      	movs	r6, #1
    5004:	e7d6      	b.n	4fb4 <process_tapping+0xf4>
    5006:	466a      	mov	r2, sp
    5008:	4661      	mov	r1, ip
    500a:	7912      	ldrb	r2, [r2, #4]
    500c:	a808      	add	r0, sp, #32
    500e:	7002      	strb	r2, [r0, #0]
    5010:	7041      	strb	r1, [r0, #1]
    5012:	8800      	ldrh	r0, [r0, #0]
    5014:	4550      	cmp	r0, sl
    5016:	d0c7      	beq.n	4fa8 <process_tapping+0xe8>
        if (WITHIN_TAPPING_TERM(event)) {
    5018:	4642      	mov	r2, r8
    501a:	1b90      	subs	r0, r2, r6
    501c:	45b0      	cmp	r8, r6
    501e:	d202      	bcs.n	5026 <process_tapping+0x166>
    5020:	4a79      	ldr	r2, [pc, #484]	; (5208 <process_tapping+0x348>)
    5022:	4691      	mov	r9, r2
    5024:	4448      	add	r0, r9
    5026:	22c7      	movs	r2, #199	; 0xc7
    5028:	4691      	mov	r9, r2
    502a:	2200      	movs	r2, #0
    502c:	4649      	mov	r1, r9
    502e:	0fc6      	lsrs	r6, r0, #31
    5030:	4281      	cmp	r1, r0
    5032:	4156      	adcs	r6, r2
    5034:	b2f6      	uxtb	r6, r6
    5036:	2e00      	cmp	r6, #0
    5038:	d100      	bne.n	503c <process_tapping+0x17c>
    503a:	e0ed      	b.n	5218 <process_tapping+0x358>
            if (event.pressed) {
    503c:	1e3e      	subs	r6, r7, #0
    503e:	d0b5      	beq.n	4fac <process_tapping+0xec>
    5040:	466a      	mov	r2, sp
    5042:	7912      	ldrb	r2, [r2, #4]
    5044:	a809      	add	r0, sp, #36	; 0x24
    5046:	7002      	strb	r2, [r0, #0]
    5048:	4662      	mov	r2, ip
    504a:	7042      	strb	r2, [r0, #1]
    504c:	8800      	ldrh	r0, [r0, #0]
    504e:	496e      	ldr	r1, [pc, #440]	; (5208 <process_tapping+0x348>)
    5050:	4288      	cmp	r0, r1
    5052:	d00f      	beq.n	5074 <process_tapping+0x1b4>
                if (IS_TAPPING_KEY(event.key)) {
    5054:	2020      	movs	r0, #32
    5056:	aa02      	add	r2, sp, #8
    5058:	1812      	adds	r2, r2, r0
    505a:	4668      	mov	r0, sp
    505c:	7800      	ldrb	r0, [r0, #0]
    505e:	8829      	ldrh	r1, [r5, #0]
    5060:	7010      	strb	r0, [r2, #0]
    5062:	2021      	movs	r0, #33	; 0x21
    5064:	aa02      	add	r2, sp, #8
    5066:	1812      	adds	r2, r2, r0
    5068:	7013      	strb	r3, [r2, #0]
    506a:	aa02      	add	r2, sp, #8
    506c:	8c10      	ldrh	r0, [r2, #32]
    506e:	4288      	cmp	r0, r1
    5070:	d100      	bne.n	5074 <process_tapping+0x1b4>
    5072:	e0f7      	b.n	5264 <process_tapping+0x3a4>
                } else if (is_tap_key(event.key)) {
    5074:	2120      	movs	r1, #32
    5076:	aa02      	add	r2, sp, #8
    5078:	1852      	adds	r2, r2, r1
    507a:	4669      	mov	r1, sp
    507c:	7809      	ldrb	r1, [r1, #0]
    507e:	7011      	strb	r1, [r2, #0]
    5080:	2121      	movs	r1, #33	; 0x21
    5082:	aa02      	add	r2, sp, #8
    5084:	1852      	adds	r2, r2, r1
    5086:	7013      	strb	r3, [r2, #0]
    5088:	980a      	ldr	r0, [sp, #40]	; 0x28
    508a:	f7ff fe29 	bl	4ce0 <is_tap_key>
    508e:	2800      	cmp	r0, #0
    5090:	d1a7      	bne.n	4fe2 <process_tapping+0x122>
                    tapping_key.tap.interrupted = true;
    5092:	2201      	movs	r2, #1
    5094:	79ab      	ldrb	r3, [r5, #6]
    5096:	4313      	orrs	r3, r2
    5098:	71ab      	strb	r3, [r5, #6]
                    process_action(keyp);
    509a:	0020      	movs	r0, r4
    509c:	f7ff fc48 	bl	4930 <process_action>
                    return true;
    50a0:	e788      	b.n	4fb4 <process_tapping+0xf4>
        if (WITHIN_TAPPING_TERM(event)) {
    50a2:	4641      	mov	r1, r8
    50a4:	1b88      	subs	r0, r1, r6
    50a6:	21c7      	movs	r1, #199	; 0xc7
    50a8:	468a      	mov	sl, r1
    50aa:	2100      	movs	r1, #0
    50ac:	4652      	mov	r2, sl
    50ae:	0fc6      	lsrs	r6, r0, #31
    50b0:	4282      	cmp	r2, r0
    50b2:	414e      	adcs	r6, r1
    50b4:	b2f6      	uxtb	r6, r6
    50b6:	e73a      	b.n	4f2e <process_tapping+0x6e>
    50b8:	4642      	mov	r2, r8
    50ba:	2a00      	cmp	r2, #0
    50bc:	d100      	bne.n	50c0 <process_tapping+0x200>
    50be:	e0cc      	b.n	525a <process_tapping+0x39a>
    50c0:	466a      	mov	r2, sp
    50c2:	7812      	ldrb	r2, [r2, #0]
    50c4:	a905      	add	r1, sp, #20
    50c6:	700a      	strb	r2, [r1, #0]
    50c8:	704b      	strb	r3, [r1, #1]
    50ca:	8808      	ldrh	r0, [r1, #0]
    50cc:	494e      	ldr	r1, [pc, #312]	; (5208 <process_tapping+0x348>)
    50ce:	4288      	cmp	r0, r1
    50d0:	d100      	bne.n	50d4 <process_tapping+0x214>
    50d2:	e0c2      	b.n	525a <process_tapping+0x39a>
static inline bool IS_PRESSED(keyevent_t event) { return (!IS_NOEVENT(event) && event.pressed); }
static inline bool IS_RELEASED(keyevent_t event) { return (!IS_NOEVENT(event) && !event.pressed); }
    50d4:	2f00      	cmp	r7, #0
    50d6:	d000      	beq.n	50da <process_tapping+0x21a>
    50d8:	e754      	b.n	4f84 <process_tapping+0xc4>
    for (uint8_t i = waiting_buffer_tail; i != waiting_buffer_head; i = (i + 1) % WAITING_BUFFER_SIZE) {
    50da:	494c      	ldr	r1, [pc, #304]	; (520c <process_tapping+0x34c>)
    50dc:	484c      	ldr	r0, [pc, #304]	; (5210 <process_tapping+0x350>)
    50de:	7809      	ldrb	r1, [r1, #0]
    50e0:	7802      	ldrb	r2, [r0, #0]
    50e2:	4690      	mov	r8, r2
    50e4:	4291      	cmp	r1, r2
    50e6:	d100      	bne.n	50ea <process_tapping+0x22a>
    50e8:	e0fb      	b.n	52e2 <process_tapping+0x422>
    50ea:	4a4a      	ldr	r2, [pc, #296]	; (5214 <process_tapping+0x354>)
    50ec:	4694      	mov	ip, r2
    50ee:	2207      	movs	r2, #7
    50f0:	4691      	mov	r9, r2
    50f2:	e005      	b.n	5100 <process_tapping+0x240>
    50f4:	4648      	mov	r0, r9
    50f6:	3101      	adds	r1, #1
    50f8:	4001      	ands	r1, r0
    50fa:	4541      	cmp	r1, r8
    50fc:	d100      	bne.n	5100 <process_tapping+0x240>
    50fe:	e0f0      	b.n	52e2 <process_tapping+0x422>
        if (KEYEQ(event.key, waiting_buffer[i].event.key) && event.pressed !=  waiting_buffer[i].event.pressed) {
    5100:	4665      	mov	r5, ip
    5102:	00c8      	lsls	r0, r1, #3
    5104:	182d      	adds	r5, r5, r0
    5106:	786f      	ldrb	r7, [r5, #1]
    5108:	429f      	cmp	r7, r3
    510a:	d1f3      	bne.n	50f4 <process_tapping+0x234>
    510c:	4662      	mov	r2, ip
    510e:	5c10      	ldrb	r0, [r2, r0]
    5110:	9a00      	ldr	r2, [sp, #0]
    5112:	4290      	cmp	r0, r2
    5114:	d1ee      	bne.n	50f4 <process_tapping+0x234>
    5116:	78a8      	ldrb	r0, [r5, #2]
    5118:	2800      	cmp	r0, #0
    511a:	d0eb      	beq.n	50f4 <process_tapping+0x234>
                    return false;
    511c:	2600      	movs	r6, #0
    511e:	e749      	b.n	4fb4 <process_tapping+0xf4>
            if (tapping_key.tap.count == 0) {
    5120:	2800      	cmp	r0, #0
    5122:	d100      	bne.n	5126 <process_tapping+0x266>
    5124:	e0c5      	b.n	52b2 <process_tapping+0x3f2>
static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 && event.key.col == 255); }
    5126:	466a      	mov	r2, sp
    5128:	7912      	ldrb	r2, [r2, #4]
    512a:	a807      	add	r0, sp, #28
    512c:	7002      	strb	r2, [r0, #0]
    512e:	4662      	mov	r2, ip
    5130:	7042      	strb	r2, [r0, #1]
    5132:	8800      	ldrh	r0, [r0, #0]
    5134:	4934      	ldr	r1, [pc, #208]	; (5208 <process_tapping+0x348>)
    5136:	4288      	cmp	r0, r1
    5138:	d00f      	beq.n	515a <process_tapping+0x29a>
                if (IS_TAPPING_KEY(event.key) && !event.pressed) {
    513a:	2020      	movs	r0, #32
    513c:	aa02      	add	r2, sp, #8
    513e:	1812      	adds	r2, r2, r0
    5140:	4668      	mov	r0, sp
    5142:	7800      	ldrb	r0, [r0, #0]
    5144:	8829      	ldrh	r1, [r5, #0]
    5146:	7010      	strb	r0, [r2, #0]
    5148:	2021      	movs	r0, #33	; 0x21
    514a:	aa02      	add	r2, sp, #8
    514c:	1812      	adds	r2, r2, r0
    514e:	7013      	strb	r3, [r2, #0]
    5150:	aa02      	add	r2, sp, #8
    5152:	8c10      	ldrh	r0, [r2, #32]
    5154:	4288      	cmp	r0, r1
    5156:	d100      	bne.n	515a <process_tapping+0x29a>
    5158:	e0a2      	b.n	52a0 <process_tapping+0x3e0>
                else if (is_tap_key(event.key) && event.pressed) {
    515a:	2120      	movs	r1, #32
    515c:	aa02      	add	r2, sp, #8
    515e:	1852      	adds	r2, r2, r1
    5160:	4669      	mov	r1, sp
    5162:	7809      	ldrb	r1, [r1, #0]
    5164:	7011      	strb	r1, [r2, #0]
    5166:	2121      	movs	r1, #33	; 0x21
    5168:	aa02      	add	r2, sp, #8
    516a:	1852      	adds	r2, r2, r1
    516c:	7013      	strb	r3, [r2, #0]
    516e:	980a      	ldr	r0, [sp, #40]	; 0x28
    5170:	f7ff fdb6 	bl	4ce0 <is_tap_key>
    5174:	2800      	cmp	r0, #0
    5176:	d100      	bne.n	517a <process_tapping+0x2ba>
    5178:	e718      	b.n	4fac <process_tapping+0xec>
    517a:	2f00      	cmp	r7, #0
    517c:	d100      	bne.n	5180 <process_tapping+0x2c0>
    517e:	e715      	b.n	4fac <process_tapping+0xec>
                    if (tapping_key.tap.count > 1) {
    5180:	79ab      	ldrb	r3, [r5, #6]
    5182:	2b1f      	cmp	r3, #31
    5184:	d800      	bhi.n	5188 <process_tapping+0x2c8>
    5186:	e72c      	b.n	4fe2 <process_tapping+0x122>
                        process_action(&(keyrecord_t){
    5188:	a80e      	add	r0, sp, #56	; 0x38
    518a:	882a      	ldrh	r2, [r5, #0]
    518c:	7183      	strb	r3, [r0, #6]
    518e:	8002      	strh	r2, [r0, #0]
    5190:	2200      	movs	r2, #0
    5192:	7082      	strb	r2, [r0, #2]
    5194:	4642      	mov	r2, r8
    5196:	8082      	strh	r2, [r0, #4]
    5198:	f7ff fbca 	bl	4930 <process_action>
    519c:	e721      	b.n	4fe2 <process_tapping+0x122>
    519e:	466a      	mov	r2, sp
    51a0:	7912      	ldrb	r2, [r2, #4]
    51a2:	a806      	add	r0, sp, #24
    51a4:	7002      	strb	r2, [r0, #0]
    51a6:	4662      	mov	r2, ip
    51a8:	7042      	strb	r2, [r0, #1]
    51aa:	8800      	ldrh	r0, [r0, #0]
    51ac:	4916      	ldr	r1, [pc, #88]	; (5208 <process_tapping+0x348>)
    51ae:	4288      	cmp	r0, r1
    51b0:	d00f      	beq.n	51d2 <process_tapping+0x312>
                if (IS_TAPPING_KEY(event.key) && !event.pressed) {
    51b2:	2020      	movs	r0, #32
    51b4:	aa02      	add	r2, sp, #8
    51b6:	1812      	adds	r2, r2, r0
    51b8:	4668      	mov	r0, sp
    51ba:	7800      	ldrb	r0, [r0, #0]
    51bc:	8829      	ldrh	r1, [r5, #0]
    51be:	7010      	strb	r0, [r2, #0]
    51c0:	2021      	movs	r0, #33	; 0x21
    51c2:	aa02      	add	r2, sp, #8
    51c4:	1812      	adds	r2, r2, r0
    51c6:	7013      	strb	r3, [r2, #0]
    51c8:	aa02      	add	r2, sp, #8
    51ca:	8c10      	ldrh	r0, [r2, #32]
    51cc:	4288      	cmp	r0, r1
    51ce:	d100      	bne.n	51d2 <process_tapping+0x312>
    51d0:	e0b1      	b.n	5336 <process_tapping+0x476>
                else if (is_tap_key(event.key) && event.pressed) {
    51d2:	2120      	movs	r1, #32
    51d4:	aa02      	add	r2, sp, #8
    51d6:	1852      	adds	r2, r2, r1
    51d8:	4669      	mov	r1, sp
    51da:	7809      	ldrb	r1, [r1, #0]
    51dc:	7011      	strb	r1, [r2, #0]
    51de:	2121      	movs	r1, #33	; 0x21
    51e0:	aa02      	add	r2, sp, #8
    51e2:	1852      	adds	r2, r2, r1
    51e4:	7013      	strb	r3, [r2, #0]
    51e6:	980a      	ldr	r0, [sp, #40]	; 0x28
    51e8:	f7ff fd7a 	bl	4ce0 <is_tap_key>
    51ec:	2800      	cmp	r0, #0
    51ee:	d100      	bne.n	51f2 <process_tapping+0x332>
    51f0:	e6dc      	b.n	4fac <process_tapping+0xec>
    51f2:	2f00      	cmp	r7, #0
    51f4:	d100      	bne.n	51f8 <process_tapping+0x338>
    51f6:	e6d9      	b.n	4fac <process_tapping+0xec>
                    if (tapping_key.tap.count > 1) {
    51f8:	79ab      	ldrb	r3, [r5, #6]
                        process_action(&(keyrecord_t){
    51fa:	a80c      	add	r0, sp, #48	; 0x30
                    if (tapping_key.tap.count > 1) {
    51fc:	2b1f      	cmp	r3, #31
    51fe:	d800      	bhi.n	5202 <process_tapping+0x342>
    5200:	e6ef      	b.n	4fe2 <process_tapping+0x122>
    5202:	e7c2      	b.n	518a <process_tapping+0x2ca>
    5204:	20000c50 	.word	0x20000c50
    5208:	0000ffff 	.word	0x0000ffff
    520c:	20000c99 	.word	0x20000c99
    5210:	20000c98 	.word	0x20000c98
    5214:	20000c58 	.word	0x20000c58
            debug_event(event); debug("\n");
    5218:	2122      	movs	r1, #34	; 0x22
    521a:	aa02      	add	r2, sp, #8
    521c:	1852      	adds	r2, r2, r1
    521e:	4641      	mov	r1, r8
    5220:	7017      	strb	r7, [r2, #0]
    5222:	aa02      	add	r2, sp, #8
    5224:	8491      	strh	r1, [r2, #36]	; 0x24
    5226:	2120      	movs	r1, #32
    5228:	1852      	adds	r2, r2, r1
    522a:	4669      	mov	r1, sp
    522c:	7809      	ldrb	r1, [r1, #0]
    522e:	7011      	strb	r1, [r2, #0]
    5230:	2121      	movs	r1, #33	; 0x21
    5232:	aa02      	add	r2, sp, #8
    5234:	1852      	adds	r2, r2, r1
    5236:	7013      	strb	r3, [r2, #0]
    5238:	980a      	ldr	r0, [sp, #40]	; 0x28
    523a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    523c:	f7ff fd88 	bl	4d50 <debug_event>
            tapping_key = (keyrecord_t){};
    5240:	2208      	movs	r2, #8
    5242:	2100      	movs	r1, #0
    5244:	0028      	movs	r0, r5
    5246:	f002 fb8f 	bl	7968 <memset>
    debug("TAPPING_KEY="); debug_record(tapping_key); debug("\n");
    524a:	2000      	movs	r0, #0
    524c:	2100      	movs	r1, #0
    524e:	f7ff fd87 	bl	4d60 <debug_record>
            return false;
    5252:	e6af      	b.n	4fb4 <process_tapping+0xf4>
    5254:	f7ff fdac 	bl	4db0 <waiting_buffer_scan_tap.part.3>
    5258:	e6d0      	b.n	4ffc <process_tapping+0x13c>
                    if (event.pressed) {
    525a:	2f00      	cmp	r7, #0
    525c:	d000      	beq.n	5260 <process_tapping+0x3a0>
    525e:	e691      	b.n	4f84 <process_tapping+0xc4>
                    return false;
    5260:	2600      	movs	r6, #0
    5262:	e6a7      	b.n	4fb4 <process_tapping+0xf4>
                    if (!tapping_key.tap.interrupted && tapping_key.tap.count > 0) {
    5264:	79ab      	ldrb	r3, [r5, #6]
    5266:	07da      	lsls	r2, r3, #31
    5268:	d45f      	bmi.n	532a <process_tapping+0x46a>
    526a:	220f      	movs	r2, #15
    526c:	0019      	movs	r1, r3
    526e:	4391      	bics	r1, r2
    5270:	d05b      	beq.n	532a <process_tapping+0x46a>
                        if (keyp->tap.count < 15) keyp->tap.count += 1;
    5272:	0019      	movs	r1, r3
                        keyp->tap = tapping_key.tap;
    5274:	71a3      	strb	r3, [r4, #6]
                        if (keyp->tap.count < 15) keyp->tap.count += 1;
    5276:	4391      	bics	r1, r2
    5278:	29f0      	cmp	r1, #240	; 0xf0
    527a:	d005      	beq.n	5288 <process_tapping+0x3c8>
    527c:	0919      	lsrs	r1, r3, #4
    527e:	3101      	adds	r1, #1
    5280:	0109      	lsls	r1, r1, #4
    5282:	4013      	ands	r3, r2
    5284:	430b      	orrs	r3, r1
    5286:	71a3      	strb	r3, [r4, #6]
                        process_action(keyp);
    5288:	0020      	movs	r0, r4
    528a:	f7ff fb51 	bl	4930 <process_action>
                        tapping_key = *keyp;
    528e:	0021      	movs	r1, r4
    5290:	2208      	movs	r2, #8
    5292:	0028      	movs	r0, r5
    5294:	f002 fb24 	bl	78e0 <memcpy>
    debug("TAPPING_KEY="); debug_record(tapping_key); debug("\n");
    5298:	cd03      	ldmia	r5!, {r0, r1}
    529a:	f7ff fd61 	bl	4d60 <debug_record>
                        return true;
    529e:	e689      	b.n	4fb4 <process_tapping+0xf4>
                if (IS_TAPPING_KEY(event.key) && !event.pressed) {
    52a0:	2f00      	cmp	r7, #0
    52a2:	d052      	beq.n	534a <process_tapping+0x48a>
                else if (is_tap_key(event.key) && event.pressed) {
    52a4:	980a      	ldr	r0, [sp, #40]	; 0x28
    52a6:	f7ff fd1b 	bl	4ce0 <is_tap_key>
    52aa:	2800      	cmp	r0, #0
    52ac:	d000      	beq.n	52b0 <process_tapping+0x3f0>
    52ae:	e767      	b.n	5180 <process_tapping+0x2c0>
    52b0:	e67c      	b.n	4fac <process_tapping+0xec>
                debug_event(event); debug("\n");
    52b2:	2122      	movs	r1, #34	; 0x22
    52b4:	aa02      	add	r2, sp, #8
    52b6:	1852      	adds	r2, r2, r1
    52b8:	4641      	mov	r1, r8
    52ba:	7017      	strb	r7, [r2, #0]
    52bc:	aa02      	add	r2, sp, #8
    52be:	8491      	strh	r1, [r2, #36]	; 0x24
    52c0:	2120      	movs	r1, #32
    52c2:	1852      	adds	r2, r2, r1
    52c4:	4669      	mov	r1, sp
    52c6:	7809      	ldrb	r1, [r1, #0]
    52c8:	7011      	strb	r1, [r2, #0]
    52ca:	2121      	movs	r1, #33	; 0x21
    52cc:	aa02      	add	r2, sp, #8
    52ce:	1852      	adds	r2, r2, r1
    52d0:	7013      	strb	r3, [r2, #0]
    52d2:	980a      	ldr	r0, [sp, #40]	; 0x28
    52d4:	990b      	ldr	r1, [sp, #44]	; 0x2c
    52d6:	f7ff fd3b 	bl	4d50 <debug_event>
                process_action(&tapping_key);
    52da:	0028      	movs	r0, r5
    52dc:	f7ff fb28 	bl	4930 <process_action>
    52e0:	e7ae      	b.n	5240 <process_tapping+0x380>
                    action_t action = layer_switch_get_action(event.key);
    52e2:	2120      	movs	r1, #32
    52e4:	aa02      	add	r2, sp, #8
    52e6:	1852      	adds	r2, r2, r1
    52e8:	4669      	mov	r1, sp
    52ea:	7809      	ldrb	r1, [r1, #0]
    52ec:	7011      	strb	r1, [r2, #0]
    52ee:	2121      	movs	r1, #33	; 0x21
    52f0:	aa02      	add	r2, sp, #8
    52f2:	1852      	adds	r2, r2, r1
    52f4:	7013      	strb	r3, [r2, #0]
    52f6:	980a      	ldr	r0, [sp, #40]	; 0x28
    52f8:	f000 fa2a 	bl	5750 <layer_switch_get_action>
    52fc:	b2c2      	uxtb	r2, r0
                    switch (action.kind.id) {
    52fe:	0400      	lsls	r0, r0, #16
    5300:	0f03      	lsrs	r3, r0, #28
    5302:	2b01      	cmp	r3, #1
    5304:	d92d      	bls.n	5362 <process_tapping+0x4a2>
    5306:	2b03      	cmp	r3, #3
    5308:	d900      	bls.n	530c <process_tapping+0x44c>
    530a:	e6c6      	b.n	509a <process_tapping+0x1da>
                            if (action.key.mods && keyp->tap.count == 0) return false;
    530c:	230f      	movs	r3, #15
    530e:	0e00      	lsrs	r0, r0, #24
    5310:	4203      	tst	r3, r0
    5312:	d003      	beq.n	531c <process_tapping+0x45c>
    5314:	79a1      	ldrb	r1, [r4, #6]
    5316:	4399      	bics	r1, r3
    5318:	d100      	bne.n	531c <process_tapping+0x45c>
    531a:	e637      	b.n	4f8c <process_tapping+0xcc>
                            if (IS_MOD(action.key.code)) return false;
    531c:	3220      	adds	r2, #32
    531e:	b2d2      	uxtb	r2, r2
    5320:	2a07      	cmp	r2, #7
    5322:	d900      	bls.n	5326 <process_tapping+0x466>
    5324:	e6b9      	b.n	509a <process_tapping+0x1da>
                    return false;
    5326:	2600      	movs	r6, #0
    5328:	e644      	b.n	4fb4 <process_tapping+0xf4>
                        tapping_key = *keyp;
    532a:	2208      	movs	r2, #8
    532c:	0021      	movs	r1, r4
    532e:	0028      	movs	r0, r5
    5330:	f002 fad6 	bl	78e0 <memcpy>
                        return true;
    5334:	e63e      	b.n	4fb4 <process_tapping+0xf4>
                    keyp->tap = tapping_key.tap;
    5336:	4653      	mov	r3, sl
                if (IS_TAPPING_KEY(event.key) && !event.pressed) {
    5338:	2f00      	cmp	r7, #0
    533a:	d0a4      	beq.n	5286 <process_tapping+0x3c6>
                else if (is_tap_key(event.key) && event.pressed) {
    533c:	980a      	ldr	r0, [sp, #40]	; 0x28
    533e:	f7ff fccf 	bl	4ce0 <is_tap_key>
    5342:	2800      	cmp	r0, #0
    5344:	d000      	beq.n	5348 <process_tapping+0x488>
    5346:	e757      	b.n	51f8 <process_tapping+0x338>
    5348:	e630      	b.n	4fac <process_tapping+0xec>
                    keyp->tap = tapping_key.tap;
    534a:	4653      	mov	r3, sl
                    process_action(keyp);
    534c:	0020      	movs	r0, r4
                    keyp->tap = tapping_key.tap;
    534e:	71a3      	strb	r3, [r4, #6]
                    process_action(keyp);
    5350:	f7ff faee 	bl	4930 <process_action>
                    tapping_key = (keyrecord_t){};
    5354:	2208      	movs	r2, #8
    5356:	2100      	movs	r1, #0
    5358:	0028      	movs	r0, r5
    535a:	f002 fb05 	bl	7968 <memset>
                    return true;
    535e:	464e      	mov	r6, r9
    5360:	e628      	b.n	4fb4 <process_tapping+0xf4>
                            if (action.key.mods && !action.key.code) return false;
    5362:	0100      	lsls	r0, r0, #4
    5364:	0f00      	lsrs	r0, r0, #28
    5366:	d0d9      	beq.n	531c <process_tapping+0x45c>
    5368:	2a00      	cmp	r2, #0
    536a:	d1d7      	bne.n	531c <process_tapping+0x45c>
                    return false;
    536c:	2600      	movs	r6, #0
    536e:	e621      	b.n	4fb4 <process_tapping+0xf4>
                    tapping_key.tap.count = 1;
    5370:	4652      	mov	r2, sl
    5372:	465b      	mov	r3, fp
    5374:	4013      	ands	r3, r2
    5376:	2210      	movs	r2, #16
    5378:	4313      	orrs	r3, r2
    537a:	71ab      	strb	r3, [r5, #6]
    debug("TAPPING_KEY="); debug_record(tapping_key); debug("\n");
    537c:	6828      	ldr	r0, [r5, #0]
    537e:	6869      	ldr	r1, [r5, #4]
    5380:	f7ff fcee 	bl	4d60 <debug_record>
                    process_action(&tapping_key);
    5384:	0028      	movs	r0, r5
    5386:	f7ff fad3 	bl	4930 <process_action>
                    keyp->tap = tapping_key.tap;
    538a:	79ab      	ldrb	r3, [r5, #6]
                    return false;
    538c:	2600      	movs	r6, #0
                    keyp->tap = tapping_key.tap;
    538e:	71a3      	strb	r3, [r4, #6]
                    return false;
    5390:	e610      	b.n	4fb4 <process_tapping+0xf4>
    5392:	46c0      	nop			; (mov r8, r8)
	...

000053a0 <action_tapping_process>:
{
    53a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    53a2:	b087      	sub	sp, #28
    53a4:	466c      	mov	r4, sp
    53a6:	9000      	str	r0, [sp, #0]
    if (process_tapping(&record)) {
    53a8:	0020      	movs	r0, r4
{
    53aa:	6061      	str	r1, [r4, #4]
    if (process_tapping(&record)) {
    53ac:	f7ff fd88 	bl	4ec0 <process_tapping>
    53b0:	1e05      	subs	r5, r0, #0
    53b2:	d02b      	beq.n	540c <action_tapping_process+0x6c>
    53b4:	8822      	ldrh	r2, [r4, #0]
    53b6:	88a3      	ldrh	r3, [r4, #4]
    53b8:	8122      	strh	r2, [r4, #8]
    53ba:	2b00      	cmp	r3, #0
    53bc:	d11e      	bne.n	53fc <action_tapping_process+0x5c>
    53be:	4e2a      	ldr	r6, [pc, #168]	; (5468 <action_tapping_process+0xc8>)
    53c0:	4c2a      	ldr	r4, [pc, #168]	; (546c <action_tapping_process+0xcc>)
    53c2:	7833      	ldrb	r3, [r6, #0]
    53c4:	7820      	ldrb	r0, [r4, #0]
    for (; waiting_buffer_tail != waiting_buffer_head; waiting_buffer_tail = (waiting_buffer_tail + 1) % WAITING_BUFFER_SIZE) {
    53c6:	4283      	cmp	r3, r0
    53c8:	d016      	beq.n	53f8 <action_tapping_process+0x58>
    53ca:	4d29      	ldr	r5, [pc, #164]	; (5470 <action_tapping_process+0xd0>)
    53cc:	2707      	movs	r7, #7
    53ce:	e00d      	b.n	53ec <action_tapping_process+0x4c>
            debug_record(waiting_buffer[waiting_buffer_tail]); debug("\n\n");
    53d0:	7823      	ldrb	r3, [r4, #0]
    53d2:	00db      	lsls	r3, r3, #3
    53d4:	58e8      	ldr	r0, [r5, r3]
    53d6:	18eb      	adds	r3, r5, r3
    53d8:	6859      	ldr	r1, [r3, #4]
    53da:	f7ff fcc1 	bl	4d60 <debug_record>
    for (; waiting_buffer_tail != waiting_buffer_head; waiting_buffer_tail = (waiting_buffer_tail + 1) % WAITING_BUFFER_SIZE) {
    53de:	7820      	ldrb	r0, [r4, #0]
    53e0:	7833      	ldrb	r3, [r6, #0]
    53e2:	3001      	adds	r0, #1
    53e4:	4038      	ands	r0, r7
    53e6:	7020      	strb	r0, [r4, #0]
    53e8:	4283      	cmp	r3, r0
    53ea:	d005      	beq.n	53f8 <action_tapping_process+0x58>
        if (process_tapping(&waiting_buffer[waiting_buffer_tail])) {
    53ec:	00c0      	lsls	r0, r0, #3
    53ee:	1828      	adds	r0, r5, r0
    53f0:	f7ff fd66 	bl	4ec0 <process_tapping>
    53f4:	2800      	cmp	r0, #0
    53f6:	d1eb      	bne.n	53d0 <action_tapping_process+0x30>
}
    53f8:	b007      	add	sp, #28
    53fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    53fc:	8922      	ldrh	r2, [r4, #8]
    53fe:	4b1d      	ldr	r3, [pc, #116]	; (5474 <action_tapping_process+0xd4>)
    5400:	429a      	cmp	r2, r3
    5402:	d0dc      	beq.n	53be <action_tapping_process+0x1e>
            debug("processed: "); debug_record(record); debug("\n");
    5404:	cc03      	ldmia	r4!, {r0, r1}
    5406:	f7ff fcab 	bl	4d60 <debug_record>
    540a:	e7d8      	b.n	53be <action_tapping_process+0x1e>
    540c:	aa04      	add	r2, sp, #16
    540e:	0021      	movs	r1, r4
    5410:	0013      	movs	r3, r2
    5412:	c941      	ldmia	r1!, {r0, r6}
    5414:	c341      	stmia	r3!, {r0, r6}
    5416:	8813      	ldrh	r3, [r2, #0]
    5418:	88a1      	ldrh	r1, [r4, #4]
    541a:	81a3      	strh	r3, [r4, #12]
    541c:	4e12      	ldr	r6, [pc, #72]	; (5468 <action_tapping_process+0xc8>)
    541e:	4c13      	ldr	r4, [pc, #76]	; (546c <action_tapping_process+0xcc>)
    5420:	7833      	ldrb	r3, [r6, #0]
    5422:	7820      	ldrb	r0, [r4, #0]
    5424:	2900      	cmp	r1, #0
    5426:	d0ce      	beq.n	53c6 <action_tapping_process+0x26>
    5428:	4669      	mov	r1, sp
    542a:	898f      	ldrh	r7, [r1, #12]
    542c:	4911      	ldr	r1, [pc, #68]	; (5474 <action_tapping_process+0xd4>)
    542e:	428f      	cmp	r7, r1
    5430:	d0c9      	beq.n	53c6 <action_tapping_process+0x26>
    if ((waiting_buffer_head + 1) % WAITING_BUFFER_SIZE == waiting_buffer_tail) {
    5432:	2107      	movs	r1, #7
    5434:	1c5f      	adds	r7, r3, #1
    5436:	4039      	ands	r1, r7
    5438:	4281      	cmp	r1, r0
    543a:	d00a      	beq.n	5452 <action_tapping_process+0xb2>
    waiting_buffer[waiting_buffer_head] = record;
    543c:	4d0c      	ldr	r5, [pc, #48]	; (5470 <action_tapping_process+0xd0>)
    543e:	00db      	lsls	r3, r3, #3
    5440:	18ed      	adds	r5, r5, r3
    5442:	ca09      	ldmia	r2!, {r0, r3}
    5444:	c509      	stmia	r5!, {r0, r3}
    waiting_buffer_head = (waiting_buffer_head + 1) % WAITING_BUFFER_SIZE;
    5446:	7031      	strb	r1, [r6, #0]
    debug("waiting_buffer_enq: "); debug_waiting_buffer();
    5448:	f7ff fc92 	bl	4d70 <debug_waiting_buffer>
    544c:	7833      	ldrb	r3, [r6, #0]
    544e:	7820      	ldrb	r0, [r4, #0]
    5450:	e7b9      	b.n	53c6 <action_tapping_process+0x26>
            clear_keyboard();
    5452:	f7ff fc3d 	bl	4cd0 <clear_keyboard>
            tapping_key = (keyrecord_t){};
    5456:	2208      	movs	r2, #8
    5458:	2100      	movs	r1, #0
    545a:	4807      	ldr	r0, [pc, #28]	; (5478 <action_tapping_process+0xd8>)
    waiting_buffer_head = 0;
    545c:	7035      	strb	r5, [r6, #0]
    waiting_buffer_tail = 0;
    545e:	7025      	strb	r5, [r4, #0]
            tapping_key = (keyrecord_t){};
    5460:	f002 fa82 	bl	7968 <memset>
    5464:	e7c8      	b.n	53f8 <action_tapping_process+0x58>
    5466:	46c0      	nop			; (mov r8, r8)
    5468:	20000c98 	.word	0x20000c98
    546c:	20000c99 	.word	0x20000c99
    5470:	20000c58 	.word	0x20000c58
    5474:	0000ffff 	.word	0x0000ffff
    5478:	20000c50 	.word	0x20000c50
    547c:	00000000 	.word	0x00000000

00005480 <action_macro_play>:

#ifndef NO_ACTION_MACRO

#define MACRO_READ()  (macro = MACRO_GET(macro_p++))
void action_macro_play(const macro_t *macro_p)
{
    5480:	b5f0      	push	{r4, r5, r6, r7, lr}
    5482:	46d6      	mov	lr, sl
    5484:	464f      	mov	r7, r9
    5486:	4646      	mov	r6, r8
    5488:	0005      	movs	r5, r0
    548a:	b5c0      	push	{r6, r7, lr}
    macro_t macro = END;
    uint8_t interval = 0;

    uint8_t mod_storage = 0;

    if (!macro_p) return;
    548c:	2800      	cmp	r0, #0
    548e:	d03d      	beq.n	550c <action_macro_play+0x8c>
                dprintf("DOWN(%02X)\n", macro);
                register_code(macro);
                break;
            case 0x84 ... 0xF3:
                dprintf("UP(%02X)\n", macro);
                unregister_code(macro&0x7F);
    5490:	237f      	movs	r3, #127	; 0x7f
    5492:	4699      	mov	r9, r3
                    add_weak_mods(MOD_BIT(macro));
    5494:	3b78      	subs	r3, #120	; 0x78
    uint8_t mod_storage = 0;
    5496:	2700      	movs	r7, #0
    uint8_t interval = 0;
    5498:	2600      	movs	r6, #0
                    add_weak_mods(MOD_BIT(macro));
    549a:	4698      	mov	r8, r3
        switch (MACRO_READ()) {
    549c:	7828      	ldrb	r0, [r5, #0]
    549e:	1c6c      	adds	r4, r5, #1
    54a0:	2875      	cmp	r0, #117	; 0x75
    54a2:	d022      	beq.n	54ea <action_macro_play+0x6a>
    54a4:	2875      	cmp	r0, #117	; 0x75
    54a6:	d823      	bhi.n	54f0 <action_macro_play+0x70>
    54a8:	2873      	cmp	r0, #115	; 0x73
    54aa:	d851      	bhi.n	5550 <action_macro_play+0xd0>
    54ac:	2804      	cmp	r0, #4
    54ae:	d24b      	bcs.n	5548 <action_macro_play+0xc8>
    54b0:	2801      	cmp	r0, #1
    54b2:	d038      	beq.n	5526 <action_macro_play+0xa6>
    54b4:	2802      	cmp	r0, #2
    54b6:	d129      	bne.n	550c <action_macro_play+0x8c>
                MACRO_READ();
    54b8:	7868      	ldrb	r0, [r5, #1]
    54ba:	1cac      	adds	r4, r5, #2
                if (IS_MOD(macro)) {
    54bc:	0003      	movs	r3, r0
    54be:	3320      	adds	r3, #32
    54c0:	b2db      	uxtb	r3, r3
    54c2:	2b07      	cmp	r3, #7
    54c4:	d964      	bls.n	5590 <action_macro_play+0x110>
                unregister_code(macro&0x7F);
    54c6:	f7ff f9c3 	bl	4850 <unregister_code>
        switch (MACRO_READ()) {
    54ca:	0025      	movs	r5, r4
            case END:
            default:
                return;
        }
        // interval
        { uint8_t ms = interval; while (ms--) wait_ms(1); }
    54cc:	1e74      	subs	r4, r6, #1
    54ce:	b2e4      	uxtb	r4, r4
    54d0:	2e00      	cmp	r6, #0
    54d2:	d0e3      	beq.n	549c <action_macro_play+0x1c>
    54d4:	3c01      	subs	r4, #1
    54d6:	2001      	movs	r0, #1
    54d8:	b2e4      	uxtb	r4, r4
    54da:	f7fc f989 	bl	17f0 <chThdSleep>
    54de:	2cff      	cmp	r4, #255	; 0xff
    54e0:	d1f8      	bne.n	54d4 <action_macro_play+0x54>
        switch (MACRO_READ()) {
    54e2:	7828      	ldrb	r0, [r5, #0]
    54e4:	1c6c      	adds	r4, r5, #1
    54e6:	2875      	cmp	r0, #117	; 0x75
    54e8:	d1dc      	bne.n	54a4 <action_macro_play+0x24>
                interval = MACRO_READ();
    54ea:	786e      	ldrb	r6, [r5, #1]
    54ec:	3502      	adds	r5, #2
                break;
    54ee:	e7ed      	b.n	54cc <action_macro_play+0x4c>
        switch (MACRO_READ()) {
    54f0:	2878      	cmp	r0, #120	; 0x78
    54f2:	d03d      	beq.n	5570 <action_macro_play+0xf0>
    54f4:	d80f      	bhi.n	5516 <action_macro_play+0x96>
    54f6:	2876      	cmp	r0, #118	; 0x76
    54f8:	d040      	beq.n	557c <action_macro_play+0xfc>
    54fa:	2877      	cmp	r0, #119	; 0x77
    54fc:	d106      	bne.n	550c <action_macro_play+0x8c>
                set_mods(mod_storage);
    54fe:	0038      	movs	r0, r7
    5500:	f000 fa2e 	bl	5960 <set_mods>
        switch (MACRO_READ()) {
    5504:	0025      	movs	r5, r4
                send_keyboard_report();
    5506:	f000 f94b 	bl	57a0 <send_keyboard_report>
                break;
    550a:	e7df      	b.n	54cc <action_macro_play+0x4c>
    }
}
    550c:	bc1c      	pop	{r2, r3, r4}
    550e:	4690      	mov	r8, r2
    5510:	4699      	mov	r9, r3
    5512:	46a2      	mov	sl, r4
    5514:	bdf0      	pop	{r4, r5, r6, r7, pc}
        switch (MACRO_READ()) {
    5516:	0003      	movs	r3, r0
    5518:	337c      	adds	r3, #124	; 0x7c
    551a:	b2db      	uxtb	r3, r3
    551c:	2b6f      	cmp	r3, #111	; 0x6f
    551e:	d8f5      	bhi.n	550c <action_macro_play+0x8c>
                unregister_code(macro&0x7F);
    5520:	464b      	mov	r3, r9
    5522:	4018      	ands	r0, r3
    5524:	e7cf      	b.n	54c6 <action_macro_play+0x46>
                MACRO_READ();
    5526:	786b      	ldrb	r3, [r5, #1]
    5528:	1cac      	adds	r4, r5, #2
                if (IS_MOD(macro)) {
    552a:	001a      	movs	r2, r3
    552c:	3220      	adds	r2, #32
    552e:	b2d2      	uxtb	r2, r2
    5530:	2a07      	cmp	r2, #7
    5532:	d828      	bhi.n	5586 <action_macro_play+0x106>
                    add_weak_mods(MOD_BIT(macro));
    5534:	4642      	mov	r2, r8
    5536:	4013      	ands	r3, r2
    5538:	4098      	lsls	r0, r3
    553a:	b2c0      	uxtb	r0, r0
    553c:	f000 fa20 	bl	5980 <add_weak_mods>
                MACRO_READ();
    5540:	0025      	movs	r5, r4
                    send_keyboard_report();
    5542:	f000 f92d 	bl	57a0 <send_keyboard_report>
    5546:	e7c1      	b.n	54cc <action_macro_play+0x4c>
                register_code(macro);
    5548:	f7ff f8a2 	bl	4690 <register_code>
        switch (MACRO_READ()) {
    554c:	0025      	movs	r5, r4
                break;
    554e:	e7bd      	b.n	54cc <action_macro_play+0x4c>
                MACRO_READ();
    5550:	1cab      	adds	r3, r5, #2
    5552:	469a      	mov	sl, r3
    5554:	786b      	ldrb	r3, [r5, #1]
                { uint8_t ms = macro; while (ms--) wait_ms(1); }
    5556:	1e5c      	subs	r4, r3, #1
    5558:	b2e4      	uxtb	r4, r4
    555a:	2b00      	cmp	r3, #0
    555c:	d006      	beq.n	556c <action_macro_play+0xec>
    555e:	3c01      	subs	r4, #1
    5560:	2001      	movs	r0, #1
    5562:	b2e4      	uxtb	r4, r4
    5564:	f7fc f944 	bl	17f0 <chThdSleep>
    5568:	2cff      	cmp	r4, #255	; 0xff
    556a:	d1f8      	bne.n	555e <action_macro_play+0xde>
                MACRO_READ();
    556c:	4655      	mov	r5, sl
    556e:	e7ad      	b.n	54cc <action_macro_play+0x4c>
                clear_mods();
    5570:	f000 f9fe 	bl	5970 <clear_mods>
        switch (MACRO_READ()) {
    5574:	0025      	movs	r5, r4
                send_keyboard_report();
    5576:	f000 f913 	bl	57a0 <send_keyboard_report>
                break;
    557a:	e7a7      	b.n	54cc <action_macro_play+0x4c>
                mod_storage = get_mods();
    557c:	f000 f9d8 	bl	5930 <get_mods>
        switch (MACRO_READ()) {
    5580:	0025      	movs	r5, r4
                mod_storage = get_mods();
    5582:	0007      	movs	r7, r0
                break;
    5584:	e7a2      	b.n	54cc <action_macro_play+0x4c>
                    register_code(macro);
    5586:	0018      	movs	r0, r3
    5588:	f7ff f882 	bl	4690 <register_code>
                MACRO_READ();
    558c:	0025      	movs	r5, r4
    558e:	e79d      	b.n	54cc <action_macro_play+0x4c>
                    del_weak_mods(MOD_BIT(macro));
    5590:	4643      	mov	r3, r8
    5592:	4018      	ands	r0, r3
    5594:	2301      	movs	r3, #1
    5596:	4083      	lsls	r3, r0
    5598:	b2d8      	uxtb	r0, r3
    559a:	f000 f9f9 	bl	5990 <del_weak_mods>
                MACRO_READ();
    559e:	0025      	movs	r5, r4
                    send_keyboard_report();
    55a0:	f000 f8fe 	bl	57a0 <send_keyboard_report>
    55a4:	e792      	b.n	54cc <action_macro_play+0x4c>
    55a6:	46c0      	nop			; (mov r8, r8)
	...

000055b0 <default_layer_debug>:
}

void default_layer_debug(void)
{
    dprintf("%08lX(%u)", default_layer_state, biton32(default_layer_state));
}
    55b0:	4770      	bx	lr
    55b2:	46c0      	nop			; (mov r8, r8)
	...

000055c0 <default_layer_set>:

void default_layer_set(uint32_t state)
{
    55c0:	b510      	push	{r4, lr}
    default_layer_state = state;
    55c2:	4b03      	ldr	r3, [pc, #12]	; (55d0 <default_layer_set+0x10>)
    55c4:	6018      	str	r0, [r3, #0]
    hook_default_layer_change(default_layer_state);
    55c6:	f000 fb73 	bl	5cb0 <hook_default_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    55ca:	f7ff fb69 	bl	4ca0 <clear_keyboard_but_mods>
    default_layer_state_set(state);
}
    55ce:	bd10      	pop	{r4, pc}
    55d0:	20000c9c 	.word	0x20000c9c
	...

000055e0 <default_layer_or>:

#ifndef NO_ACTION_LAYER
void default_layer_or(uint32_t state)
{
    55e0:	b510      	push	{r4, lr}
    default_layer_state_set(default_layer_state | state);
    55e2:	4b04      	ldr	r3, [pc, #16]	; (55f4 <default_layer_or+0x14>)
    55e4:	681a      	ldr	r2, [r3, #0]
    55e6:	4310      	orrs	r0, r2
    default_layer_state = state;
    55e8:	6018      	str	r0, [r3, #0]
    hook_default_layer_change(default_layer_state);
    55ea:	f000 fb61 	bl	5cb0 <hook_default_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    55ee:	f7ff fb57 	bl	4ca0 <clear_keyboard_but_mods>
}
    55f2:	bd10      	pop	{r4, pc}
    55f4:	20000c9c 	.word	0x20000c9c
	...

00005600 <default_layer_and>:
void default_layer_and(uint32_t state)
{
    5600:	b510      	push	{r4, lr}
    default_layer_state_set(default_layer_state & state);
    5602:	4b04      	ldr	r3, [pc, #16]	; (5614 <default_layer_and+0x14>)
    5604:	681a      	ldr	r2, [r3, #0]
    5606:	4010      	ands	r0, r2
    default_layer_state = state;
    5608:	6018      	str	r0, [r3, #0]
    hook_default_layer_change(default_layer_state);
    560a:	f000 fb51 	bl	5cb0 <hook_default_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    560e:	f7ff fb47 	bl	4ca0 <clear_keyboard_but_mods>
}
    5612:	bd10      	pop	{r4, pc}
    5614:	20000c9c 	.word	0x20000c9c
	...

00005620 <default_layer_xor>:
void default_layer_xor(uint32_t state)
{
    5620:	b510      	push	{r4, lr}
    default_layer_state_set(default_layer_state ^ state);
    5622:	4b04      	ldr	r3, [pc, #16]	; (5634 <default_layer_xor+0x14>)
    5624:	681a      	ldr	r2, [r3, #0]
    5626:	4050      	eors	r0, r2
    default_layer_state = state;
    5628:	6018      	str	r0, [r3, #0]
    hook_default_layer_change(default_layer_state);
    562a:	f000 fb41 	bl	5cb0 <hook_default_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    562e:	f7ff fb37 	bl	4ca0 <clear_keyboard_but_mods>
}
    5632:	bd10      	pop	{r4, pc}
    5634:	20000c9c 	.word	0x20000c9c
	...

00005640 <layer_clear>:

static void layer_state_set(uint32_t state)
{
    dprint("layer_state: ");
    layer_debug(); dprint(" to ");
    layer_state = state;
    5640:	2200      	movs	r2, #0
    layer_debug(); dprintln();
    clear_keyboard_but_mods(); // To avoid stuck keys
}

void layer_clear(void)
{
    5642:	b510      	push	{r4, lr}
    layer_state = state;
    5644:	4b03      	ldr	r3, [pc, #12]	; (5654 <layer_clear+0x14>)
    hook_layer_change(layer_state);
    5646:	2000      	movs	r0, #0
    layer_state = state;
    5648:	601a      	str	r2, [r3, #0]
    hook_layer_change(layer_state);
    564a:	f000 fb39 	bl	5cc0 <hook_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    564e:	f7ff fb27 	bl	4ca0 <clear_keyboard_but_mods>
    layer_state_set(0);
}
    5652:	bd10      	pop	{r4, pc}
    5654:	20000ca0 	.word	0x20000ca0
	...

00005660 <layer_move>:

void layer_move(uint8_t layer)
{
    layer_state_set(1UL<<layer);
    5660:	2301      	movs	r3, #1
    5662:	4083      	lsls	r3, r0
    5664:	0018      	movs	r0, r3
{
    5666:	b510      	push	{r4, lr}
    layer_state = state;
    5668:	4b03      	ldr	r3, [pc, #12]	; (5678 <layer_move+0x18>)
    566a:	6018      	str	r0, [r3, #0]
    hook_layer_change(layer_state);
    566c:	f000 fb28 	bl	5cc0 <hook_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    5670:	f7ff fb16 	bl	4ca0 <clear_keyboard_but_mods>
}
    5674:	bd10      	pop	{r4, pc}
    5676:	46c0      	nop			; (mov r8, r8)
    5678:	20000ca0 	.word	0x20000ca0
    567c:	00000000 	.word	0x00000000

00005680 <layer_on>:

void layer_on(uint8_t layer)
{
    5680:	0003      	movs	r3, r0
    layer_state_set(layer_state | (1UL<<layer));
    5682:	2001      	movs	r0, #1
    5684:	4098      	lsls	r0, r3
{
    5686:	b510      	push	{r4, lr}
    layer_state_set(layer_state | (1UL<<layer));
    5688:	4b04      	ldr	r3, [pc, #16]	; (569c <layer_on+0x1c>)
    568a:	681a      	ldr	r2, [r3, #0]
    568c:	4310      	orrs	r0, r2
    layer_state = state;
    568e:	6018      	str	r0, [r3, #0]
    hook_layer_change(layer_state);
    5690:	f000 fb16 	bl	5cc0 <hook_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    5694:	f7ff fb04 	bl	4ca0 <clear_keyboard_but_mods>
}
    5698:	bd10      	pop	{r4, pc}
    569a:	46c0      	nop			; (mov r8, r8)
    569c:	20000ca0 	.word	0x20000ca0

000056a0 <layer_off>:

void layer_off(uint8_t layer)
{
    layer_state_set(layer_state & ~(1UL<<layer));
    56a0:	2301      	movs	r3, #1
    56a2:	4083      	lsls	r3, r0
{
    56a4:	b510      	push	{r4, lr}
    layer_state_set(layer_state & ~(1UL<<layer));
    56a6:	4a04      	ldr	r2, [pc, #16]	; (56b8 <layer_off+0x18>)
    56a8:	6810      	ldr	r0, [r2, #0]
    56aa:	4398      	bics	r0, r3
    layer_state = state;
    56ac:	6010      	str	r0, [r2, #0]
    hook_layer_change(layer_state);
    56ae:	f000 fb07 	bl	5cc0 <hook_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    56b2:	f7ff faf5 	bl	4ca0 <clear_keyboard_but_mods>
}
    56b6:	bd10      	pop	{r4, pc}
    56b8:	20000ca0 	.word	0x20000ca0
    56bc:	00000000 	.word	0x00000000

000056c0 <layer_invert>:

void layer_invert(uint8_t layer)
{
    56c0:	0003      	movs	r3, r0
    layer_state_set(layer_state ^ (1UL<<layer));
    56c2:	2001      	movs	r0, #1
    56c4:	4098      	lsls	r0, r3
{
    56c6:	b510      	push	{r4, lr}
    layer_state_set(layer_state ^ (1UL<<layer));
    56c8:	4b04      	ldr	r3, [pc, #16]	; (56dc <layer_invert+0x1c>)
    56ca:	681a      	ldr	r2, [r3, #0]
    56cc:	4050      	eors	r0, r2
    layer_state = state;
    56ce:	6018      	str	r0, [r3, #0]
    hook_layer_change(layer_state);
    56d0:	f000 faf6 	bl	5cc0 <hook_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    56d4:	f7ff fae4 	bl	4ca0 <clear_keyboard_but_mods>
}
    56d8:	bd10      	pop	{r4, pc}
    56da:	46c0      	nop			; (mov r8, r8)
    56dc:	20000ca0 	.word	0x20000ca0

000056e0 <layer_or>:

void layer_or(uint32_t state)
{
    56e0:	b510      	push	{r4, lr}
    layer_state_set(layer_state | state);
    56e2:	4b04      	ldr	r3, [pc, #16]	; (56f4 <layer_or+0x14>)
    56e4:	681a      	ldr	r2, [r3, #0]
    56e6:	4310      	orrs	r0, r2
    layer_state = state;
    56e8:	6018      	str	r0, [r3, #0]
    hook_layer_change(layer_state);
    56ea:	f000 fae9 	bl	5cc0 <hook_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    56ee:	f7ff fad7 	bl	4ca0 <clear_keyboard_but_mods>
}
    56f2:	bd10      	pop	{r4, pc}
    56f4:	20000ca0 	.word	0x20000ca0
	...

00005700 <layer_and>:
void layer_and(uint32_t state)
{
    5700:	b510      	push	{r4, lr}
    layer_state_set(layer_state & state);
    5702:	4b04      	ldr	r3, [pc, #16]	; (5714 <layer_and+0x14>)
    5704:	681a      	ldr	r2, [r3, #0]
    5706:	4010      	ands	r0, r2
    layer_state = state;
    5708:	6018      	str	r0, [r3, #0]
    hook_layer_change(layer_state);
    570a:	f000 fad9 	bl	5cc0 <hook_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    570e:	f7ff fac7 	bl	4ca0 <clear_keyboard_but_mods>
}
    5712:	bd10      	pop	{r4, pc}
    5714:	20000ca0 	.word	0x20000ca0
	...

00005720 <layer_xor>:
void layer_xor(uint32_t state)
{
    5720:	b510      	push	{r4, lr}
    layer_state_set(layer_state ^ state);
    5722:	4b04      	ldr	r3, [pc, #16]	; (5734 <layer_xor+0x14>)
    5724:	681a      	ldr	r2, [r3, #0]
    5726:	4050      	eors	r0, r2
    layer_state = state;
    5728:	6018      	str	r0, [r3, #0]
    hook_layer_change(layer_state);
    572a:	f000 fac9 	bl	5cc0 <hook_layer_change>
    clear_keyboard_but_mods(); // To avoid stuck keys
    572e:	f7ff fab7 	bl	4ca0 <clear_keyboard_but_mods>
}
    5732:	bd10      	pop	{r4, pc}
    5734:	20000ca0 	.word	0x20000ca0
	...

00005740 <layer_debug>:
    5740:	4770      	bx	lr
    5742:	46c0      	nop			; (mov r8, r8)
	...

00005750 <layer_switch_get_action>:
#endif



action_t layer_switch_get_action(keypos_t key)
{
    5750:	b5f0      	push	{r4, r5, r6, r7, lr}
    action_t action = ACTION_TRANSPARENT;

#ifndef NO_ACTION_LAYER
    uint32_t layers = layer_state | default_layer_state;
    5752:	4b0f      	ldr	r3, [pc, #60]	; (5790 <layer_switch_get_action+0x40>)
{
    5754:	b083      	sub	sp, #12
    uint32_t layers = layer_state | default_layer_state;
    5756:	681d      	ldr	r5, [r3, #0]
    5758:	4b0e      	ldr	r3, [pc, #56]	; (5794 <layer_switch_get_action+0x44>)
{
    575a:	ae01      	add	r6, sp, #4
    uint32_t layers = layer_state | default_layer_state;
    575c:	681b      	ldr	r3, [r3, #0]
{
    575e:	8030      	strh	r0, [r6, #0]
    uint32_t layers = layer_state | default_layer_state;
    5760:	431d      	orrs	r5, r3
    5762:	241f      	movs	r4, #31
    /* check top layer first */
    for (int8_t i = 31; i >= 0; i--) {
        if (layers & (1UL<<i)) {
    5764:	2701      	movs	r7, #1
    5766:	e001      	b.n	576c <layer_switch_get_action+0x1c>
    for (int8_t i = 31; i >= 0; i--) {
    5768:	3c01      	subs	r4, #1
    576a:	d30c      	bcc.n	5786 <layer_switch_get_action+0x36>
        if (layers & (1UL<<i)) {
    576c:	002b      	movs	r3, r5
    576e:	40e3      	lsrs	r3, r4
    5770:	b2e0      	uxtb	r0, r4
    5772:	421f      	tst	r7, r3
    5774:	d0f8      	beq.n	5768 <layer_switch_get_action+0x18>
            action = action_for_key(i, key);
    5776:	6831      	ldr	r1, [r6, #0]
    5778:	f000 f9f2 	bl	5b60 <action_for_key>
    577c:	b280      	uxth	r0, r0
            if (action.code != (action_t)ACTION_TRANSPARENT.code) {
    577e:	2801      	cmp	r0, #1
    5780:	d0f2      	beq.n	5768 <layer_switch_get_action+0x18>
    return action;
#else
    action = action_for_key(biton32(default_layer_state), key);
    return action;
#endif
}
    5782:	b003      	add	sp, #12
    5784:	bdf0      	pop	{r4, r5, r6, r7, pc}
    action = action_for_key(0, key);
    5786:	9901      	ldr	r1, [sp, #4]
    5788:	2000      	movs	r0, #0
    578a:	f000 f9e9 	bl	5b60 <action_for_key>
    return action;
    578e:	e7f8      	b.n	5782 <layer_switch_get_action+0x32>
    5790:	20000ca0 	.word	0x20000ca0
    5794:	20000c9c 	.word	0x20000c9c
	...

000057a0 <send_keyboard_report>:
static int16_t oneshot_time = 0;
#endif
#endif


void send_keyboard_report(void) {
    57a0:	b570      	push	{r4, r5, r6, lr}
    keyboard_report->mods  = real_mods;
    57a2:	4b11      	ldr	r3, [pc, #68]	; (57e8 <send_keyboard_report+0x48>)
    keyboard_report->mods |= weak_mods;
    57a4:	4a11      	ldr	r2, [pc, #68]	; (57ec <send_keyboard_report+0x4c>)
    keyboard_report->mods  = real_mods;
    57a6:	6818      	ldr	r0, [r3, #0]
    keyboard_report->mods |= weak_mods;
    57a8:	4b11      	ldr	r3, [pc, #68]	; (57f0 <send_keyboard_report+0x50>)
    57aa:	7812      	ldrb	r2, [r2, #0]
    57ac:	781b      	ldrb	r3, [r3, #0]
#ifndef NO_ACTION_ONESHOT
    if (oneshot_mods) {
    57ae:	4d11      	ldr	r5, [pc, #68]	; (57f4 <send_keyboard_report+0x54>)
    keyboard_report->mods |= weak_mods;
    57b0:	4313      	orrs	r3, r2
    if (oneshot_mods) {
    57b2:	2200      	movs	r2, #0
    keyboard_report->mods |= weak_mods;
    57b4:	7003      	strb	r3, [r0, #0]
    if (oneshot_mods) {
    57b6:	56aa      	ldrsb	r2, [r5, r2]
    57b8:	2a00      	cmp	r2, #0
    57ba:	d011      	beq.n	57e0 <send_keyboard_report+0x40>
    57bc:	0004      	movs	r4, r0
        if (TIMER_DIFF_16(timer_read(), oneshot_time) >= ONESHOT_TIMEOUT) {
            dprintf("Oneshot: timeout\n");
            clear_oneshot_mods();
        }
#endif
        keyboard_report->mods |= oneshot_mods;
    57be:	4313      	orrs	r3, r2
/*
 * inspect keyboard state
 */
uint8_t has_anykey(void)
{
    uint8_t cnt = 0;
    57c0:	2200      	movs	r2, #0
        keyboard_report->mods |= oneshot_mods;
    57c2:	7003      	strb	r3, [r0, #0]
    57c4:	3410      	adds	r4, #16
    57c6:	1c43      	adds	r3, r0, #1
    for (uint8_t i = 1; i < KEYBOARD_REPORT_SIZE; i++) {
        if (keyboard_report->raw[i])
    57c8:	7819      	ldrb	r1, [r3, #0]
    57ca:	2900      	cmp	r1, #0
    57cc:	d001      	beq.n	57d2 <send_keyboard_report+0x32>
            cnt++;
    57ce:	3201      	adds	r2, #1
    57d0:	b2d2      	uxtb	r2, r2
    57d2:	3301      	adds	r3, #1
    for (uint8_t i = 1; i < KEYBOARD_REPORT_SIZE; i++) {
    57d4:	42a3      	cmp	r3, r4
    57d6:	d1f7      	bne.n	57c8 <send_keyboard_report+0x28>
        if (has_anykey()) {
    57d8:	2a00      	cmp	r2, #0
    57da:	d001      	beq.n	57e0 <send_keyboard_report+0x40>
    oneshot_mods = 0;
    57dc:	2300      	movs	r3, #0
    57de:	702b      	strb	r3, [r5, #0]
    host_keyboard_send(keyboard_report);
    57e0:	f7fe fdee 	bl	43c0 <host_keyboard_send>
}
    57e4:	bd70      	pop	{r4, r5, r6, pc}
    57e6:	46c0      	nop			; (mov r8, r8)
    57e8:	1ffffe34 	.word	0x1ffffe34
    57ec:	20000cb6 	.word	0x20000cb6
    57f0:	20000cb5 	.word	0x20000cb5
    57f4:	20000cb4 	.word	0x20000cb4
	...

00005800 <add_key>:
{
    5800:	b570      	push	{r4, r5, r6, lr}
    if (keyboard_protocol && keyboard_nkro) {
    5802:	4b1f      	ldr	r3, [pc, #124]	; (5880 <add_key+0x80>)
    5804:	781b      	ldrb	r3, [r3, #0]
    5806:	2b00      	cmp	r3, #0
    5808:	d003      	beq.n	5812 <add_key+0x12>
    580a:	4b1e      	ldr	r3, [pc, #120]	; (5884 <add_key+0x84>)
    580c:	781b      	ldrb	r3, [r3, #0]
    580e:	2b00      	cmp	r3, #0
    5810:	d11f      	bne.n	5852 <add_key+0x52>
    cb_count++;
#else
    int8_t i = 0;
    int8_t empty = -1;
    for (; i < KEYBOARD_REPORT_KEYS; i++) {
        if (keyboard_report->keys[i] == code) {
    5812:	2501      	movs	r5, #1
    5814:	4b1c      	ldr	r3, [pc, #112]	; (5888 <add_key+0x88>)
    5816:	426d      	negs	r5, r5
    5818:	6819      	ldr	r1, [r3, #0]
    581a:	2300      	movs	r3, #0
    581c:	1c8a      	adds	r2, r1, #2
    581e:	e005      	b.n	582c <add_key+0x2c>
    5820:	3301      	adds	r3, #1
    5822:	b2dc      	uxtb	r4, r3
    5824:	3201      	adds	r2, #1
    5826:	b263      	sxtb	r3, r4
    for (; i < KEYBOARD_REPORT_KEYS; i++) {
    5828:	2c0e      	cmp	r4, #14
    582a:	d00d      	beq.n	5848 <add_key+0x48>
        if (keyboard_report->keys[i] == code) {
    582c:	7814      	ldrb	r4, [r2, #0]
    582e:	42a0      	cmp	r0, r4
    5830:	d00e      	beq.n	5850 <add_key+0x50>
            break;
        }
        if (empty == -1 && keyboard_report->keys[i] == 0) {
    5832:	1c6e      	adds	r6, r5, #1
    5834:	d1f4      	bne.n	5820 <add_key+0x20>
    5836:	2c00      	cmp	r4, #0
    5838:	d1f2      	bne.n	5820 <add_key+0x20>
    583a:	001d      	movs	r5, r3
    583c:	3301      	adds	r3, #1
    583e:	b2dc      	uxtb	r4, r3
    5840:	3201      	adds	r2, #1
    5842:	b263      	sxtb	r3, r4
    for (; i < KEYBOARD_REPORT_KEYS; i++) {
    5844:	2c0e      	cmp	r4, #14
    5846:	d1f1      	bne.n	582c <add_key+0x2c>
            empty = i;
        }
    }
    if (i == KEYBOARD_REPORT_KEYS) {
        if (empty != -1) {
    5848:	1c6b      	adds	r3, r5, #1
    584a:	d001      	beq.n	5850 <add_key+0x50>
            keyboard_report->keys[empty] = code;
    584c:	194d      	adds	r5, r1, r5
    584e:	70a8      	strb	r0, [r5, #2]
}
    5850:	bd70      	pop	{r4, r5, r6, pc}
}

#ifdef NKRO_ENABLE
static inline void add_key_bit(uint8_t code)
{
    if ((code>>3) < KEYBOARD_REPORT_BITS) {
    5852:	08c3      	lsrs	r3, r0, #3
    5854:	2b0e      	cmp	r3, #14
    5856:	d908      	bls.n	586a <add_key+0x6a>
        keyboard_report->nkro.bits[code>>3] |= 1<<(code&7);
    } else {
        dprintf("add_key_bit: can't add: %02X\n", code);
    5858:	4b0c      	ldr	r3, [pc, #48]	; (588c <add_key+0x8c>)
    585a:	781b      	ldrb	r3, [r3, #0]
    585c:	07db      	lsls	r3, r3, #31
    585e:	d5f7      	bpl.n	5850 <add_key+0x50>
    5860:	0001      	movs	r1, r0
    5862:	480b      	ldr	r0, [pc, #44]	; (5890 <add_key+0x90>)
    5864:	f000 fc94 	bl	6190 <tfp_printf>
    5868:	e7f2      	b.n	5850 <add_key+0x50>
        keyboard_report->nkro.bits[code>>3] |= 1<<(code&7);
    586a:	4a07      	ldr	r2, [pc, #28]	; (5888 <add_key+0x88>)
    586c:	2107      	movs	r1, #7
    586e:	6812      	ldr	r2, [r2, #0]
    5870:	4008      	ands	r0, r1
    5872:	18d2      	adds	r2, r2, r3
    5874:	2301      	movs	r3, #1
    5876:	4083      	lsls	r3, r0
    5878:	7851      	ldrb	r1, [r2, #1]
    587a:	430b      	orrs	r3, r1
    587c:	7053      	strb	r3, [r2, #1]
    587e:	e7e7      	b.n	5850 <add_key+0x50>
    5880:	1ffffe00 	.word	0x1ffffe00
    5884:	1ffffe31 	.word	0x1ffffe31
    5888:	1ffffe34 	.word	0x1ffffe34
    588c:	20000cb8 	.word	0x20000cb8
    5890:	000088ec 	.word	0x000088ec
	...

000058a0 <del_key>:
{
    58a0:	b510      	push	{r4, lr}
    if (keyboard_protocol && keyboard_nkro) {
    58a2:	4b16      	ldr	r3, [pc, #88]	; (58fc <del_key+0x5c>)
    58a4:	781b      	ldrb	r3, [r3, #0]
    58a6:	2b00      	cmp	r3, #0
    58a8:	d003      	beq.n	58b2 <del_key+0x12>
    58aa:	4b15      	ldr	r3, [pc, #84]	; (5900 <del_key+0x60>)
    58ac:	781b      	ldrb	r3, [r3, #0]
    58ae:	2b00      	cmp	r3, #0
    58b0:	d10c      	bne.n	58cc <del_key+0x2c>
            keyboard_report->keys[i] = 0;
    58b2:	2100      	movs	r1, #0
        if (keyboard_report->keys[i] == code) {
    58b4:	4b13      	ldr	r3, [pc, #76]	; (5904 <del_key+0x64>)
    58b6:	681c      	ldr	r4, [r3, #0]
    58b8:	1ca3      	adds	r3, r4, #2
    58ba:	3410      	adds	r4, #16
    58bc:	781a      	ldrb	r2, [r3, #0]
    58be:	4282      	cmp	r2, r0
    58c0:	d100      	bne.n	58c4 <del_key+0x24>
            keyboard_report->keys[i] = 0;
    58c2:	7019      	strb	r1, [r3, #0]
    58c4:	3301      	adds	r3, #1
    for (uint8_t i = 0; i < KEYBOARD_REPORT_KEYS; i++) {
    58c6:	42a3      	cmp	r3, r4
    58c8:	d1f8      	bne.n	58bc <del_key+0x1c>
}
    58ca:	bd10      	pop	{r4, pc}
    }
}

static inline void del_key_bit(uint8_t code)
{
    if ((code>>3) < KEYBOARD_REPORT_BITS) {
    58cc:	08c3      	lsrs	r3, r0, #3
    58ce:	2b0e      	cmp	r3, #14
    58d0:	d908      	bls.n	58e4 <del_key+0x44>
        keyboard_report->nkro.bits[code>>3] &= ~(1<<(code&7));
    } else {
        dprintf("del_key_bit: can't del: %02X\n", code);
    58d2:	4b0d      	ldr	r3, [pc, #52]	; (5908 <del_key+0x68>)
    58d4:	781b      	ldrb	r3, [r3, #0]
    58d6:	07db      	lsls	r3, r3, #31
    58d8:	d5f7      	bpl.n	58ca <del_key+0x2a>
    58da:	0001      	movs	r1, r0
    58dc:	480b      	ldr	r0, [pc, #44]	; (590c <del_key+0x6c>)
    58de:	f000 fc57 	bl	6190 <tfp_printf>
    58e2:	e7f2      	b.n	58ca <del_key+0x2a>
        keyboard_report->nkro.bits[code>>3] &= ~(1<<(code&7));
    58e4:	2107      	movs	r1, #7
    58e6:	4008      	ands	r0, r1
    58e8:	3906      	subs	r1, #6
    58ea:	4081      	lsls	r1, r0
    58ec:	4a05      	ldr	r2, [pc, #20]	; (5904 <del_key+0x64>)
    58ee:	6812      	ldr	r2, [r2, #0]
    58f0:	18d3      	adds	r3, r2, r3
    58f2:	785a      	ldrb	r2, [r3, #1]
    58f4:	438a      	bics	r2, r1
    58f6:	705a      	strb	r2, [r3, #1]
    58f8:	e7e7      	b.n	58ca <del_key+0x2a>
    58fa:	46c0      	nop			; (mov r8, r8)
    58fc:	1ffffe00 	.word	0x1ffffe00
    5900:	1ffffe31 	.word	0x1ffffe31
    5904:	1ffffe34 	.word	0x1ffffe34
    5908:	20000cb8 	.word	0x20000cb8
    590c:	0000890c 	.word	0x0000890c

00005910 <clear_keys>:
        keyboard_report->raw[i] = 0;
    5910:	2100      	movs	r1, #0
    5912:	4b04      	ldr	r3, [pc, #16]	; (5924 <clear_keys+0x14>)
    5914:	681a      	ldr	r2, [r3, #0]
    5916:	1c53      	adds	r3, r2, #1
    5918:	3210      	adds	r2, #16
    591a:	7019      	strb	r1, [r3, #0]
    591c:	3301      	adds	r3, #1
    for (int8_t i = 1; i < KEYBOARD_REPORT_SIZE; i++) {
    591e:	4293      	cmp	r3, r2
    5920:	d1fb      	bne.n	591a <clear_keys+0xa>
}
    5922:	4770      	bx	lr
    5924:	1ffffe34 	.word	0x1ffffe34
	...

00005930 <get_mods>:
uint8_t get_mods(void) { return real_mods; }
    5930:	4b01      	ldr	r3, [pc, #4]	; (5938 <get_mods+0x8>)
    5932:	7818      	ldrb	r0, [r3, #0]
    5934:	4770      	bx	lr
    5936:	46c0      	nop			; (mov r8, r8)
    5938:	20000cb5 	.word	0x20000cb5
    593c:	00000000 	.word	0x00000000

00005940 <add_mods>:
void add_mods(uint8_t mods) { real_mods |= mods; }
    5940:	4b02      	ldr	r3, [pc, #8]	; (594c <add_mods+0xc>)
    5942:	781a      	ldrb	r2, [r3, #0]
    5944:	4310      	orrs	r0, r2
    5946:	7018      	strb	r0, [r3, #0]
    5948:	4770      	bx	lr
    594a:	46c0      	nop			; (mov r8, r8)
    594c:	20000cb5 	.word	0x20000cb5

00005950 <del_mods>:
void del_mods(uint8_t mods) { real_mods &= ~mods; }
    5950:	4a02      	ldr	r2, [pc, #8]	; (595c <del_mods+0xc>)
    5952:	7813      	ldrb	r3, [r2, #0]
    5954:	4383      	bics	r3, r0
    5956:	7013      	strb	r3, [r2, #0]
    5958:	4770      	bx	lr
    595a:	46c0      	nop			; (mov r8, r8)
    595c:	20000cb5 	.word	0x20000cb5

00005960 <set_mods>:
void set_mods(uint8_t mods) { real_mods = mods; }
    5960:	4b01      	ldr	r3, [pc, #4]	; (5968 <set_mods+0x8>)
    5962:	7018      	strb	r0, [r3, #0]
    5964:	4770      	bx	lr
    5966:	46c0      	nop			; (mov r8, r8)
    5968:	20000cb5 	.word	0x20000cb5
    596c:	00000000 	.word	0x00000000

00005970 <clear_mods>:
void clear_mods(void) { real_mods = 0; }
    5970:	2200      	movs	r2, #0
    5972:	4b01      	ldr	r3, [pc, #4]	; (5978 <clear_mods+0x8>)
    5974:	701a      	strb	r2, [r3, #0]
    5976:	4770      	bx	lr
    5978:	20000cb5 	.word	0x20000cb5
    597c:	00000000 	.word	0x00000000

00005980 <add_weak_mods>:
void add_weak_mods(uint8_t mods) { weak_mods |= mods; }
    5980:	4b02      	ldr	r3, [pc, #8]	; (598c <add_weak_mods+0xc>)
    5982:	781a      	ldrb	r2, [r3, #0]
    5984:	4310      	orrs	r0, r2
    5986:	7018      	strb	r0, [r3, #0]
    5988:	4770      	bx	lr
    598a:	46c0      	nop			; (mov r8, r8)
    598c:	20000cb6 	.word	0x20000cb6

00005990 <del_weak_mods>:
void del_weak_mods(uint8_t mods) { weak_mods &= ~mods; }
    5990:	4a02      	ldr	r2, [pc, #8]	; (599c <del_weak_mods+0xc>)
    5992:	7813      	ldrb	r3, [r2, #0]
    5994:	4383      	bics	r3, r0
    5996:	7013      	strb	r3, [r2, #0]
    5998:	4770      	bx	lr
    599a:	46c0      	nop			; (mov r8, r8)
    599c:	20000cb6 	.word	0x20000cb6

000059a0 <clear_weak_mods>:
void clear_weak_mods(void) { weak_mods = 0; }
    59a0:	2200      	movs	r2, #0
    59a2:	4b01      	ldr	r3, [pc, #4]	; (59a8 <clear_weak_mods+0x8>)
    59a4:	701a      	strb	r2, [r3, #0]
    59a6:	4770      	bx	lr
    59a8:	20000cb6 	.word	0x20000cb6
    59ac:	00000000 	.word	0x00000000

000059b0 <set_oneshot_mods>:
    oneshot_mods = mods;
    59b0:	4b01      	ldr	r3, [pc, #4]	; (59b8 <set_oneshot_mods+0x8>)
    59b2:	7018      	strb	r0, [r3, #0]
}
    59b4:	4770      	bx	lr
    59b6:	46c0      	nop			; (mov r8, r8)
    59b8:	20000cb4 	.word	0x20000cb4
    59bc:	00000000 	.word	0x00000000

000059c0 <clear_oneshot_mods>:
    oneshot_mods = 0;
    59c0:	2200      	movs	r2, #0
    59c2:	4b01      	ldr	r3, [pc, #4]	; (59c8 <clear_oneshot_mods+0x8>)
    59c4:	701a      	strb	r2, [r3, #0]
}
    59c6:	4770      	bx	lr
    59c8:	20000cb4 	.word	0x20000cb4
    59cc:	00000000 	.word	0x00000000

000059d0 <keycode_to_action>:



/* translates keycode to action */
static action_t keycode_to_action(uint8_t keycode)
{
    59d0:	b510      	push	{r4, lr}
    59d2:	0003      	movs	r3, r0
    switch (keycode) {
    59d4:	28bc      	cmp	r0, #188	; 0xbc
    59d6:	d809      	bhi.n	59ec <keycode_to_action+0x1c>
    59d8:	28a8      	cmp	r0, #168	; 0xa8
    59da:	d218      	bcs.n	5a0e <keycode_to_action+0x3e>
    59dc:	28a4      	cmp	r0, #164	; 0xa4
    59de:	d851      	bhi.n	5a84 <keycode_to_action+0xb4>
    59e0:	2804      	cmp	r0, #4
    59e2:	d24d      	bcs.n	5a80 <keycode_to_action+0xb0>
            break;
        case KC_MS_UP ... KC_MS_ACCEL2:
            return (action_t)ACTION_MOUSEKEY(keycode);
            break;
        case KC_TRNS:
            return (action_t)ACTION_TRANSPARENT;
    59e4:	2001      	movs	r0, #1
    switch (keycode) {
    59e6:	2b01      	cmp	r3, #1
    59e8:	d10f      	bne.n	5a0a <keycode_to_action+0x3a>
        default:
            return (action_t)ACTION_NO;
            break;
    }
    return (action_t)ACTION_NO;
}
    59ea:	bd10      	pop	{r4, pc}
    switch (keycode) {
    59ec:	28e7      	cmp	r0, #231	; 0xe7
    59ee:	d841      	bhi.n	5a74 <keycode_to_action+0xa4>
    59f0:	28e0      	cmp	r0, #224	; 0xe0
    59f2:	d245      	bcs.n	5a80 <keycode_to_action+0xb0>
    59f4:	28bf      	cmp	r0, #191	; 0xbf
    59f6:	d108      	bne.n	5a0a <keycode_to_action+0x3a>
            clear_keyboard();
    59f8:	f7ff f96a 	bl	4cd0 <clear_keyboard>
            wait_ms(50);
    59fc:	2032      	movs	r0, #50	; 0x32
    59fe:	f7fb fef7 	bl	17f0 <chThdSleep>
            bootloader_jump(); // not return
    5a02:	f000 fc5d 	bl	62c0 <bootloader_jump>
    return (action_t)ACTION_NO;
    5a06:	2000      	movs	r0, #0
    5a08:	e7ef      	b.n	59ea <keycode_to_action+0x1a>
            return (action_t)ACTION_NO;
    5a0a:	2000      	movs	r0, #0
    5a0c:	e7ed      	b.n	59ea <keycode_to_action+0x1a>
            return (action_t)ACTION_USAGE_CONSUMER(KEYCODE2CONSUMER(keycode));
    5a0e:	28a8      	cmp	r0, #168	; 0xa8
    5a10:	d042      	beq.n	5a98 <keycode_to_action+0xc8>
    5a12:	28a9      	cmp	r0, #169	; 0xa9
    5a14:	d044      	beq.n	5aa0 <keycode_to_action+0xd0>
    5a16:	28aa      	cmp	r0, #170	; 0xaa
    5a18:	d03c      	beq.n	5a94 <keycode_to_action+0xc4>
    5a1a:	28ab      	cmp	r0, #171	; 0xab
    5a1c:	d042      	beq.n	5aa4 <keycode_to_action+0xd4>
    5a1e:	28ac      	cmp	r0, #172	; 0xac
    5a20:	d042      	beq.n	5aa8 <keycode_to_action+0xd8>
    5a22:	28ad      	cmp	r0, #173	; 0xad
    5a24:	d042      	beq.n	5aac <keycode_to_action+0xdc>
    5a26:	28ae      	cmp	r0, #174	; 0xae
    5a28:	d042      	beq.n	5ab0 <keycode_to_action+0xe0>
    5a2a:	28af      	cmp	r0, #175	; 0xaf
    5a2c:	d042      	beq.n	5ab4 <keycode_to_action+0xe4>
    5a2e:	28b1      	cmp	r0, #177	; 0xb1
    5a30:	d042      	beq.n	5ab8 <keycode_to_action+0xe8>
    5a32:	28b0      	cmp	r0, #176	; 0xb0
    5a34:	d042      	beq.n	5abc <keycode_to_action+0xec>
    5a36:	28b2      	cmp	r0, #178	; 0xb2
    5a38:	d042      	beq.n	5ac0 <keycode_to_action+0xf0>
    5a3a:	28b3      	cmp	r0, #179	; 0xb3
    5a3c:	d042      	beq.n	5ac4 <keycode_to_action+0xf4>
    5a3e:	28b4      	cmp	r0, #180	; 0xb4
    5a40:	d042      	beq.n	5ac8 <keycode_to_action+0xf8>
    5a42:	28b5      	cmp	r0, #181	; 0xb5
    5a44:	d042      	beq.n	5acc <keycode_to_action+0xfc>
    5a46:	28b6      	cmp	r0, #182	; 0xb6
    5a48:	d042      	beq.n	5ad0 <keycode_to_action+0x100>
    5a4a:	28b7      	cmp	r0, #183	; 0xb7
    5a4c:	d042      	beq.n	5ad4 <keycode_to_action+0x104>
    5a4e:	28b8      	cmp	r0, #184	; 0xb8
    5a50:	d042      	beq.n	5ad8 <keycode_to_action+0x108>
    5a52:	28b9      	cmp	r0, #185	; 0xb9
    5a54:	d044      	beq.n	5ae0 <keycode_to_action+0x110>
    5a56:	28ba      	cmp	r0, #186	; 0xba
    5a58:	d040      	beq.n	5adc <keycode_to_action+0x10c>
    5a5a:	28bb      	cmp	r0, #187	; 0xbb
    5a5c:	d042      	beq.n	5ae4 <keycode_to_action+0x114>
    5a5e:	3bbc      	subs	r3, #188	; 0xbc
    5a60:	4258      	negs	r0, r3
    5a62:	4143      	adcs	r3, r0
    5a64:	4820      	ldr	r0, [pc, #128]	; (5ae8 <keycode_to_action+0x118>)
    5a66:	425b      	negs	r3, r3
    5a68:	4018      	ands	r0, r3
    5a6a:	2388      	movs	r3, #136	; 0x88
    5a6c:	01db      	lsls	r3, r3, #7
    5a6e:	469c      	mov	ip, r3
    5a70:	4460      	add	r0, ip
    5a72:	e7ba      	b.n	59ea <keycode_to_action+0x1a>
    switch (keycode) {
    5a74:	28f0      	cmp	r0, #240	; 0xf0
    5a76:	d3c8      	bcc.n	5a0a <keycode_to_action+0x3a>
            return (action_t)ACTION_MOUSEKEY(keycode);
    5a78:	20a0      	movs	r0, #160	; 0xa0
    5a7a:	01c0      	lsls	r0, r0, #7
    5a7c:	4318      	orrs	r0, r3
    5a7e:	e7b4      	b.n	59ea <keycode_to_action+0x1a>
            return (action_t)ACTION_KEY(keycode);
    5a80:	1c18      	adds	r0, r3, #0
    5a82:	e7b2      	b.n	59ea <keycode_to_action+0x1a>
            return (action_t)ACTION_USAGE_SYSTEM(KEYCODE2SYSTEM(keycode));
    5a84:	28a5      	cmp	r0, #165	; 0xa5
    5a86:	d009      	beq.n	5a9c <keycode_to_action+0xcc>
    5a88:	3ba6      	subs	r3, #166	; 0xa6
    5a8a:	1e58      	subs	r0, r3, #1
    5a8c:	4183      	sbcs	r3, r0
    5a8e:	4a17      	ldr	r2, [pc, #92]	; (5aec <keycode_to_action+0x11c>)
    5a90:	1898      	adds	r0, r3, r2
    5a92:	e7aa      	b.n	59ea <keycode_to_action+0x1a>
            return (action_t)ACTION_USAGE_CONSUMER(KEYCODE2CONSUMER(keycode));
    5a94:	4816      	ldr	r0, [pc, #88]	; (5af0 <keycode_to_action+0x120>)
    5a96:	e7a8      	b.n	59ea <keycode_to_action+0x1a>
    5a98:	4816      	ldr	r0, [pc, #88]	; (5af4 <keycode_to_action+0x124>)
    5a9a:	e7a6      	b.n	59ea <keycode_to_action+0x1a>
            return (action_t)ACTION_USAGE_SYSTEM(KEYCODE2SYSTEM(keycode));
    5a9c:	4816      	ldr	r0, [pc, #88]	; (5af8 <keycode_to_action+0x128>)
    5a9e:	e7a4      	b.n	59ea <keycode_to_action+0x1a>
            return (action_t)ACTION_USAGE_CONSUMER(KEYCODE2CONSUMER(keycode));
    5aa0:	4816      	ldr	r0, [pc, #88]	; (5afc <keycode_to_action+0x12c>)
    5aa2:	e7a2      	b.n	59ea <keycode_to_action+0x1a>
    5aa4:	4816      	ldr	r0, [pc, #88]	; (5b00 <keycode_to_action+0x130>)
    5aa6:	e7a0      	b.n	59ea <keycode_to_action+0x1a>
    5aa8:	4816      	ldr	r0, [pc, #88]	; (5b04 <keycode_to_action+0x134>)
    5aaa:	e79e      	b.n	59ea <keycode_to_action+0x1a>
    5aac:	4816      	ldr	r0, [pc, #88]	; (5b08 <keycode_to_action+0x138>)
    5aae:	e79c      	b.n	59ea <keycode_to_action+0x1a>
    5ab0:	4816      	ldr	r0, [pc, #88]	; (5b0c <keycode_to_action+0x13c>)
    5ab2:	e79a      	b.n	59ea <keycode_to_action+0x1a>
    5ab4:	4816      	ldr	r0, [pc, #88]	; (5b10 <keycode_to_action+0x140>)
    5ab6:	e798      	b.n	59ea <keycode_to_action+0x1a>
    5ab8:	4816      	ldr	r0, [pc, #88]	; (5b14 <keycode_to_action+0x144>)
    5aba:	e796      	b.n	59ea <keycode_to_action+0x1a>
    5abc:	4816      	ldr	r0, [pc, #88]	; (5b18 <keycode_to_action+0x148>)
    5abe:	e794      	b.n	59ea <keycode_to_action+0x1a>
    5ac0:	4816      	ldr	r0, [pc, #88]	; (5b1c <keycode_to_action+0x14c>)
    5ac2:	e792      	b.n	59ea <keycode_to_action+0x1a>
    5ac4:	4816      	ldr	r0, [pc, #88]	; (5b20 <keycode_to_action+0x150>)
    5ac6:	e790      	b.n	59ea <keycode_to_action+0x1a>
    5ac8:	4816      	ldr	r0, [pc, #88]	; (5b24 <keycode_to_action+0x154>)
    5aca:	e78e      	b.n	59ea <keycode_to_action+0x1a>
    5acc:	4816      	ldr	r0, [pc, #88]	; (5b28 <keycode_to_action+0x158>)
    5ace:	e78c      	b.n	59ea <keycode_to_action+0x1a>
    5ad0:	4816      	ldr	r0, [pc, #88]	; (5b2c <keycode_to_action+0x15c>)
    5ad2:	e78a      	b.n	59ea <keycode_to_action+0x1a>
    5ad4:	4816      	ldr	r0, [pc, #88]	; (5b30 <keycode_to_action+0x160>)
    5ad6:	e788      	b.n	59ea <keycode_to_action+0x1a>
    5ad8:	4816      	ldr	r0, [pc, #88]	; (5b34 <keycode_to_action+0x164>)
    5ada:	e786      	b.n	59ea <keycode_to_action+0x1a>
    5adc:	4816      	ldr	r0, [pc, #88]	; (5b38 <keycode_to_action+0x168>)
    5ade:	e784      	b.n	59ea <keycode_to_action+0x1a>
    5ae0:	4816      	ldr	r0, [pc, #88]	; (5b3c <keycode_to_action+0x16c>)
    5ae2:	e782      	b.n	59ea <keycode_to_action+0x1a>
    5ae4:	4816      	ldr	r0, [pc, #88]	; (5b40 <keycode_to_action+0x170>)
    5ae6:	e780      	b.n	59ea <keycode_to_action+0x1a>
    5ae8:	0000022a 	.word	0x0000022a
    5aec:	00004082 	.word	0x00004082
    5af0:	000044ea 	.word	0x000044ea
    5af4:	000044e2 	.word	0x000044e2
    5af8:	00004081 	.word	0x00004081
    5afc:	000044e9 	.word	0x000044e9
    5b00:	000044b5 	.word	0x000044b5
    5b04:	000044b6 	.word	0x000044b6
    5b08:	000044b3 	.word	0x000044b3
    5b0c:	000044b4 	.word	0x000044b4
    5b10:	000044b7 	.word	0x000044b7
    5b14:	000044cc 	.word	0x000044cc
    5b18:	000044cd 	.word	0x000044cd
    5b1c:	00004583 	.word	0x00004583
    5b20:	0000458a 	.word	0x0000458a
    5b24:	00004592 	.word	0x00004592
    5b28:	00004594 	.word	0x00004594
    5b2c:	00004621 	.word	0x00004621
    5b30:	00004623 	.word	0x00004623
    5b34:	00004624 	.word	0x00004624
    5b38:	00004626 	.word	0x00004626
    5b3c:	00004625 	.word	0x00004625
    5b40:	00004627 	.word	0x00004627
	...

00005b50 <action_function>:
}
    5b50:	4770      	bx	lr
    5b52:	46c0      	nop			; (mov r8, r8)
	...

00005b60 <action_for_key>:
{
    5b60:	b500      	push	{lr}
    5b62:	b083      	sub	sp, #12
    5b64:	ab01      	add	r3, sp, #4
    5b66:	8019      	strh	r1, [r3, #0]
    uint8_t keycode = keymap_key_to_keycode(layer, key);
    5b68:	9901      	ldr	r1, [sp, #4]
    5b6a:	f7fe fbd9 	bl	4320 <keymap_key_to_keycode>
    switch (keycode) {
    5b6e:	28df      	cmp	r0, #223	; 0xdf
    5b70:	d80e      	bhi.n	5b90 <action_for_key+0x30>
    5b72:	28c0      	cmp	r0, #192	; 0xc0
    5b74:	d23a      	bcs.n	5bec <action_for_key+0x8c>
    5b76:	2831      	cmp	r0, #49	; 0x31
    5b78:	d042      	beq.n	5c00 <action_for_key+0xa0>
    5b7a:	d818      	bhi.n	5bae <action_for_key+0x4e>
    5b7c:	2829      	cmp	r0, #41	; 0x29
    5b7e:	d02f      	beq.n	5be0 <action_for_key+0x80>
    5b80:	282a      	cmp	r0, #42	; 0x2a
    5b82:	d14f      	bne.n	5c24 <action_for_key+0xc4>
            if (keymap_config.swap_backslash_backspace) {
    5b84:	4b2d      	ldr	r3, [pc, #180]	; (5c3c <action_for_key+0xdc>)
    5b86:	781b      	ldrb	r3, [r3, #0]
    5b88:	065b      	lsls	r3, r3, #25
    5b8a:	d53d      	bpl.n	5c08 <action_for_key+0xa8>
    5b8c:	2031      	movs	r0, #49	; 0x31
    5b8e:	e02f      	b.n	5bf0 <action_for_key+0x90>
    switch (keycode) {
    5b90:	28e3      	cmp	r0, #227	; 0xe3
    5b92:	d03b      	beq.n	5c0c <action_for_key+0xac>
    5b94:	d917      	bls.n	5bc6 <action_for_key+0x66>
    5b96:	28e6      	cmp	r0, #230	; 0xe6
    5b98:	d03e      	beq.n	5c18 <action_for_key+0xb8>
    5b9a:	28e7      	cmp	r0, #231	; 0xe7
    5b9c:	d142      	bne.n	5c24 <action_for_key+0xc4>
            if (keymap_config.swap_ralt_rgui) {
    5b9e:	4b27      	ldr	r3, [pc, #156]	; (5c3c <action_for_key+0xdc>)
    5ba0:	781b      	ldrb	r3, [r3, #0]
    5ba2:	071a      	lsls	r2, r3, #28
    5ba4:	d43c      	bmi.n	5c20 <action_for_key+0xc0>
            if (keymap_config.no_gui) {
    5ba6:	06db      	lsls	r3, r3, #27
    5ba8:	d546      	bpl.n	5c38 <action_for_key+0xd8>
    5baa:	2000      	movs	r0, #0
    5bac:	e020      	b.n	5bf0 <action_for_key+0x90>
    switch (keycode) {
    5bae:	2839      	cmp	r0, #57	; 0x39
    5bb0:	d020      	beq.n	5bf4 <action_for_key+0x94>
    5bb2:	2882      	cmp	r0, #130	; 0x82
    5bb4:	d01e      	beq.n	5bf4 <action_for_key+0x94>
    5bb6:	2835      	cmp	r0, #53	; 0x35
    5bb8:	d134      	bne.n	5c24 <action_for_key+0xc4>
            if (keymap_config.swap_grave_esc) {
    5bba:	4b20      	ldr	r3, [pc, #128]	; (5c3c <action_for_key+0xdc>)
    5bbc:	781b      	ldrb	r3, [r3, #0]
    5bbe:	069b      	lsls	r3, r3, #26
    5bc0:	d512      	bpl.n	5be8 <action_for_key+0x88>
    5bc2:	2029      	movs	r0, #41	; 0x29
    5bc4:	e014      	b.n	5bf0 <action_for_key+0x90>
    switch (keycode) {
    5bc6:	28e0      	cmp	r0, #224	; 0xe0
    5bc8:	d02f      	beq.n	5c2a <action_for_key+0xca>
    5bca:	28e2      	cmp	r0, #226	; 0xe2
    5bcc:	d12a      	bne.n	5c24 <action_for_key+0xc4>
            if (keymap_config.swap_lalt_lgui) {
    5bce:	4b1b      	ldr	r3, [pc, #108]	; (5c3c <action_for_key+0xdc>)
    5bd0:	781b      	ldrb	r3, [r3, #0]
    5bd2:	075a      	lsls	r2, r3, #29
    5bd4:	d51e      	bpl.n	5c14 <action_for_key+0xb4>
    5bd6:	20e3      	movs	r0, #227	; 0xe3
                if (keymap_config.no_gui) {
    5bd8:	06db      	lsls	r3, r3, #27
    5bda:	d509      	bpl.n	5bf0 <action_for_key+0x90>
    5bdc:	2000      	movs	r0, #0
    5bde:	e007      	b.n	5bf0 <action_for_key+0x90>
            if (keymap_config.swap_grave_esc) {
    5be0:	4b16      	ldr	r3, [pc, #88]	; (5c3c <action_for_key+0xdc>)
    5be2:	781b      	ldrb	r3, [r3, #0]
    5be4:	069b      	lsls	r3, r3, #26
    5be6:	d5ec      	bpl.n	5bc2 <action_for_key+0x62>
    5be8:	2035      	movs	r0, #53	; 0x35
    5bea:	e001      	b.n	5bf0 <action_for_key+0x90>
            return keymap_fn_to_action(keycode);
    5bec:	f7fe fbb0 	bl	4350 <keymap_fn_to_action>
}
    5bf0:	b003      	add	sp, #12
    5bf2:	bd00      	pop	{pc}
            if (keymap_config.swap_control_capslock || keymap_config.capslock_to_control) {
    5bf4:	4b11      	ldr	r3, [pc, #68]	; (5c3c <action_for_key+0xdc>)
    5bf6:	781b      	ldrb	r3, [r3, #0]
    5bf8:	079b      	lsls	r3, r3, #30
    5bfa:	d013      	beq.n	5c24 <action_for_key+0xc4>
    5bfc:	20e0      	movs	r0, #224	; 0xe0
    5bfe:	e7f7      	b.n	5bf0 <action_for_key+0x90>
            if (keymap_config.swap_backslash_backspace) {
    5c00:	4b0e      	ldr	r3, [pc, #56]	; (5c3c <action_for_key+0xdc>)
    5c02:	781b      	ldrb	r3, [r3, #0]
    5c04:	065b      	lsls	r3, r3, #25
    5c06:	d5c1      	bpl.n	5b8c <action_for_key+0x2c>
    5c08:	202a      	movs	r0, #42	; 0x2a
    5c0a:	e7f1      	b.n	5bf0 <action_for_key+0x90>
            if (keymap_config.swap_lalt_lgui) {
    5c0c:	4b0b      	ldr	r3, [pc, #44]	; (5c3c <action_for_key+0xdc>)
    5c0e:	781b      	ldrb	r3, [r3, #0]
    5c10:	075a      	lsls	r2, r3, #29
    5c12:	d5e0      	bpl.n	5bd6 <action_for_key+0x76>
    5c14:	20e2      	movs	r0, #226	; 0xe2
    5c16:	e7eb      	b.n	5bf0 <action_for_key+0x90>
            if (keymap_config.swap_ralt_rgui) {
    5c18:	4b08      	ldr	r3, [pc, #32]	; (5c3c <action_for_key+0xdc>)
    5c1a:	781b      	ldrb	r3, [r3, #0]
    5c1c:	071a      	lsls	r2, r3, #28
    5c1e:	d4c2      	bmi.n	5ba6 <action_for_key+0x46>
    5c20:	20e6      	movs	r0, #230	; 0xe6
    5c22:	e7e5      	b.n	5bf0 <action_for_key+0x90>
            return keycode_to_action(keycode);
    5c24:	f7ff fed4 	bl	59d0 <keycode_to_action>
    5c28:	e7e2      	b.n	5bf0 <action_for_key+0x90>
            if (keymap_config.swap_control_capslock) {
    5c2a:	4b04      	ldr	r3, [pc, #16]	; (5c3c <action_for_key+0xdc>)
    5c2c:	2039      	movs	r0, #57	; 0x39
    5c2e:	781b      	ldrb	r3, [r3, #0]
    5c30:	07db      	lsls	r3, r3, #31
    5c32:	d4dd      	bmi.n	5bf0 <action_for_key+0x90>
    5c34:	20e0      	movs	r0, #224	; 0xe0
    5c36:	e7db      	b.n	5bf0 <action_for_key+0x90>
    5c38:	20e7      	movs	r0, #231	; 0xe7
    5c3a:	e7d9      	b.n	5bf0 <action_for_key+0x90>
    5c3c:	20000cc4 	.word	0x20000cc4

00005c40 <bitrev16>:
    bits = (bits & 0b01010101)<<1 | (bits & 0b10101010)>>1;
    return bits;
}

uint16_t bitrev16(uint16_t bits)
{
    5c40:	b510      	push	{r4, lr}
    bits = (bits & 0b00110011)<<2 | (bits & 0b11001100)>>2;
    5c42:	2433      	movs	r4, #51	; 0x33
    bits = bitrev(bits & 0x00ff)<<8 | bitrev((bits & 0xff00)>>8);
    5c44:	b2c3      	uxtb	r3, r0
    bits = (bits & 0x0f)<<4 | (bits & 0xf0)>>4;
    5c46:	0119      	lsls	r1, r3, #4
    5c48:	091b      	lsrs	r3, r3, #4
    5c4a:	4319      	orrs	r1, r3
    bits = (bits & 0b00110011)<<2 | (bits & 0b11001100)>>2;
    5c4c:	b2c9      	uxtb	r1, r1
    5c4e:	008b      	lsls	r3, r1, #2
    5c50:	1089      	asrs	r1, r1, #2
    5c52:	4021      	ands	r1, r4
    5c54:	43a3      	bics	r3, r4
    bits = bitrev(bits & 0x00ff)<<8 | bitrev((bits & 0xff00)>>8);
    5c56:	0a00      	lsrs	r0, r0, #8
    bits = (bits & 0b00110011)<<2 | (bits & 0b11001100)>>2;
    5c58:	430b      	orrs	r3, r1
    bits = (bits & 0x0f)<<4 | (bits & 0xf0)>>4;
    5c5a:	0101      	lsls	r1, r0, #4
    5c5c:	0900      	lsrs	r0, r0, #4
    5c5e:	4308      	orrs	r0, r1
    bits = (bits & 0b01010101)<<1 | (bits & 0b10101010)>>1;
    5c60:	2155      	movs	r1, #85	; 0x55
    bits = (bits & 0b00110011)<<2 | (bits & 0b11001100)>>2;
    5c62:	b2c0      	uxtb	r0, r0
    5c64:	0082      	lsls	r2, r0, #2
    5c66:	1080      	asrs	r0, r0, #2
    5c68:	4020      	ands	r0, r4
    bits = (bits & 0b01010101)<<1 | (bits & 0b10101010)>>1;
    5c6a:	b2db      	uxtb	r3, r3
    bits = (bits & 0b00110011)<<2 | (bits & 0b11001100)>>2;
    5c6c:	43a2      	bics	r2, r4
    5c6e:	4302      	orrs	r2, r0
    bits = (bits & 0b01010101)<<1 | (bits & 0b10101010)>>1;
    5c70:	0058      	lsls	r0, r3, #1
    5c72:	105b      	asrs	r3, r3, #1
    5c74:	4388      	bics	r0, r1
    5c76:	b2d2      	uxtb	r2, r2
    5c78:	400b      	ands	r3, r1
    5c7a:	4303      	orrs	r3, r0
    5c7c:	0050      	lsls	r0, r2, #1
    5c7e:	1052      	asrs	r2, r2, #1
    5c80:	4388      	bics	r0, r1
    5c82:	400a      	ands	r2, r1
    5c84:	4310      	orrs	r0, r2
    bits = bitrev(bits & 0x00ff)<<8 | bitrev((bits & 0xff00)>>8);
    5c86:	b2db      	uxtb	r3, r3
    5c88:	021b      	lsls	r3, r3, #8
    5c8a:	b2c0      	uxtb	r0, r0
    return bits;
    5c8c:	4318      	orrs	r0, r3
}
    5c8e:	bd10      	pop	{r4, pc}

00005c90 <hook_keyboard_loop>:
/* -------------------------------------------------
 * Definitions of default hooks
 * ------------------------------------------------- */

__attribute__((weak))
void hook_keyboard_loop(void) {}
    5c90:	4770      	bx	lr
    5c92:	46c0      	nop			; (mov r8, r8)
	...

00005ca0 <hook_matrix_change>:

__attribute__((weak))
void hook_matrix_change(keyevent_t event) {
    5ca0:	b082      	sub	sp, #8
    (void)event;
}
    5ca2:	b002      	add	sp, #8
    5ca4:	4770      	bx	lr
    5ca6:	46c0      	nop			; (mov r8, r8)
	...

00005cb0 <hook_default_layer_change>:

__attribute__((weak))
void hook_default_layer_change(uint32_t default_layer_state) {
    (void)default_layer_state;
}
    5cb0:	4770      	bx	lr
    5cb2:	46c0      	nop			; (mov r8, r8)
	...

00005cc0 <hook_layer_change>:
    5cc0:	4770      	bx	lr
    5cc2:	46c0      	nop			; (mov r8, r8)
	...

00005cd0 <hook_keyboard_leds_change>:
void hook_layer_change(uint32_t layer_state) {
    (void)layer_state;
}

__attribute__((weak))
void hook_keyboard_leds_change(uint8_t led_status) {
    5cd0:	b510      	push	{r4, lr}
    keyboard_set_leds(led_status);
    5cd2:	f7fe fcad 	bl	4630 <keyboard_set_leds>
}
    5cd6:	bd10      	pop	{r4, pc}
	...

00005ce0 <hook_bootmagic>:
    5ce0:	4770      	bx	lr
    5ce2:	46c0      	nop			; (mov r8, r8)
	...

00005cf0 <suspend_power_down>:
void suspend_idle(uint8_t time) {
	// TODO: this is not used anywhere - what units is 'time' in?
	chThdSleepMilliseconds(time);
}

void suspend_power_down(void) {
    5cf0:	b510      	push	{r4, lr}
	// also shouldn't power down USB

	// on AVR, this enables the watchdog for 15ms (max), and goes to
	// SLEEP_MODE_PWR_DOWN

	chThdSleepMilliseconds(17);
    5cf2:	2011      	movs	r0, #17
    5cf4:	f7fb fd7c 	bl	17f0 <chThdSleep>
}
    5cf8:	bd10      	pop	{r4, pc}
    5cfa:	46c0      	nop			; (mov r8, r8)
    5cfc:	0000      	movs	r0, r0
	...

00005d00 <matrix_power_up>:

__attribute__ ((weak)) void matrix_power_up(void) {}
    5d00:	4770      	bx	lr
    5d02:	46c0      	nop			; (mov r8, r8)
	...

00005d10 <matrix_power_down>:
    5d10:	4770      	bx	lr
    5d12:	46c0      	nop			; (mov r8, r8)
	...

00005d20 <suspend_wakeup_condition>:
__attribute__ ((weak)) void matrix_power_down(void) {}
bool suspend_wakeup_condition(void)
{
    5d20:	b510      	push	{r4, lr}
    matrix_power_up();
    5d22:	f7ff ffed 	bl	5d00 <matrix_power_up>
    matrix_scan();
    matrix_power_down();
    for (uint8_t r = 0; r < MATRIX_ROWS; r++) {
    5d26:	2400      	movs	r4, #0
    matrix_scan();
    5d28:	f7fe f9b2 	bl	4090 <matrix_scan>
    matrix_power_down();
    5d2c:	f7ff fff0 	bl	5d10 <matrix_power_down>
        if (matrix_get_row(r)) return true;
    5d30:	0020      	movs	r0, r4
    5d32:	f7fe fab5 	bl	42a0 <matrix_get_row>
    5d36:	2800      	cmp	r0, #0
    5d38:	d104      	bne.n	5d44 <suspend_wakeup_condition+0x24>
    for (uint8_t r = 0; r < MATRIX_ROWS; r++) {
    5d3a:	3401      	adds	r4, #1
    5d3c:	b2e4      	uxtb	r4, r4
    5d3e:	2c04      	cmp	r4, #4
    5d40:	d1f6      	bne.n	5d30 <suspend_wakeup_condition+0x10>
    }
    return false;
}
    5d42:	bd10      	pop	{r4, pc}
        if (matrix_get_row(r)) return true;
    5d44:	2001      	movs	r0, #1
    5d46:	e7fc      	b.n	5d42 <suspend_wakeup_condition+0x22>
	...

00005d50 <suspend_wakeup_init>:

// run immediately after wakeup
void suspend_wakeup_init(void)
{
    5d50:	b510      	push	{r4, lr}
    // need to do it manually, because we're running from ISR
    //  and clear_keyboard() calls print
    // so only clear the variables in memory
    // the reports will be sent from main.c afterwards
    // or if the PC asks for GET_REPORT
    clear_mods();
    5d52:	f7ff fe0d 	bl	5970 <clear_mods>
    clear_weak_mods();
    5d56:	f7ff fe23 	bl	59a0 <clear_weak_mods>
    clear_keys();
    5d5a:	f7ff fdd9 	bl	5910 <clear_keys>
#ifdef MOUSEKEY_ENABLE
    mousekey_clear();
    5d5e:	f001 f8af 	bl	6ec0 <mousekey_clear>
#endif /* MOUSEKEY_ENABLE */
#ifdef EXTRAKEY_ENABLE
    host_system_send(0);
    5d62:	2000      	movs	r0, #0
    5d64:	f7fe fb7c 	bl	4460 <host_system_send>
    host_consumer_send(0);
    5d68:	2000      	movs	r0, #0
    5d6a:	f7fe fba1 	bl	44b0 <host_consumer_send>
#endif /* EXTRAKEY_ENABLE */
#ifdef BACKLIGHT_ENABLE
    backlight_init();
#endif /* BACKLIGHT_ENABLE */
}
    5d6e:	bd10      	pop	{r4, pc}

00005d70 <uli2a>:
#define PRINTF_LONG_SUPPORT

#ifdef PRINTF_LONG_SUPPORT

static void uli2a(unsigned long int num, unsigned int base, int uc,char * bf)
    {
    5d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5d72:	4645      	mov	r5, r8
    5d74:	4657      	mov	r7, sl
    5d76:	464e      	mov	r6, r9
    5d78:	46de      	mov	lr, fp
    5d7a:	4698      	mov	r8, r3
    5d7c:	b5e0      	push	{r5, r6, r7, lr}
    int n=0;
    unsigned int d=1;
    5d7e:	2401      	movs	r4, #1
    {
    5d80:	0006      	movs	r6, r0
    5d82:	000f      	movs	r7, r1
    5d84:	0015      	movs	r5, r2
    while (num/d >= base)
    5d86:	4288      	cmp	r0, r1
    5d88:	d308      	bcc.n	5d9c <uli2a+0x2c>
        d*=base;         
    5d8a:	437c      	muls	r4, r7
    while (num/d >= base)
    5d8c:	0030      	movs	r0, r6
    5d8e:	0021      	movs	r1, r4
    5d90:	f7fa fbcc 	bl	52c <__udivsi3>
    5d94:	42b8      	cmp	r0, r7
    5d96:	d2f8      	bcs.n	5d8a <uli2a+0x1a>
    while (d!=0) {
    5d98:	2c00      	cmp	r4, #0
    5d9a:	d02a      	beq.n	5df2 <uli2a+0x82>
    5d9c:	2300      	movs	r3, #0
    5d9e:	4699      	mov	r9, r3
        int dgt = num / d;
        num%=d;
        d/=base;
        if (n || dgt>0|| d==0) {
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5da0:	426b      	negs	r3, r5
    5da2:	415d      	adcs	r5, r3
    5da4:	426b      	negs	r3, r5
    5da6:	469a      	mov	sl, r3
    5da8:	2320      	movs	r3, #32
    5daa:	469b      	mov	fp, r3
    5dac:	0021      	movs	r1, r4
    5dae:	0030      	movs	r0, r6
    5db0:	f7fa fc42 	bl	638 <__aeabi_uidivmod>
    5db4:	0005      	movs	r5, r0
    5db6:	000e      	movs	r6, r1
        d/=base;
    5db8:	0020      	movs	r0, r4
    5dba:	0039      	movs	r1, r7
    5dbc:	f7fa fbb6 	bl	52c <__udivsi3>
        if (n || dgt>0|| d==0) {
    5dc0:	464b      	mov	r3, r9
        d/=base;
    5dc2:	0004      	movs	r4, r0
        if (n || dgt>0|| d==0) {
    5dc4:	2b00      	cmp	r3, #0
    5dc6:	d101      	bne.n	5dcc <uli2a+0x5c>
    5dc8:	2d00      	cmp	r5, #0
    5dca:	dd1b      	ble.n	5e04 <uli2a+0x94>
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5dcc:	2330      	movs	r3, #48	; 0x30
    5dce:	2d09      	cmp	r5, #9
    5dd0:	dd03      	ble.n	5dda <uli2a+0x6a>
    5dd2:	465b      	mov	r3, fp
    5dd4:	4652      	mov	r2, sl
    5dd6:	4013      	ands	r3, r2
    5dd8:	3337      	adds	r3, #55	; 0x37
    5dda:	195d      	adds	r5, r3, r5
    5ddc:	4643      	mov	r3, r8
    5dde:	701d      	strb	r5, [r3, #0]
            ++n;
    5de0:	2301      	movs	r3, #1
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5de2:	4642      	mov	r2, r8
            ++n;
    5de4:	469c      	mov	ip, r3
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5de6:	3201      	adds	r2, #1
            ++n;
    5de8:	44e1      	add	r9, ip
    while (d!=0) {
    5dea:	2c00      	cmp	r4, #0
    5dec:	d002      	beq.n	5df4 <uli2a+0x84>
    5dee:	4690      	mov	r8, r2
    5df0:	e7dc      	b.n	5dac <uli2a+0x3c>
    5df2:	4642      	mov	r2, r8
            }
        }
    *bf=0;
    5df4:	2300      	movs	r3, #0
    5df6:	7013      	strb	r3, [r2, #0]
    }
    5df8:	bc3c      	pop	{r2, r3, r4, r5}
    5dfa:	4690      	mov	r8, r2
    5dfc:	4699      	mov	r9, r3
    5dfe:	46a2      	mov	sl, r4
    5e00:	46ab      	mov	fp, r5
    5e02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (n || dgt>0|| d==0) {
    5e04:	2800      	cmp	r0, #0
    5e06:	d002      	beq.n	5e0e <uli2a+0x9e>
    5e08:	4642      	mov	r2, r8
    5e0a:	4690      	mov	r8, r2
    5e0c:	e7ce      	b.n	5dac <uli2a+0x3c>
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5e0e:	4643      	mov	r3, r8
    5e10:	3530      	adds	r5, #48	; 0x30
    5e12:	1c5a      	adds	r2, r3, #1
    5e14:	701d      	strb	r5, [r3, #0]
    5e16:	e7ed      	b.n	5df4 <uli2a+0x84>
	...

00005e20 <ui2a>:
    }

#endif

static void ui2a(unsigned int num, unsigned int base, int uc,char * bf)
    {
    5e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5e22:	4645      	mov	r5, r8
    5e24:	4657      	mov	r7, sl
    5e26:	464e      	mov	r6, r9
    5e28:	46de      	mov	lr, fp
    5e2a:	4698      	mov	r8, r3
    5e2c:	b5e0      	push	{r5, r6, r7, lr}
    int n=0;
    unsigned int d=1;
    5e2e:	2401      	movs	r4, #1
    {
    5e30:	0006      	movs	r6, r0
    5e32:	000f      	movs	r7, r1
    5e34:	0015      	movs	r5, r2
    while (num/d >= base)
    5e36:	4288      	cmp	r0, r1
    5e38:	d308      	bcc.n	5e4c <ui2a+0x2c>
        d*=base;        
    5e3a:	437c      	muls	r4, r7
    while (num/d >= base)
    5e3c:	0030      	movs	r0, r6
    5e3e:	0021      	movs	r1, r4
    5e40:	f7fa fb74 	bl	52c <__udivsi3>
    5e44:	42b8      	cmp	r0, r7
    5e46:	d2f8      	bcs.n	5e3a <ui2a+0x1a>
    while (d!=0) {
    5e48:	2c00      	cmp	r4, #0
    5e4a:	d02a      	beq.n	5ea2 <ui2a+0x82>
    5e4c:	2300      	movs	r3, #0
    5e4e:	4699      	mov	r9, r3
        int dgt = num / d;
        num%= d;
        d/=base;
        if (n || dgt>0 || d==0) {
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5e50:	426b      	negs	r3, r5
    5e52:	415d      	adcs	r5, r3
    5e54:	426b      	negs	r3, r5
    5e56:	469a      	mov	sl, r3
    5e58:	2320      	movs	r3, #32
    5e5a:	469b      	mov	fp, r3
    5e5c:	0021      	movs	r1, r4
    5e5e:	0030      	movs	r0, r6
    5e60:	f7fa fbea 	bl	638 <__aeabi_uidivmod>
    5e64:	0005      	movs	r5, r0
    5e66:	000e      	movs	r6, r1
        d/=base;
    5e68:	0020      	movs	r0, r4
    5e6a:	0039      	movs	r1, r7
    5e6c:	f7fa fb5e 	bl	52c <__udivsi3>
        if (n || dgt>0 || d==0) {
    5e70:	464b      	mov	r3, r9
        d/=base;
    5e72:	0004      	movs	r4, r0
        if (n || dgt>0 || d==0) {
    5e74:	2b00      	cmp	r3, #0
    5e76:	d101      	bne.n	5e7c <ui2a+0x5c>
    5e78:	2d00      	cmp	r5, #0
    5e7a:	dd1b      	ble.n	5eb4 <ui2a+0x94>
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5e7c:	2330      	movs	r3, #48	; 0x30
    5e7e:	2d09      	cmp	r5, #9
    5e80:	dd03      	ble.n	5e8a <ui2a+0x6a>
    5e82:	465b      	mov	r3, fp
    5e84:	4652      	mov	r2, sl
    5e86:	4013      	ands	r3, r2
    5e88:	3337      	adds	r3, #55	; 0x37
    5e8a:	195d      	adds	r5, r3, r5
    5e8c:	4643      	mov	r3, r8
    5e8e:	701d      	strb	r5, [r3, #0]
            ++n;
    5e90:	2301      	movs	r3, #1
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5e92:	4642      	mov	r2, r8
            ++n;
    5e94:	469c      	mov	ip, r3
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5e96:	3201      	adds	r2, #1
            ++n;
    5e98:	44e1      	add	r9, ip
    while (d!=0) {
    5e9a:	2c00      	cmp	r4, #0
    5e9c:	d002      	beq.n	5ea4 <ui2a+0x84>
    5e9e:	4690      	mov	r8, r2
    5ea0:	e7dc      	b.n	5e5c <ui2a+0x3c>
    5ea2:	4642      	mov	r2, r8
            }
        }
    *bf=0;
    5ea4:	2300      	movs	r3, #0
    5ea6:	7013      	strb	r3, [r2, #0]
    }
    5ea8:	bc3c      	pop	{r2, r3, r4, r5}
    5eaa:	4690      	mov	r8, r2
    5eac:	4699      	mov	r9, r3
    5eae:	46a2      	mov	sl, r4
    5eb0:	46ab      	mov	fp, r5
    5eb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (n || dgt>0 || d==0) {
    5eb4:	2800      	cmp	r0, #0
    5eb6:	d002      	beq.n	5ebe <ui2a+0x9e>
    5eb8:	4642      	mov	r2, r8
    5eba:	4690      	mov	r8, r2
    5ebc:	e7ce      	b.n	5e5c <ui2a+0x3c>
            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
    5ebe:	4643      	mov	r3, r8
    5ec0:	3530      	adds	r5, #48	; 0x30
    5ec2:	1c5a      	adds	r2, r3, #1
    5ec4:	701d      	strb	r5, [r3, #0]
    5ec6:	e7ed      	b.n	5ea4 <ui2a+0x84>
	...

00005ed0 <putchw>:
    *nump=num;
    return ch;
    }

static void putchw(void* putp,putcf putf,int n, char z, char* bf)
    {
    5ed0:	b5f0      	push	{r4, r5, r6, r7, lr}
    5ed2:	46c6      	mov	lr, r8
    5ed4:	000e      	movs	r6, r1
    char fc=z? '0' : ' ';
    5ed6:	4259      	negs	r1, r3
    5ed8:	414b      	adcs	r3, r1
    5eda:	210f      	movs	r1, #15
    {
    5edc:	b500      	push	{lr}
    char fc=z? '0' : ' ';
    5ede:	425d      	negs	r5, r3
    char ch;
    char* p=bf;
    while (*p++ && n > 0)
    5ee0:	9b06      	ldr	r3, [sp, #24]
    char fc=z? '0' : ' ';
    5ee2:	438d      	bics	r5, r1
    while (*p++ && n > 0)
    5ee4:	3301      	adds	r3, #1
    5ee6:	4698      	mov	r8, r3
    5ee8:	9b06      	ldr	r3, [sp, #24]
    {
    5eea:	0007      	movs	r7, r0
    while (*p++ && n > 0)
    5eec:	7819      	ldrb	r1, [r3, #0]
    char fc=z? '0' : ' ';
    5eee:	3530      	adds	r5, #48	; 0x30
    while (*p++ && n > 0)
    5ef0:	2900      	cmp	r1, #0
    5ef2:	d026      	beq.n	5f42 <putchw+0x72>
    5ef4:	2a00      	cmp	r2, #0
    5ef6:	dd19      	ble.n	5f2c <putchw+0x5c>
    5ef8:	4643      	mov	r3, r8
    5efa:	e003      	b.n	5f04 <putchw+0x34>
    5efc:	4662      	mov	r2, ip
    5efe:	3301      	adds	r3, #1
    5f00:	2a00      	cmp	r2, #0
    5f02:	d013      	beq.n	5f2c <putchw+0x5c>
        n--;
    5f04:	1e50      	subs	r0, r2, #1
    5f06:	4684      	mov	ip, r0
    while (*p++ && n > 0)
    5f08:	7818      	ldrb	r0, [r3, #0]
    5f0a:	2800      	cmp	r0, #0
    5f0c:	d1f6      	bne.n	5efc <putchw+0x2c>
    while (n-- > 0) 
    5f0e:	4663      	mov	r3, ip
    5f10:	1e94      	subs	r4, r2, #2
    5f12:	2b00      	cmp	r3, #0
    5f14:	d00a      	beq.n	5f2c <putchw+0x5c>
        putf(putp,fc);
    5f16:	0029      	movs	r1, r5
    5f18:	0038      	movs	r0, r7
    while (n-- > 0) 
    5f1a:	3c01      	subs	r4, #1
        putf(putp,fc);
    5f1c:	47b0      	blx	r6
    5f1e:	1c63      	adds	r3, r4, #1
    while (n-- > 0) 
    5f20:	2b00      	cmp	r3, #0
    5f22:	dcf8      	bgt.n	5f16 <putchw+0x46>
    while ((ch= *bf++))
    5f24:	9b06      	ldr	r3, [sp, #24]
    5f26:	7819      	ldrb	r1, [r3, #0]
    5f28:	2900      	cmp	r1, #0
    5f2a:	d007      	beq.n	5f3c <putchw+0x6c>
    5f2c:	4644      	mov	r4, r8
        putf(putp,ch);
    5f2e:	0038      	movs	r0, r7
    5f30:	3401      	adds	r4, #1
    5f32:	47b0      	blx	r6
    while ((ch= *bf++))
    5f34:	1e63      	subs	r3, r4, #1
    5f36:	7819      	ldrb	r1, [r3, #0]
    5f38:	2900      	cmp	r1, #0
    5f3a:	d1f8      	bne.n	5f2e <putchw+0x5e>
    }
    5f3c:	bc04      	pop	{r2}
    5f3e:	4690      	mov	r8, r2
    5f40:	bdf0      	pop	{r4, r5, r6, r7, pc}
    while (n-- > 0) 
    5f42:	1e54      	subs	r4, r2, #1
    5f44:	2a00      	cmp	r2, #0
    5f46:	ddf9      	ble.n	5f3c <putchw+0x6c>
    5f48:	e7e5      	b.n	5f16 <putchw+0x46>
    5f4a:	46c0      	nop			; (mov r8, r8)
    5f4c:	0000      	movs	r0, r0
	...

00005f50 <tfp_format>:

void tfp_format(void* putp,putcf putf,char *fmt, va_list va)
    {
    5f50:	b5f0      	push	{r4, r5, r6, r7, lr}
    5f52:	464e      	mov	r6, r9
    5f54:	46de      	mov	lr, fp
    5f56:	4645      	mov	r5, r8
    5f58:	4657      	mov	r7, sl
    5f5a:	4699      	mov	r9, r3
        *bf++ = '-';
    5f5c:	232d      	movs	r3, #45	; 0x2d
    {
    5f5e:	b5e0      	push	{r5, r6, r7, lr}
    5f60:	0014      	movs	r4, r2
    5f62:	b089      	sub	sp, #36	; 0x24
    5f64:	0006      	movs	r6, r0
    5f66:	000d      	movs	r5, r1
        *bf++ = '-';
    5f68:	469b      	mov	fp, r3
    char bf[12];
    
    char ch;


    while ((ch=*(fmt++))) {
    5f6a:	e004      	b.n	5f76 <tfp_format+0x26>
        if (ch!='%') 
    5f6c:	2925      	cmp	r1, #37	; 0x25
    5f6e:	d00d      	beq.n	5f8c <tfp_format+0x3c>
            putf(putp,ch);
    5f70:	0030      	movs	r0, r6
    5f72:	47a8      	blx	r5
    while ((ch=*(fmt++))) {
    5f74:	003c      	movs	r4, r7
    5f76:	7821      	ldrb	r1, [r4, #0]
    5f78:	1c67      	adds	r7, r4, #1
    5f7a:	2900      	cmp	r1, #0
    5f7c:	d1f6      	bne.n	5f6c <tfp_format+0x1c>
                    break;
                }
            }
        }
    abort:;
    }
    5f7e:	b009      	add	sp, #36	; 0x24
    5f80:	bc3c      	pop	{r2, r3, r4, r5}
    5f82:	4690      	mov	r8, r2
    5f84:	4699      	mov	r9, r3
    5f86:	46a2      	mov	sl, r4
    5f88:	46ab      	mov	fp, r5
    5f8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            ch=*(fmt++);
    5f8c:	7862      	ldrb	r2, [r4, #1]
            if (ch=='0') {
    5f8e:	2a30      	cmp	r2, #48	; 0x30
    5f90:	d02d      	beq.n	5fee <tfp_format+0x9e>
            ch=*(fmt++);
    5f92:	1ca3      	adds	r3, r4, #2
    5f94:	4698      	mov	r8, r3
            char lz=0;
    5f96:	2300      	movs	r3, #0
    5f98:	469a      	mov	sl, r3
            if (ch>='0' && ch<='9') {
    5f9a:	0013      	movs	r3, r2
    5f9c:	3b30      	subs	r3, #48	; 0x30
    5f9e:	b2d9      	uxtb	r1, r3
            int w=0;
    5fa0:	2700      	movs	r7, #0
            if (ch>='0' && ch<='9') {
    5fa2:	2909      	cmp	r1, #9
    5fa4:	d92e      	bls.n	6004 <tfp_format+0xb4>
            if (ch=='l') {
    5fa6:	2a6c      	cmp	r2, #108	; 0x6c
    5fa8:	d047      	beq.n	603a <tfp_format+0xea>
            switch (ch) {
    5faa:	2a63      	cmp	r2, #99	; 0x63
    5fac:	d100      	bne.n	5fb0 <tfp_format+0x60>
    5fae:	e082      	b.n	60b6 <tfp_format+0x166>
    5fb0:	d95f      	bls.n	6072 <tfp_format+0x122>
    5fb2:	2a73      	cmp	r2, #115	; 0x73
    5fb4:	d100      	bne.n	5fb8 <tfp_format+0x68>
    5fb6:	e099      	b.n	60ec <tfp_format+0x19c>
    5fb8:	d96c      	bls.n	6094 <tfp_format+0x144>
    5fba:	2a75      	cmp	r2, #117	; 0x75
    5fbc:	d000      	beq.n	5fc0 <tfp_format+0x70>
    5fbe:	e0a2      	b.n	6106 <tfp_format+0x1b6>
                    ui2a(va_arg(va, unsigned int),10,0,bf);
    5fc0:	464a      	mov	r2, r9
    5fc2:	464b      	mov	r3, r9
    5fc4:	6810      	ldr	r0, [r2, #0]
    5fc6:	3304      	adds	r3, #4
    5fc8:	aa05      	add	r2, sp, #20
    5fca:	9303      	str	r3, [sp, #12]
    5fcc:	210a      	movs	r1, #10
    5fce:	0013      	movs	r3, r2
    5fd0:	2200      	movs	r2, #0
    5fd2:	f7ff ff25 	bl	5e20 <ui2a>
    5fd6:	9b03      	ldr	r3, [sp, #12]
    5fd8:	4644      	mov	r4, r8
    5fda:	4699      	mov	r9, r3
                    putchw(putp,putf,w,lz,bf);
    5fdc:	ab05      	add	r3, sp, #20
    5fde:	9300      	str	r3, [sp, #0]
    5fe0:	003a      	movs	r2, r7
    5fe2:	4653      	mov	r3, sl
    5fe4:	0029      	movs	r1, r5
    5fe6:	0030      	movs	r0, r6
    5fe8:	f7ff ff72 	bl	5ed0 <putchw>
                    break;
    5fec:	e7c3      	b.n	5f76 <tfp_format+0x26>
                ch=*(fmt++);
    5fee:	1ce3      	adds	r3, r4, #3
    5ff0:	4698      	mov	r8, r3
                lz=1;
    5ff2:	2301      	movs	r3, #1
                ch=*(fmt++);
    5ff4:	78a2      	ldrb	r2, [r4, #2]
                lz=1;
    5ff6:	469a      	mov	sl, r3
            if (ch>='0' && ch<='9') {
    5ff8:	0013      	movs	r3, r2
    5ffa:	3b30      	subs	r3, #48	; 0x30
    5ffc:	b2d9      	uxtb	r1, r3
            int w=0;
    5ffe:	2700      	movs	r7, #0
            if (ch>='0' && ch<='9') {
    6000:	2909      	cmp	r1, #9
    6002:	d8d0      	bhi.n	5fa6 <tfp_format+0x56>
    6004:	4641      	mov	r1, r8
    6006:	e007      	b.n	6018 <tfp_format+0xc8>
        num=num*base+digit;
    6008:	00ba      	lsls	r2, r7, #2
    600a:	19d7      	adds	r7, r2, r7
        ch=*p++;
    600c:	780a      	ldrb	r2, [r1, #0]
        num=num*base+digit;
    600e:	007f      	lsls	r7, r7, #1
    6010:	18ff      	adds	r7, r7, r3
    6012:	0013      	movs	r3, r2
    6014:	3101      	adds	r1, #1
    6016:	3b30      	subs	r3, #48	; 0x30
    if (ch>='0' && ch<='9') 
    6018:	b2d8      	uxtb	r0, r3
    601a:	4688      	mov	r8, r1
    601c:	2809      	cmp	r0, #9
    601e:	d9f3      	bls.n	6008 <tfp_format+0xb8>
    else if (ch>='a' && ch<='f')
    6020:	0013      	movs	r3, r2
    6022:	3b61      	subs	r3, #97	; 0x61
    6024:	2b05      	cmp	r3, #5
    6026:	d903      	bls.n	6030 <tfp_format+0xe0>
    else if (ch>='A' && ch<='F')
    6028:	0013      	movs	r3, r2
    602a:	3b41      	subs	r3, #65	; 0x41
    602c:	2b05      	cmp	r3, #5
    602e:	d8ba      	bhi.n	5fa6 <tfp_format+0x56>
        return ch-'A'+10;
    6030:	330a      	adds	r3, #10
        if (digit>base) break;
    6032:	2b0a      	cmp	r3, #10
    6034:	dde8      	ble.n	6008 <tfp_format+0xb8>
            if (ch=='l') {
    6036:	2a6c      	cmp	r2, #108	; 0x6c
    6038:	d1b7      	bne.n	5faa <tfp_format+0x5a>
                ch=*(fmt++);
    603a:	4643      	mov	r3, r8
    603c:	1c5c      	adds	r4, r3, #1
    603e:	781b      	ldrb	r3, [r3, #0]
            switch (ch) {
    6040:	2b63      	cmp	r3, #99	; 0x63
    6042:	d037      	beq.n	60b4 <tfp_format+0x164>
    6044:	d91e      	bls.n	6084 <tfp_format+0x134>
    6046:	2b73      	cmp	r3, #115	; 0x73
    6048:	d04f      	beq.n	60ea <tfp_format+0x19a>
    604a:	d975      	bls.n	6138 <tfp_format+0x1e8>
    604c:	2b75      	cmp	r3, #117	; 0x75
    604e:	d040      	beq.n	60d2 <tfp_format+0x182>
    6050:	2b78      	cmp	r3, #120	; 0x78
    6052:	d000      	beq.n	6056 <tfp_format+0x106>
    6054:	e78f      	b.n	5f76 <tfp_format+0x26>
                        uli2a(va_arg(va, unsigned long int),16,(ch=='X'),bf);
    6056:	2204      	movs	r2, #4
    6058:	3b58      	subs	r3, #88	; 0x58
    605a:	444a      	add	r2, r9
    605c:	4690      	mov	r8, r2
    605e:	425a      	negs	r2, r3
    6060:	415a      	adcs	r2, r3
    6062:	464b      	mov	r3, r9
    6064:	2110      	movs	r1, #16
    6066:	6818      	ldr	r0, [r3, #0]
    6068:	ab05      	add	r3, sp, #20
    606a:	f7ff fe81 	bl	5d70 <uli2a>
    606e:	46c1      	mov	r9, r8
    6070:	e7b4      	b.n	5fdc <tfp_format+0x8c>
            switch (ch) {
    6072:	2a25      	cmp	r2, #37	; 0x25
    6074:	d028      	beq.n	60c8 <tfp_format+0x178>
    6076:	2a58      	cmp	r2, #88	; 0x58
    6078:	d047      	beq.n	610a <tfp_format+0x1ba>
    607a:	2a00      	cmp	r2, #0
    607c:	d100      	bne.n	6080 <tfp_format+0x130>
    607e:	e77e      	b.n	5f7e <tfp_format+0x2e>
    6080:	4644      	mov	r4, r8
    6082:	e778      	b.n	5f76 <tfp_format+0x26>
    6084:	2b25      	cmp	r3, #37	; 0x25
    6086:	d01e      	beq.n	60c6 <tfp_format+0x176>
    6088:	2b58      	cmp	r3, #88	; 0x58
    608a:	d0e4      	beq.n	6056 <tfp_format+0x106>
    608c:	2b00      	cmp	r3, #0
    608e:	d000      	beq.n	6092 <tfp_format+0x142>
    6090:	e771      	b.n	5f76 <tfp_format+0x26>
    6092:	e774      	b.n	5f7e <tfp_format+0x2e>
    6094:	2a64      	cmp	r2, #100	; 0x64
    6096:	d1f3      	bne.n	6080 <tfp_format+0x130>
                    i2a(va_arg(va, int),bf);
    6098:	464b      	mov	r3, r9
    609a:	6818      	ldr	r0, [r3, #0]
    if (num<0) {
    609c:	2800      	cmp	r0, #0
    609e:	db42      	blt.n	6126 <tfp_format+0x1d6>
    60a0:	ab05      	add	r3, sp, #20
                    i2a(va_arg(va, int),bf);
    60a2:	2204      	movs	r2, #4
    60a4:	4694      	mov	ip, r2
    ui2a(num,10,0,bf);
    60a6:	210a      	movs	r1, #10
    60a8:	2200      	movs	r2, #0
                    i2a(va_arg(va, int),bf);
    60aa:	44e1      	add	r9, ip
    ui2a(num,10,0,bf);
    60ac:	4644      	mov	r4, r8
    60ae:	f7ff feb7 	bl	5e20 <ui2a>
    60b2:	e793      	b.n	5fdc <tfp_format+0x8c>
                ch=*(fmt++);
    60b4:	46a0      	mov	r8, r4
                    putf(putp,(char)(va_arg(va, int)));
    60b6:	464b      	mov	r3, r9
    60b8:	0030      	movs	r0, r6
    60ba:	1d1c      	adds	r4, r3, #4
    60bc:	7819      	ldrb	r1, [r3, #0]
    60be:	46a1      	mov	r9, r4
    60c0:	47a8      	blx	r5
                    break;
    60c2:	4644      	mov	r4, r8
    60c4:	e757      	b.n	5f76 <tfp_format+0x26>
                ch=*(fmt++);
    60c6:	46a0      	mov	r8, r4
                    putf(putp,ch);
    60c8:	2125      	movs	r1, #37	; 0x25
    60ca:	0030      	movs	r0, r6
    60cc:	47a8      	blx	r5
    60ce:	4644      	mov	r4, r8
    60d0:	e751      	b.n	5f76 <tfp_format+0x26>
                        uli2a(va_arg(va, unsigned long int),10,0,bf);
    60d2:	2304      	movs	r3, #4
    60d4:	444b      	add	r3, r9
    60d6:	4698      	mov	r8, r3
    60d8:	464b      	mov	r3, r9
    60da:	2200      	movs	r2, #0
    60dc:	6818      	ldr	r0, [r3, #0]
    60de:	210a      	movs	r1, #10
    60e0:	ab05      	add	r3, sp, #20
    60e2:	f7ff fe45 	bl	5d70 <uli2a>
    60e6:	46c1      	mov	r9, r8
    60e8:	e778      	b.n	5fdc <tfp_format+0x8c>
                ch=*(fmt++);
    60ea:	46a0      	mov	r8, r4
                    putchw(putp,putf,w,0,va_arg(va, char*));
    60ec:	464b      	mov	r3, r9
    60ee:	1d1c      	adds	r4, r3, #4
    60f0:	681b      	ldr	r3, [r3, #0]
    60f2:	003a      	movs	r2, r7
    60f4:	9300      	str	r3, [sp, #0]
    60f6:	0029      	movs	r1, r5
    60f8:	2300      	movs	r3, #0
    60fa:	0030      	movs	r0, r6
    60fc:	46a1      	mov	r9, r4
    60fe:	f7ff fee7 	bl	5ed0 <putchw>
                    break;
    6102:	4644      	mov	r4, r8
    6104:	e737      	b.n	5f76 <tfp_format+0x26>
            switch (ch) {
    6106:	2a78      	cmp	r2, #120	; 0x78
    6108:	d1ba      	bne.n	6080 <tfp_format+0x130>
                    ui2a(va_arg(va, unsigned int),16,(ch=='X'),bf);
    610a:	464b      	mov	r3, r9
    610c:	3a58      	subs	r2, #88	; 0x58
    610e:	1d1c      	adds	r4, r3, #4
    6110:	4253      	negs	r3, r2
    6112:	415a      	adcs	r2, r3
    6114:	464b      	mov	r3, r9
    6116:	2110      	movs	r1, #16
    6118:	6818      	ldr	r0, [r3, #0]
    611a:	ab05      	add	r3, sp, #20
    611c:	46a1      	mov	r9, r4
    611e:	f7ff fe7f 	bl	5e20 <ui2a>
    6122:	4644      	mov	r4, r8
    6124:	e75a      	b.n	5fdc <tfp_format+0x8c>
        *bf++ = '-';
    6126:	465a      	mov	r2, fp
    6128:	ab02      	add	r3, sp, #8
    612a:	731a      	strb	r2, [r3, #12]
    612c:	aa02      	add	r2, sp, #8
    612e:	230d      	movs	r3, #13
    6130:	4694      	mov	ip, r2
        num=-num;
    6132:	4240      	negs	r0, r0
        *bf++ = '-';
    6134:	4463      	add	r3, ip
    6136:	e7b4      	b.n	60a2 <tfp_format+0x152>
            switch (ch) {
    6138:	2b64      	cmp	r3, #100	; 0x64
    613a:	d000      	beq.n	613e <tfp_format+0x1ee>
    613c:	e71b      	b.n	5f76 <tfp_format+0x26>
                        li2a(va_arg(va, unsigned long int),bf);
    613e:	2304      	movs	r3, #4
    6140:	444b      	add	r3, r9
    6142:	4698      	mov	r8, r3
    6144:	464b      	mov	r3, r9
    6146:	6818      	ldr	r0, [r3, #0]
    if (num<0) {
    6148:	2800      	cmp	r0, #0
    614a:	db06      	blt.n	615a <tfp_format+0x20a>
    614c:	ab05      	add	r3, sp, #20
    uli2a(num,10,0,bf);
    614e:	2200      	movs	r2, #0
    6150:	210a      	movs	r1, #10
    6152:	f7ff fe0d 	bl	5d70 <uli2a>
                        li2a(va_arg(va, unsigned long int),bf);
    6156:	46c1      	mov	r9, r8
    6158:	e740      	b.n	5fdc <tfp_format+0x8c>
        *bf++ = '-';
    615a:	465a      	mov	r2, fp
    615c:	ab02      	add	r3, sp, #8
    615e:	731a      	strb	r2, [r3, #12]
    6160:	aa02      	add	r2, sp, #8
    6162:	230d      	movs	r3, #13
    6164:	4694      	mov	ip, r2
        num=-num;
    6166:	4240      	negs	r0, r0
        *bf++ = '-';
    6168:	4463      	add	r3, ip
    616a:	e7f0      	b.n	614e <tfp_format+0x1fe>
    616c:	0000      	movs	r0, r0
	...

00006170 <init_printf>:


void init_printf(void* putp,void (*putf) (void*,char))
    {
    stdout_putf=putf;
    6170:	4b02      	ldr	r3, [pc, #8]	; (617c <init_printf+0xc>)
    6172:	6019      	str	r1, [r3, #0]
    stdout_putp=putp;
    6174:	4b02      	ldr	r3, [pc, #8]	; (6180 <init_printf+0x10>)
    6176:	6018      	str	r0, [r3, #0]
    }
    6178:	4770      	bx	lr
    617a:	46c0      	nop			; (mov r8, r8)
    617c:	20000cbc 	.word	0x20000cbc
    6180:	20000cc0 	.word	0x20000cc0
	...

00006190 <tfp_printf>:

void tfp_printf(char *fmt, ...)
    {
    6190:	b40f      	push	{r0, r1, r2, r3}
    6192:	b500      	push	{lr}
    6194:	b083      	sub	sp, #12
    6196:	ab04      	add	r3, sp, #16
    va_list va;
    va_start(va,fmt);
    tfp_format(stdout_putp,stdout_putf,fmt,va);
    6198:	4905      	ldr	r1, [pc, #20]	; (61b0 <tfp_printf+0x20>)
    619a:	4806      	ldr	r0, [pc, #24]	; (61b4 <tfp_printf+0x24>)
    {
    619c:	cb04      	ldmia	r3!, {r2}
    tfp_format(stdout_putp,stdout_putf,fmt,va);
    619e:	6809      	ldr	r1, [r1, #0]
    61a0:	6800      	ldr	r0, [r0, #0]
    va_start(va,fmt);
    61a2:	9301      	str	r3, [sp, #4]
    tfp_format(stdout_putp,stdout_putf,fmt,va);
    61a4:	f7ff fed4 	bl	5f50 <tfp_format>
    va_end(va);
    }
    61a8:	b003      	add	sp, #12
    61aa:	bc08      	pop	{r3}
    61ac:	b004      	add	sp, #16
    61ae:	4718      	bx	r3
    61b0:	20000cbc 	.word	0x20000cbc
    61b4:	20000cc0 	.word	0x20000cc0
	...

000061c0 <timer_init>:
#include "ch.h"

#include "timer.h"

void timer_init(void) {}
    61c0:	4770      	bx	lr
    61c2:	46c0      	nop			; (mov r8, r8)
	...

000061d0 <timer_read>:

void timer_clear(void) {}

uint16_t timer_read(void)
{
    61d0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    61d2:	b672      	cpsid	i
  _dbg_check_lock();
    61d4:	f7fa ff04 	bl	fe0 <_dbg_check_lock>
  return ch.vtlist.systime;
    61d8:	4d0e      	ldr	r5, [pc, #56]	; (6214 <timer_read+0x44>)
    61da:	6aac      	ldr	r4, [r5, #40]	; 0x28
  _dbg_check_unlock();
    61dc:	f7fa ff18 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    61e0:	682b      	ldr	r3, [r5, #0]
    61e2:	42ab      	cmp	r3, r5
    61e4:	d004      	beq.n	61f0 <timer_read+0x20>
    61e6:	69aa      	ldr	r2, [r5, #24]
    61e8:	689b      	ldr	r3, [r3, #8]
    61ea:	6892      	ldr	r2, [r2, #8]
    61ec:	429a      	cmp	r2, r3
    61ee:	d30d      	bcc.n	620c <timer_read+0x3c>
  __ASM volatile ("cpsie i" : : : "memory");
    61f0:	b662      	cpsie	i
    return (uint16_t)ST2MS(chVTGetSystemTime());
    61f2:	21fa      	movs	r1, #250	; 0xfa
    61f4:	3401      	adds	r4, #1
    61f6:	0160      	lsls	r0, r4, #5
    61f8:	1b00      	subs	r0, r0, r4
    61fa:	0080      	lsls	r0, r0, #2
    61fc:	1900      	adds	r0, r0, r4
    61fe:	00c0      	lsls	r0, r0, #3
    6200:	0089      	lsls	r1, r1, #2
    6202:	3801      	subs	r0, #1
    6204:	f7fa f992 	bl	52c <__udivsi3>
    6208:	b280      	uxth	r0, r0
}
    620a:	bd70      	pop	{r4, r5, r6, pc}
    620c:	4802      	ldr	r0, [pc, #8]	; (6218 <timer_read+0x48>)
    620e:	f7fa fe97 	bl	f40 <chSysHalt>
    6212:	e7ed      	b.n	61f0 <timer_read+0x20>
    6214:	200000d8 	.word	0x200000d8
    6218:	0000892c 	.word	0x0000892c
    621c:	00000000 	.word	0x00000000

00006220 <timer_read32>:

uint32_t timer_read32(void)
{
    6220:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    6222:	b672      	cpsid	i
  _dbg_check_lock();
    6224:	f7fa fedc 	bl	fe0 <_dbg_check_lock>
    6228:	4d0e      	ldr	r5, [pc, #56]	; (6264 <timer_read32+0x44>)
    622a:	6aac      	ldr	r4, [r5, #40]	; 0x28
  _dbg_check_unlock();
    622c:	f7fa fef0 	bl	1010 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
    6230:	682b      	ldr	r3, [r5, #0]
    6232:	42ab      	cmp	r3, r5
    6234:	d004      	beq.n	6240 <timer_read32+0x20>
    6236:	69aa      	ldr	r2, [r5, #24]
    6238:	689b      	ldr	r3, [r3, #8]
    623a:	6892      	ldr	r2, [r2, #8]
    623c:	429a      	cmp	r2, r3
    623e:	d30c      	bcc.n	625a <timer_read32+0x3a>
  __ASM volatile ("cpsie i" : : : "memory");
    6240:	b662      	cpsie	i
    return ST2MS(chVTGetSystemTime());
    6242:	21fa      	movs	r1, #250	; 0xfa
    6244:	3401      	adds	r4, #1
    6246:	0160      	lsls	r0, r4, #5
    6248:	1b00      	subs	r0, r0, r4
    624a:	0080      	lsls	r0, r0, #2
    624c:	1900      	adds	r0, r0, r4
    624e:	00c0      	lsls	r0, r0, #3
    6250:	0089      	lsls	r1, r1, #2
    6252:	3801      	subs	r0, #1
    6254:	f7fa f96a 	bl	52c <__udivsi3>
}
    6258:	bd70      	pop	{r4, r5, r6, pc}
    625a:	4803      	ldr	r0, [pc, #12]	; (6268 <timer_read32+0x48>)
    625c:	f7fa fe70 	bl	f40 <chSysHalt>
    6260:	e7ee      	b.n	6240 <timer_read32+0x20>
    6262:	46c0      	nop			; (mov r8, r8)
    6264:	200000d8 	.word	0x200000d8
    6268:	0000892c 	.word	0x0000892c
    626c:	00000000 	.word	0x00000000

00006270 <timer_elapsed>:

uint16_t timer_elapsed(uint16_t last)
{
    6270:	0001      	movs	r1, r0
    6272:	4b0e      	ldr	r3, [pc, #56]	; (62ac <timer_elapsed+0x3c>)
    return (uint16_t)(ST2MS(chVTTimeElapsedSinceX(MS2ST(last))));
    6274:	0140      	lsls	r0, r0, #5
{
    6276:	b510      	push	{r4, lr}
    return (uint16_t)(ST2MS(chVTTimeElapsedSinceX(MS2ST(last))));
    6278:	1a40      	subs	r0, r0, r1
    627a:	6a9c      	ldr	r4, [r3, #40]	; 0x28
    627c:	4b0c      	ldr	r3, [pc, #48]	; (62b0 <timer_elapsed+0x40>)
    627e:	0080      	lsls	r0, r0, #2
    6280:	469c      	mov	ip, r3
    6282:	1840      	adds	r0, r0, r1
    6284:	21fa      	movs	r1, #250	; 0xfa
    6286:	00c0      	lsls	r0, r0, #3
    6288:	4460      	add	r0, ip
    628a:	0089      	lsls	r1, r1, #2
    628c:	f7fa f94e 	bl	52c <__udivsi3>
    6290:	21fa      	movs	r1, #250	; 0xfa
    6292:	3401      	adds	r4, #1
    6294:	1a24      	subs	r4, r4, r0
    6296:	0160      	lsls	r0, r4, #5
    6298:	1b00      	subs	r0, r0, r4
    629a:	0080      	lsls	r0, r0, #2
    629c:	1900      	adds	r0, r0, r4
    629e:	00c0      	lsls	r0, r0, #3
    62a0:	0089      	lsls	r1, r1, #2
    62a2:	3801      	subs	r0, #1
    62a4:	f7fa f942 	bl	52c <__udivsi3>
    62a8:	b280      	uxth	r0, r0
}
    62aa:	bd10      	pop	{r4, pc}
    62ac:	200000d8 	.word	0x200000d8
    62b0:	000003e7 	.word	0x000003e7
	...

000062c0 <bootloader_jump>:
  SCB->AIRCR = SCB_AIRCR_VECTKEY_WRITEMAGIC | SCB_AIRCR_SYSRESETREQ_Msk;
}

#else /* defined(KIIBOHD_BOOTLOADER) */
/* Default for Kinetis - expecting an ARM Teensy */
void bootloader_jump(void) {
    62c0:	b510      	push	{r4, lr}
	chThdSleepMilliseconds(100);
    62c2:	2064      	movs	r0, #100	; 0x64
    62c4:	f7fb fa94 	bl	17f0 <chThdSleep>
	__BKPT(0);
    62c8:	be00      	bkpt	0x0000
}
    62ca:	bd10      	pop	{r4, pc}
    62cc:	0000      	movs	r0, r0
	...

000062d0 <scan_key>:
        default_layer_set((uint32_t)default_layer);
    }
}

static bool scan_key(uint16_t code)
{
    62d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    for (uint8_t r = 0; r < MATRIX_ROWS; r++) {
    62d2:	2300      	movs	r3, #0
{
    62d4:	464f      	mov	r7, r9
    62d6:	4646      	mov	r6, r8
    62d8:	46d6      	mov	lr, sl
    62da:	4681      	mov	r9, r0
    62dc:	b5c0      	push	{r6, r7, lr}
    for (uint8_t r = 0; r < MATRIX_ROWS; r++) {
    62de:	4698      	mov	r8, r3
        matrix_row_t matrix_row = matrix_get_row(r);
        for (uint8_t c = 0; c < MATRIX_COLS; c++) {
            if (matrix_row & ((matrix_row_t)1<<c)) {
    62e0:	2701      	movs	r7, #1
{
    62e2:	b082      	sub	sp, #8
                // read key from Layer 0
                action_t action = action_for_key(0, (keypos_t){ .row = r, .col = c });
    62e4:	ae01      	add	r6, sp, #4
        matrix_row_t matrix_row = matrix_get_row(r);
    62e6:	4640      	mov	r0, r8
    62e8:	f7fd ffda 	bl	42a0 <matrix_get_row>
                if (action.code == code ||
    62ec:	231f      	movs	r3, #31
        matrix_row_t matrix_row = matrix_get_row(r);
    62ee:	0005      	movs	r5, r0
    62f0:	2400      	movs	r4, #0
                if (action.code == code ||
    62f2:	469a      	mov	sl, r3
    62f4:	e002      	b.n	62fc <scan_key+0x2c>
    62f6:	3401      	adds	r4, #1
        for (uint8_t c = 0; c < MATRIX_COLS; c++) {
    62f8:	2c0b      	cmp	r4, #11
    62fa:	d022      	beq.n	6342 <scan_key+0x72>
            if (matrix_row & ((matrix_row_t)1<<c)) {
    62fc:	002b      	movs	r3, r5
    62fe:	4123      	asrs	r3, r4
    6300:	b2e2      	uxtb	r2, r4
    6302:	421f      	tst	r7, r3
    6304:	d0f7      	beq.n	62f6 <scan_key+0x26>
                action_t action = action_for_key(0, (keypos_t){ .row = r, .col = c });
    6306:	4643      	mov	r3, r8
    6308:	7032      	strb	r2, [r6, #0]
    630a:	7073      	strb	r3, [r6, #1]
    630c:	6831      	ldr	r1, [r6, #0]
    630e:	2000      	movs	r0, #0
    6310:	f7ff fc26 	bl	5b60 <action_for_key>
                if (action.code == code ||
    6314:	b283      	uxth	r3, r0
    6316:	454b      	cmp	r3, r9
    6318:	d00c      	beq.n	6334 <scan_key+0x64>
                    ((action.kind.id == ACT_LMODS ||
    631a:	0403      	lsls	r3, r0, #16
    631c:	0e1b      	lsrs	r3, r3, #24
                if (action.code == code ||
    631e:	0019      	movs	r1, r3
    6320:	4652      	mov	r2, sl
    6322:	4391      	bics	r1, r2
    6324:	223f      	movs	r2, #63	; 0x3f
    6326:	4393      	bics	r3, r2
    6328:	d001      	beq.n	632e <scan_key+0x5e>
                      action.kind.id == ACT_RMODS ||
                      action.kind.id == ACT_LMODS_TAP ||
                      action.kind.id == ACT_RMODS_TAP ||
    632a:	29a0      	cmp	r1, #160	; 0xa0
    632c:	d1e3      	bne.n	62f6 <scan_key+0x26>
                      action.kind.id == ACT_LAYER_TAP ||
                      action.kind.id == ACT_LAYER_TAP_EXT) &&
    632e:	b2c0      	uxtb	r0, r0
    6330:	4548      	cmp	r0, r9
    6332:	d1e0      	bne.n	62f6 <scan_key+0x26>
                     action.key.code == code)) {
                    return true;
    6334:	2001      	movs	r0, #1
                }
            }
        }
    }
    return false;
}
    6336:	b002      	add	sp, #8
    6338:	bc1c      	pop	{r2, r3, r4}
    633a:	4690      	mov	r8, r2
    633c:	4699      	mov	r9, r3
    633e:	46a2      	mov	sl, r4
    6340:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (uint8_t r = 0; r < MATRIX_ROWS; r++) {
    6342:	4643      	mov	r3, r8
    6344:	3301      	adds	r3, #1
    6346:	b2db      	uxtb	r3, r3
    6348:	4698      	mov	r8, r3
    634a:	2b04      	cmp	r3, #4
    634c:	d1cb      	bne.n	62e6 <scan_key+0x16>
    return false;
    634e:	2000      	movs	r0, #0
    6350:	e7f1      	b.n	6336 <scan_key+0x66>
    6352:	46c0      	nop			; (mov r8, r8)
	...

00006360 <bootmagic_scan_key>:

bool bootmagic_scan_key(uint16_t code)
{
    6360:	b510      	push	{r4, lr}
    6362:	0004      	movs	r4, r0
    if (!scan_key(BOOTMAGIC_KEY_SALT)) return false;
    6364:	202c      	movs	r0, #44	; 0x2c
    6366:	f7ff ffb3 	bl	62d0 <scan_key>
    636a:	2800      	cmp	r0, #0
    636c:	d002      	beq.n	6374 <bootmagic_scan_key+0x14>

    return scan_key(code);
    636e:	0020      	movs	r0, r4
    6370:	f7ff ffae 	bl	62d0 <scan_key>
}
    6374:	bd10      	pop	{r4, pc}
    6376:	46c0      	nop			; (mov r8, r8)
	...

00006380 <bootmagic>:
{
    6380:	b510      	push	{r4, lr}
    if (!eeconfig_is_enabled()) {
    6382:	f000 facd 	bl	6920 <eeconfig_is_enabled>
    6386:	2800      	cmp	r0, #0
    6388:	d100      	bne.n	638c <bootmagic+0xc>
    638a:	e0f5      	b.n	6578 <bootmagic+0x1f8>
    print("bootmagic scan: ... ");
    638c:	48a2      	ldr	r0, [pc, #648]	; (6618 <bootmagic+0x298>)
    638e:	f7ff feff 	bl	6190 <tfp_printf>
    6392:	2464      	movs	r4, #100	; 0x64
    6394:	3c01      	subs	r4, #1
    while (scan--) { matrix_scan(); wait_ms(10); }
    6396:	f7fd fe7b 	bl	4090 <matrix_scan>
    639a:	b2e4      	uxtb	r4, r4
    639c:	200a      	movs	r0, #10
    639e:	f7fb fa27 	bl	17f0 <chThdSleep>
    63a2:	2c00      	cmp	r4, #0
    63a4:	d1f6      	bne.n	6394 <bootmagic+0x14>
    print("done.\n");
    63a6:	489d      	ldr	r0, [pc, #628]	; (661c <bootmagic+0x29c>)
    63a8:	f7ff fef2 	bl	6190 <tfp_printf>
    if (bootmagic_scan_key(BOOTMAGIC_KEY_SKIP)) {
    63ac:	2029      	movs	r0, #41	; 0x29
    63ae:	f7ff ffd7 	bl	6360 <bootmagic_scan_key>
    63b2:	2800      	cmp	r0, #0
    63b4:	d000      	beq.n	63b8 <bootmagic+0x38>
}
    63b6:	bd10      	pop	{r4, pc}
    if (bootmagic_scan_key(BOOTMAGIC_KEY_EEPROM_CLEAR)) {
    63b8:	302a      	adds	r0, #42	; 0x2a
    63ba:	f7ff ffd1 	bl	6360 <bootmagic_scan_key>
    63be:	2800      	cmp	r0, #0
    63c0:	d000      	beq.n	63c4 <bootmagic+0x44>
    63c2:	e0fb      	b.n	65bc <bootmagic+0x23c>
    if (bootmagic_scan_key(BOOTMAGIC_KEY_BOOTLOADER)) {
    63c4:	2005      	movs	r0, #5
    63c6:	f7ff ffcb 	bl	6360 <bootmagic_scan_key>
    63ca:	2800      	cmp	r0, #0
    63cc:	d000      	beq.n	63d0 <bootmagic+0x50>
    63ce:	e0f2      	b.n	65b6 <bootmagic+0x236>
    hook_bootmagic();
    63d0:	f7ff fc86 	bl	5ce0 <hook_bootmagic>
    debug_config.raw = eeconfig_read_debug();
    63d4:	f000 fab4 	bl	6940 <eeconfig_read_debug>
    63d8:	4c91      	ldr	r4, [pc, #580]	; (6620 <bootmagic+0x2a0>)
    63da:	7020      	strb	r0, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEBUG_ENABLE)) {
    63dc:	2007      	movs	r0, #7
    63de:	f7ff ffbf 	bl	6360 <bootmagic_scan_key>
    63e2:	2800      	cmp	r0, #0
    63e4:	d000      	beq.n	63e8 <bootmagic+0x68>
    63e6:	e0d6      	b.n	6596 <bootmagic+0x216>
    eeconfig_write_debug(debug_config.raw);
    63e8:	7820      	ldrb	r0, [r4, #0]
    63ea:	f000 fab1 	bl	6950 <eeconfig_write_debug>
    keymap_config.raw = eeconfig_read_keymap();
    63ee:	f000 fac7 	bl	6980 <eeconfig_read_keymap>
    63f2:	4c8c      	ldr	r4, [pc, #560]	; (6624 <bootmagic+0x2a4>)
    63f4:	7020      	strb	r0, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_SWAP_CONTROL_CAPSLOCK)) {
    63f6:	20e0      	movs	r0, #224	; 0xe0
    63f8:	f7ff ffb2 	bl	6360 <bootmagic_scan_key>
    63fc:	2800      	cmp	r0, #0
    63fe:	d008      	beq.n	6412 <bootmagic+0x92>
        keymap_config.swap_control_capslock = !keymap_config.swap_control_capslock;
    6400:	2101      	movs	r1, #1
    6402:	7823      	ldrb	r3, [r4, #0]
    6404:	07da      	lsls	r2, r3, #31
    6406:	0fd2      	lsrs	r2, r2, #31
    6408:	404a      	eors	r2, r1
    640a:	2101      	movs	r1, #1
    640c:	438b      	bics	r3, r1
    640e:	4313      	orrs	r3, r2
    6410:	7023      	strb	r3, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_CAPSLOCK_TO_CONTROL)) {
    6412:	2039      	movs	r0, #57	; 0x39
    6414:	f7ff ffa4 	bl	6360 <bootmagic_scan_key>
    6418:	2800      	cmp	r0, #0
    641a:	d009      	beq.n	6430 <bootmagic+0xb0>
        keymap_config.capslock_to_control = !keymap_config.capslock_to_control;
    641c:	2101      	movs	r1, #1
    641e:	7822      	ldrb	r2, [r4, #0]
    6420:	0793      	lsls	r3, r2, #30
    6422:	0fdb      	lsrs	r3, r3, #31
    6424:	404b      	eors	r3, r1
    6426:	2102      	movs	r1, #2
    6428:	005b      	lsls	r3, r3, #1
    642a:	438a      	bics	r2, r1
    642c:	4313      	orrs	r3, r2
    642e:	7023      	strb	r3, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_SWAP_LALT_LGUI)) {
    6430:	20e2      	movs	r0, #226	; 0xe2
    6432:	f7ff ff95 	bl	6360 <bootmagic_scan_key>
    6436:	2800      	cmp	r0, #0
    6438:	d009      	beq.n	644e <bootmagic+0xce>
        keymap_config.swap_lalt_lgui = !keymap_config.swap_lalt_lgui;
    643a:	2101      	movs	r1, #1
    643c:	7822      	ldrb	r2, [r4, #0]
    643e:	0753      	lsls	r3, r2, #29
    6440:	0fdb      	lsrs	r3, r3, #31
    6442:	404b      	eors	r3, r1
    6444:	2104      	movs	r1, #4
    6446:	009b      	lsls	r3, r3, #2
    6448:	438a      	bics	r2, r1
    644a:	4313      	orrs	r3, r2
    644c:	7023      	strb	r3, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_SWAP_RALT_RGUI)) {
    644e:	20e6      	movs	r0, #230	; 0xe6
    6450:	f7ff ff86 	bl	6360 <bootmagic_scan_key>
    6454:	2800      	cmp	r0, #0
    6456:	d009      	beq.n	646c <bootmagic+0xec>
        keymap_config.swap_ralt_rgui = !keymap_config.swap_ralt_rgui;
    6458:	2101      	movs	r1, #1
    645a:	7822      	ldrb	r2, [r4, #0]
    645c:	0713      	lsls	r3, r2, #28
    645e:	0fdb      	lsrs	r3, r3, #31
    6460:	404b      	eors	r3, r1
    6462:	2108      	movs	r1, #8
    6464:	00db      	lsls	r3, r3, #3
    6466:	438a      	bics	r2, r1
    6468:	4313      	orrs	r3, r2
    646a:	7023      	strb	r3, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_NO_GUI)) {
    646c:	20e3      	movs	r0, #227	; 0xe3
    646e:	f7ff ff77 	bl	6360 <bootmagic_scan_key>
    6472:	2800      	cmp	r0, #0
    6474:	d009      	beq.n	648a <bootmagic+0x10a>
        keymap_config.no_gui = !keymap_config.no_gui;
    6476:	2101      	movs	r1, #1
    6478:	7822      	ldrb	r2, [r4, #0]
    647a:	06d3      	lsls	r3, r2, #27
    647c:	0fdb      	lsrs	r3, r3, #31
    647e:	404b      	eors	r3, r1
    6480:	2110      	movs	r1, #16
    6482:	011b      	lsls	r3, r3, #4
    6484:	438a      	bics	r2, r1
    6486:	4313      	orrs	r3, r2
    6488:	7023      	strb	r3, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_SWAP_GRAVE_ESC)) {
    648a:	2035      	movs	r0, #53	; 0x35
    648c:	f7ff ff68 	bl	6360 <bootmagic_scan_key>
    6490:	2800      	cmp	r0, #0
    6492:	d009      	beq.n	64a8 <bootmagic+0x128>
        keymap_config.swap_grave_esc = !keymap_config.swap_grave_esc;
    6494:	2101      	movs	r1, #1
    6496:	7822      	ldrb	r2, [r4, #0]
    6498:	0693      	lsls	r3, r2, #26
    649a:	0fdb      	lsrs	r3, r3, #31
    649c:	404b      	eors	r3, r1
    649e:	2120      	movs	r1, #32
    64a0:	015b      	lsls	r3, r3, #5
    64a2:	438a      	bics	r2, r1
    64a4:	4313      	orrs	r3, r2
    64a6:	7023      	strb	r3, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_SWAP_BACKSLASH_BACKSPACE)) {
    64a8:	2031      	movs	r0, #49	; 0x31
    64aa:	f7ff ff59 	bl	6360 <bootmagic_scan_key>
    64ae:	2800      	cmp	r0, #0
    64b0:	d009      	beq.n	64c6 <bootmagic+0x146>
        keymap_config.swap_backslash_backspace = !keymap_config.swap_backslash_backspace;
    64b2:	2101      	movs	r1, #1
    64b4:	7822      	ldrb	r2, [r4, #0]
    64b6:	0653      	lsls	r3, r2, #25
    64b8:	0fdb      	lsrs	r3, r3, #31
    64ba:	404b      	eors	r3, r1
    64bc:	2140      	movs	r1, #64	; 0x40
    64be:	019b      	lsls	r3, r3, #6
    64c0:	438a      	bics	r2, r1
    64c2:	4313      	orrs	r3, r2
    64c4:	7023      	strb	r3, [r4, #0]
    if (bootmagic_scan_key(BOOTMAGIC_HOST_NKRO)) {
    64c6:	2011      	movs	r0, #17
    64c8:	f7ff ff4a 	bl	6360 <bootmagic_scan_key>
    64cc:	2800      	cmp	r0, #0
    64ce:	d008      	beq.n	64e2 <bootmagic+0x162>
        keymap_config.nkro = !keymap_config.nkro;
    64d0:	2301      	movs	r3, #1
    64d2:	7821      	ldrb	r1, [r4, #0]
    64d4:	09ca      	lsrs	r2, r1, #7
    64d6:	405a      	eors	r2, r3
    64d8:	237f      	movs	r3, #127	; 0x7f
    64da:	01d2      	lsls	r2, r2, #7
    64dc:	400b      	ands	r3, r1
    64de:	4313      	orrs	r3, r2
    64e0:	7023      	strb	r3, [r4, #0]
    eeconfig_write_keymap(keymap_config.raw);
    64e2:	7820      	ldrb	r0, [r4, #0]
    64e4:	f000 fa54 	bl	6990 <eeconfig_write_keymap>
    keyboard_nkro = keymap_config.nkro;
    64e8:	7823      	ldrb	r3, [r4, #0]
    64ea:	4a4f      	ldr	r2, [pc, #316]	; (6628 <bootmagic+0x2a8>)
    64ec:	09db      	lsrs	r3, r3, #7
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_0)) { default_layer |= (1<<0); }
    64ee:	2027      	movs	r0, #39	; 0x27
    keyboard_nkro = keymap_config.nkro;
    64f0:	7013      	strb	r3, [r2, #0]
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_0)) { default_layer |= (1<<0); }
    64f2:	f7ff ff35 	bl	6360 <bootmagic_scan_key>
    64f6:	0004      	movs	r4, r0
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_1)) { default_layer |= (1<<1); }
    64f8:	201e      	movs	r0, #30
    64fa:	f7ff ff31 	bl	6360 <bootmagic_scan_key>
    64fe:	2800      	cmp	r0, #0
    6500:	d002      	beq.n	6508 <bootmagic+0x188>
    6502:	2302      	movs	r3, #2
    6504:	431c      	orrs	r4, r3
    6506:	b2e4      	uxtb	r4, r4
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_2)) { default_layer |= (1<<2); }
    6508:	201f      	movs	r0, #31
    650a:	f7ff ff29 	bl	6360 <bootmagic_scan_key>
    650e:	2800      	cmp	r0, #0
    6510:	d002      	beq.n	6518 <bootmagic+0x198>
    6512:	2304      	movs	r3, #4
    6514:	431c      	orrs	r4, r3
    6516:	b2e4      	uxtb	r4, r4
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_3)) { default_layer |= (1<<3); }
    6518:	2020      	movs	r0, #32
    651a:	f7ff ff21 	bl	6360 <bootmagic_scan_key>
    651e:	2800      	cmp	r0, #0
    6520:	d002      	beq.n	6528 <bootmagic+0x1a8>
    6522:	2308      	movs	r3, #8
    6524:	431c      	orrs	r4, r3
    6526:	b2e4      	uxtb	r4, r4
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_4)) { default_layer |= (1<<4); }
    6528:	2021      	movs	r0, #33	; 0x21
    652a:	f7ff ff19 	bl	6360 <bootmagic_scan_key>
    652e:	2800      	cmp	r0, #0
    6530:	d002      	beq.n	6538 <bootmagic+0x1b8>
    6532:	2310      	movs	r3, #16
    6534:	431c      	orrs	r4, r3
    6536:	b2e4      	uxtb	r4, r4
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_5)) { default_layer |= (1<<5); }
    6538:	2022      	movs	r0, #34	; 0x22
    653a:	f7ff ff11 	bl	6360 <bootmagic_scan_key>
    653e:	2800      	cmp	r0, #0
    6540:	d002      	beq.n	6548 <bootmagic+0x1c8>
    6542:	2320      	movs	r3, #32
    6544:	431c      	orrs	r4, r3
    6546:	b2e4      	uxtb	r4, r4
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_6)) { default_layer |= (1<<6); }
    6548:	2023      	movs	r0, #35	; 0x23
    654a:	f7ff ff09 	bl	6360 <bootmagic_scan_key>
    654e:	2800      	cmp	r0, #0
    6550:	d015      	beq.n	657e <bootmagic+0x1fe>
    6552:	2340      	movs	r3, #64	; 0x40
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_7)) { default_layer |= (1<<7); }
    6554:	2024      	movs	r0, #36	; 0x24
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_6)) { default_layer |= (1<<6); }
    6556:	431c      	orrs	r4, r3
    6558:	b2e4      	uxtb	r4, r4
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_7)) { default_layer |= (1<<7); }
    655a:	f7ff ff01 	bl	6360 <bootmagic_scan_key>
    655e:	2800      	cmp	r0, #0
    6560:	d003      	beq.n	656a <bootmagic+0x1ea>
    6562:	2380      	movs	r3, #128	; 0x80
    6564:	425b      	negs	r3, r3
    6566:	431c      	orrs	r4, r3
    6568:	b2e4      	uxtb	r4, r4
        eeconfig_write_default_layer(default_layer);
    656a:	0020      	movs	r0, r4
    656c:	f000 fa00 	bl	6970 <eeconfig_write_default_layer>
        default_layer_set((uint32_t)default_layer);
    6570:	0020      	movs	r0, r4
    6572:	f7ff f825 	bl	55c0 <default_layer_set>
    6576:	e71e      	b.n	63b6 <bootmagic+0x36>
        eeconfig_init();
    6578:	f000 f9b2 	bl	68e0 <eeconfig_init>
    657c:	e706      	b.n	638c <bootmagic+0xc>
    if (bootmagic_scan_key(BOOTMAGIC_KEY_DEFAULT_LAYER_7)) { default_layer |= (1<<7); }
    657e:	2024      	movs	r0, #36	; 0x24
    6580:	f7ff feee 	bl	6360 <bootmagic_scan_key>
    6584:	2800      	cmp	r0, #0
    6586:	d1ec      	bne.n	6562 <bootmagic+0x1e2>
    if (default_layer) {
    6588:	2c00      	cmp	r4, #0
    658a:	d1ee      	bne.n	656a <bootmagic+0x1ea>
        default_layer = eeconfig_read_default_layer();
    658c:	f000 f9e8 	bl	6960 <eeconfig_read_default_layer>
        default_layer_set((uint32_t)default_layer);
    6590:	f7ff f816 	bl	55c0 <default_layer_set>
    6594:	e70f      	b.n	63b6 <bootmagic+0x36>
        if (bootmagic_scan_key(BOOTMAGIC_KEY_DEBUG_MATRIX)) {
    6596:	201b      	movs	r0, #27
    6598:	f7ff fee2 	bl	6360 <bootmagic_scan_key>
    659c:	2800      	cmp	r0, #0
    659e:	d010      	beq.n	65c2 <bootmagic+0x242>
            debug_config.matrix = !debug_config.matrix;
    65a0:	2101      	movs	r1, #1
    65a2:	7822      	ldrb	r2, [r4, #0]
    65a4:	0793      	lsls	r3, r2, #30
    65a6:	0fdb      	lsrs	r3, r3, #31
    65a8:	404b      	eors	r3, r1
    65aa:	2102      	movs	r1, #2
    65ac:	005b      	lsls	r3, r3, #1
    65ae:	438a      	bics	r2, r1
    65b0:	4313      	orrs	r3, r2
    65b2:	7023      	strb	r3, [r4, #0]
    65b4:	e718      	b.n	63e8 <bootmagic+0x68>
        bootloader_jump();
    65b6:	f7ff fe83 	bl	62c0 <bootloader_jump>
    65ba:	e709      	b.n	63d0 <bootmagic+0x50>
        eeconfig_init();
    65bc:	f000 f990 	bl	68e0 <eeconfig_init>
    65c0:	e700      	b.n	63c4 <bootmagic+0x44>
        } else if (bootmagic_scan_key(BOOTMAGIC_KEY_DEBUG_KEYBOARD)) {
    65c2:	200e      	movs	r0, #14
    65c4:	f7ff fecc 	bl	6360 <bootmagic_scan_key>
    65c8:	2800      	cmp	r0, #0
    65ca:	d00a      	beq.n	65e2 <bootmagic+0x262>
            debug_config.keyboard = !debug_config.keyboard;
    65cc:	2101      	movs	r1, #1
    65ce:	7822      	ldrb	r2, [r4, #0]
    65d0:	0753      	lsls	r3, r2, #29
    65d2:	0fdb      	lsrs	r3, r3, #31
    65d4:	404b      	eors	r3, r1
    65d6:	2104      	movs	r1, #4
    65d8:	009b      	lsls	r3, r3, #2
    65da:	438a      	bics	r2, r1
    65dc:	4313      	orrs	r3, r2
    65de:	7023      	strb	r3, [r4, #0]
    65e0:	e702      	b.n	63e8 <bootmagic+0x68>
        } else if (bootmagic_scan_key(BOOTMAGIC_KEY_DEBUG_MOUSE)) {
    65e2:	2010      	movs	r0, #16
    65e4:	f7ff febc 	bl	6360 <bootmagic_scan_key>
    65e8:	2800      	cmp	r0, #0
    65ea:	d00a      	beq.n	6602 <bootmagic+0x282>
            debug_config.mouse = !debug_config.mouse;
    65ec:	2101      	movs	r1, #1
    65ee:	7822      	ldrb	r2, [r4, #0]
    65f0:	0713      	lsls	r3, r2, #28
    65f2:	0fdb      	lsrs	r3, r3, #31
    65f4:	404b      	eors	r3, r1
    65f6:	2108      	movs	r1, #8
    65f8:	00db      	lsls	r3, r3, #3
    65fa:	438a      	bics	r2, r1
    65fc:	4313      	orrs	r3, r2
    65fe:	7023      	strb	r3, [r4, #0]
    6600:	e6f2      	b.n	63e8 <bootmagic+0x68>
            debug_config.enable = !debug_config.enable;
    6602:	2101      	movs	r1, #1
    6604:	7823      	ldrb	r3, [r4, #0]
    6606:	07da      	lsls	r2, r3, #31
    6608:	0fd2      	lsrs	r2, r2, #31
    660a:	404a      	eors	r2, r1
    660c:	2101      	movs	r1, #1
    660e:	438b      	bics	r3, r1
    6610:	4313      	orrs	r3, r2
    6612:	7023      	strb	r3, [r4, #0]
    6614:	e6e8      	b.n	63e8 <bootmagic+0x68>
    6616:	46c0      	nop			; (mov r8, r8)
    6618:	00008938 	.word	0x00008938
    661c:	00008950 	.word	0x00008950
    6620:	20000cb8 	.word	0x20000cb8
    6624:	20000cc4 	.word	0x20000cc4
    6628:	1ffffe31 	.word	0x1ffffe31
    662c:	00000000 	.word	0x00000000

00006630 <eeprom_read_byte>:
	} while (p < (uint16_t *)SYMVAL(__eeprom_workarea_end__));
	flashend = (uint32_t)((uint16_t *)SYMVAL(__eeprom_workarea_end__) - 1);
}

uint8_t eeprom_read_byte(const uint8_t *addr)
{
    6630:	b570      	push	{r4, r5, r6, lr}
	uint32_t offset = (uint32_t)addr;
	const uint16_t *p = (uint16_t *)SYMVAL(__eeprom_workarea_start__);
	const uint16_t *end = (const uint16_t *)((uint32_t)flashend);
    6632:	4d13      	ldr	r5, [pc, #76]	; (6680 <eeprom_read_byte+0x50>)
    6634:	682b      	ldr	r3, [r5, #0]
	uint16_t val;
	uint8_t data=0xFF;

	if (!end) {
    6636:	2b00      	cmp	r3, #0
    6638:	d10b      	bne.n	6652 <eeprom_read_byte+0x22>
    663a:	4b12      	ldr	r3, [pc, #72]	; (6684 <eeprom_read_byte+0x54>)
		if (*p++ == 0xFFFF) {
    663c:	4912      	ldr	r1, [pc, #72]	; (6688 <eeprom_read_byte+0x58>)
	} while (p < (uint16_t *)SYMVAL(__eeprom_workarea_end__));
    663e:	4c13      	ldr	r4, [pc, #76]	; (668c <eeprom_read_byte+0x5c>)
    6640:	e002      	b.n	6648 <eeprom_read_byte+0x18>
    6642:	3302      	adds	r3, #2
    6644:	42a3      	cmp	r3, r4
    6646:	d218      	bcs.n	667a <eeprom_read_byte+0x4a>
		if (*p++ == 0xFFFF) {
    6648:	881a      	ldrh	r2, [r3, #0]
    664a:	428a      	cmp	r2, r1
    664c:	d1f9      	bne.n	6642 <eeprom_read_byte+0x12>
			flashend = (uint32_t)(p - 2);
    664e:	3b02      	subs	r3, #2
    6650:	602b      	str	r3, [r5, #0]
		eeprom_initialize();
		end = (const uint16_t *)((uint32_t)flashend);
	}
	if (offset < EEPROM_SIZE) {
    6652:	287f      	cmp	r0, #127	; 0x7f
    6654:	d80f      	bhi.n	6676 <eeprom_read_byte+0x46>
		while (p <= end) {
    6656:	4a0b      	ldr	r2, [pc, #44]	; (6684 <eeprom_read_byte+0x54>)
	uint8_t data=0xFF;
    6658:	26ff      	movs	r6, #255	; 0xff
		while (p <= end) {
    665a:	4293      	cmp	r3, r2
    665c:	d309      	bcc.n	6672 <eeprom_read_byte+0x42>
			val = *p++;
			if ((val & 255) == offset) data = val >> 8;
    665e:	25ff      	movs	r5, #255	; 0xff
    6660:	002c      	movs	r4, r5
			val = *p++;
    6662:	8811      	ldrh	r1, [r2, #0]
			if ((val & 255) == offset) data = val >> 8;
    6664:	400c      	ands	r4, r1
    6666:	4284      	cmp	r4, r0
    6668:	d100      	bne.n	666c <eeprom_read_byte+0x3c>
    666a:	0a0e      	lsrs	r6, r1, #8
    666c:	3202      	adds	r2, #2
		while (p <= end) {
    666e:	4293      	cmp	r3, r2
    6670:	d2f6      	bcs.n	6660 <eeprom_read_byte+0x30>
		}
	}
	return data;
}
    6672:	0030      	movs	r0, r6
    6674:	bd70      	pop	{r4, r5, r6, pc}
	uint8_t data=0xFF;
    6676:	26ff      	movs	r6, #255	; 0xff
    6678:	e7fb      	b.n	6672 <eeprom_read_byte+0x42>
	flashend = (uint32_t)((uint16_t *)SYMVAL(__eeprom_workarea_end__) - 1);
    667a:	1ea3      	subs	r3, r4, #2
    667c:	602b      	str	r3, [r5, #0]
    667e:	e7e8      	b.n	6652 <eeprom_read_byte+0x22>
    6680:	20000cc8 	.word	0x20000cc8
    6684:	0000f800 	.word	0x0000f800
    6688:	0000ffff 	.word	0x0000ffff
    668c:	00010000 	.word	0x00010000

00006690 <eeprom_write_byte>:
	}
	MCM->PLACR |= MCM_PLACR_CFCC;
}

void eeprom_write_byte(uint8_t *addr, uint8_t data)
{
    6690:	b5f0      	push	{r4, r5, r6, r7, lr}
    6692:	46de      	mov	lr, fp
    6694:	4657      	mov	r7, sl
    6696:	464e      	mov	r6, r9
    6698:	4645      	mov	r5, r8
    669a:	b5e0      	push	{r5, r6, r7, lr}
    669c:	b0a5      	sub	sp, #148	; 0x94
	uint32_t offset = (uint32_t)addr;
	const uint16_t *p, *end = (const uint16_t *)((uint32_t)flashend);
	uint32_t i, val, flashaddr;
	uint16_t do_flash_cmd[] = {
    669e:	466d      	mov	r5, sp
	const uint16_t *p, *end = (const uint16_t *)((uint32_t)flashend);
    66a0:	4b7c      	ldr	r3, [pc, #496]	; (6894 <eeprom_write_byte+0x204>)
	uint16_t do_flash_cmd[] = {
    66a2:	4a7d      	ldr	r2, [pc, #500]	; (6898 <eeprom_write_byte+0x208>)
	const uint16_t *p, *end = (const uint16_t *)((uint32_t)flashend);
    66a4:	469b      	mov	fp, r3
    66a6:	681b      	ldr	r3, [r3, #0]
    66a8:	469c      	mov	ip, r3
	uint16_t do_flash_cmd[] = {
    66aa:	cac8      	ldmia	r2!, {r3, r6, r7}
    66ac:	c5c8      	stmia	r5!, {r3, r6, r7}
    66ae:	8812      	ldrh	r2, [r2, #0]
    66b0:	802a      	strh	r2, [r5, #0]
		0x2380, 0x7003, 0x7803, 0xb25b, 0x2b00, 0xdafb, 0x4770};
	uint8_t buf[EEPROM_SIZE];

	if (offset >= EEPROM_SIZE) return;
    66b2:	287f      	cmp	r0, #127	; 0x7f
    66b4:	d900      	bls.n	66b8 <eeprom_write_byte+0x28>
    66b6:	e0c4      	b.n	6842 <eeprom_write_byte+0x1b2>
	if (!end) {
    66b8:	4663      	mov	r3, ip
    66ba:	2b00      	cmp	r3, #0
    66bc:	d000      	beq.n	66c0 <eeprom_write_byte+0x30>
    66be:	e0c7      	b.n	6850 <eeprom_write_byte+0x1c0>
    66c0:	4a76      	ldr	r2, [pc, #472]	; (689c <eeprom_write_byte+0x20c>)
    66c2:	4b77      	ldr	r3, [pc, #476]	; (68a0 <eeprom_write_byte+0x210>)
		if (*p++ == 0xFFFF) {
    66c4:	4d77      	ldr	r5, [pc, #476]	; (68a4 <eeprom_write_byte+0x214>)
    66c6:	0016      	movs	r6, r2
    66c8:	e003      	b.n	66d2 <eeprom_write_byte+0x42>
    66ca:	3302      	adds	r3, #2
	} while (p < (uint16_t *)SYMVAL(__eeprom_workarea_end__));
    66cc:	429e      	cmp	r6, r3
    66ce:	d800      	bhi.n	66d2 <eeprom_write_byte+0x42>
    66d0:	e0da      	b.n	6888 <eeprom_write_byte+0x1f8>
		if (*p++ == 0xFFFF) {
    66d2:	881a      	ldrh	r2, [r3, #0]
    66d4:	42aa      	cmp	r2, r5
    66d6:	d1f8      	bne.n	66ca <eeprom_write_byte+0x3a>
			flashend = (uint32_t)(p - 2);
    66d8:	465a      	mov	r2, fp
    66da:	46b0      	mov	r8, r6
    66dc:	3b02      	subs	r3, #2
    66de:	6013      	str	r3, [r2, #0]
		eeprom_initialize();
		end = (const uint16_t *)((uint32_t)flashend);
	}
	if (++end < (uint16_t *)SYMVAL(__eeprom_workarea_end__)) {
    66e0:	3302      	adds	r3, #2
    66e2:	4543      	cmp	r3, r8
    66e4:	d200      	bcs.n	66e8 <eeprom_write_byte+0x58>
    66e6:	e0b9      	b.n	685c <eeprom_write_byte+0x1cc>
			val |= 0x0000FFFF;
		}
		flash_write(do_flash_cmd, flashaddr, val);
	} else {
		for (i=0; i < EEPROM_SIZE; i++) {
			buf[i] = 0xFF;
    66e8:	22ff      	movs	r2, #255	; 0xff
    66ea:	ab04      	add	r3, sp, #16
    66ec:	ad24      	add	r5, sp, #144	; 0x90
    66ee:	701a      	strb	r2, [r3, #0]
    66f0:	3301      	adds	r3, #1
		for (i=0; i < EEPROM_SIZE; i++) {
    66f2:	42ab      	cmp	r3, r5
    66f4:	d1fb      	bne.n	66ee <eeprom_write_byte+0x5e>
		}
		for (p = (uint16_t *)SYMVAL(__eeprom_workarea_start__); p < (uint16_t *)SYMVAL(__eeprom_workarea_end__); p++) {
    66f6:	4e6a      	ldr	r6, [pc, #424]	; (68a0 <eeprom_write_byte+0x210>)
    66f8:	45b0      	cmp	r8, r6
    66fa:	d91a      	bls.n	6732 <eeprom_write_byte+0xa2>
    66fc:	4642      	mov	r2, r8
    66fe:	2401      	movs	r4, #1
    6700:	1c55      	adds	r5, r2, #1
    6702:	1cb2      	adds	r2, r6, #2
    6704:	1aad      	subs	r5, r5, r2
    6706:	43a5      	bics	r5, r4
    6708:	18ad      	adds	r5, r5, r2
    670a:	22ff      	movs	r2, #255	; 0xff
    670c:	0033      	movs	r3, r6
    670e:	4694      	mov	ip, r2
    6710:	4681      	mov	r9, r0
    6712:	468a      	mov	sl, r1
    6714:	4662      	mov	r2, ip
			val = *p;
    6716:	881c      	ldrh	r4, [r3, #0]
    6718:	4022      	ands	r2, r4
			if ((val & 255) < EEPROM_SIZE) {
    671a:	2a7f      	cmp	r2, #127	; 0x7f
    671c:	d804      	bhi.n	6728 <eeprom_write_byte+0x98>
				buf[val & 255] = val >> 8;
    671e:	4669      	mov	r1, sp
    6720:	2010      	movs	r0, #16
    6722:	0a27      	lsrs	r7, r4, #8
    6724:	1809      	adds	r1, r1, r0
    6726:	548f      	strb	r7, [r1, r2]
    6728:	3302      	adds	r3, #2
		for (p = (uint16_t *)SYMVAL(__eeprom_workarea_start__); p < (uint16_t *)SYMVAL(__eeprom_workarea_end__); p++) {
    672a:	42ab      	cmp	r3, r5
    672c:	d1f2      	bne.n	6714 <eeprom_write_byte+0x84>
    672e:	4648      	mov	r0, r9
    6730:	4651      	mov	r1, sl
			}
		}
		buf[offset] = data;
    6732:	466b      	mov	r3, sp
    6734:	2210      	movs	r2, #16
    6736:	189b      	adds	r3, r3, r2
    6738:	54c1      	strb	r1, [r0, r3]
		for (flashaddr=(uint32_t)(uint16_t *)SYMVAL(__eeprom_workarea_start__); flashaddr < (uint32_t)(uint16_t *)SYMVAL(__eeprom_workarea_end__); flashaddr += 1024) {
    673a:	45b0      	cmp	r8, r6
    673c:	d926      	bls.n	678c <eeprom_write_byte+0xfc>
    673e:	2301      	movs	r3, #1
    6740:	466a      	mov	r2, sp
    6742:	431a      	orrs	r2, r3
			*(uint32_t *)&(FTFA->FCCOB3) = 0x09000000 | flashaddr;
    6744:	4b58      	ldr	r3, [pc, #352]	; (68a8 <eeprom_write_byte+0x218>)
		for (flashaddr=(uint32_t)(uint16_t *)SYMVAL(__eeprom_workarea_start__); flashaddr < (uint32_t)(uint16_t *)SYMVAL(__eeprom_workarea_end__); flashaddr += 1024) {
    6746:	0035      	movs	r5, r6
			*(uint32_t *)&(FTFA->FCCOB3) = 0x09000000 | flashaddr;
    6748:	4699      	mov	r9, r3
			__disable_irq();
			(*((void (*)(volatile uint8_t *))((uint32_t)do_flash_cmd | 1)))(&(FTFA->FSTAT));
    674a:	4643      	mov	r3, r8
    674c:	0017      	movs	r7, r2
    674e:	46b0      	mov	r8, r6
    6750:	001e      	movs	r6, r3
    6752:	4c56      	ldr	r4, [pc, #344]	; (68ac <eeprom_write_byte+0x21c>)
			*(uint32_t *)&(FTFA->FCCOB3) = 0x09000000 | flashaddr;
    6754:	2390      	movs	r3, #144	; 0x90
    6756:	464a      	mov	r2, r9
    6758:	051b      	lsls	r3, r3, #20
    675a:	432b      	orrs	r3, r5
    675c:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    675e:	b672      	cpsid	i
			(*((void (*)(volatile uint8_t *))((uint32_t)do_flash_cmd | 1)))(&(FTFA->FSTAT));
    6760:	4852      	ldr	r0, [pc, #328]	; (68ac <eeprom_write_byte+0x21c>)
    6762:	47b8      	blx	r7
  __ASM volatile ("cpsie i" : : : "memory");
    6764:	b662      	cpsie	i
    6766:	2370      	movs	r3, #112	; 0x70
			__enable_irq();
			val = FTFA->FSTAT & (FTFA_FSTAT_RDCOLERR|FTFA_FSTAT_ACCERR|FTFA_FSTAT_FPVIOL);;
    6768:	7822      	ldrb	r2, [r4, #0]
    676a:	4013      	ands	r3, r2
			if (val) FTFA->FSTAT = val;
    676c:	d000      	beq.n	6770 <eeprom_write_byte+0xe0>
    676e:	7023      	strb	r3, [r4, #0]
			MCM->PLACR |= MCM_PLACR_CFCC;
    6770:	2280      	movs	r2, #128	; 0x80
    6772:	494f      	ldr	r1, [pc, #316]	; (68b0 <eeprom_write_byte+0x220>)
    6774:	00d2      	lsls	r2, r2, #3
    6776:	68c8      	ldr	r0, [r1, #12]
    6778:	4302      	orrs	r2, r0
    677a:	60ca      	str	r2, [r1, #12]
		for (flashaddr=(uint32_t)(uint16_t *)SYMVAL(__eeprom_workarea_start__); flashaddr < (uint32_t)(uint16_t *)SYMVAL(__eeprom_workarea_end__); flashaddr += 1024) {
    677c:	2280      	movs	r2, #128	; 0x80
    677e:	00d2      	lsls	r2, r2, #3
    6780:	4694      	mov	ip, r2
    6782:	4465      	add	r5, ip
    6784:	42ae      	cmp	r6, r5
    6786:	d8e5      	bhi.n	6754 <eeprom_write_byte+0xc4>
    6788:	4646      	mov	r6, r8
			val = FTFA->FSTAT & (FTFA_FSTAT_RDCOLERR|FTFA_FSTAT_ACCERR|FTFA_FSTAT_FPVIOL);;
    678a:	001c      	movs	r4, r3
    678c:	2302      	movs	r3, #2
	(*((void (*)(volatile uint8_t *))((uint32_t)code | 1)))(&(FTFA->FSTAT));
    678e:	466a      	mov	r2, sp
    6790:	4699      	mov	r9, r3
    6792:	3b01      	subs	r3, #1
    6794:	431a      	orrs	r2, r3
		}
		flashaddr=(uint32_t)(uint16_t *)SYMVAL(__eeprom_workarea_start__);
		for (i=0; i < EEPROM_SIZE; i++) {
    6796:	2500      	movs	r5, #0
	(*((void (*)(volatile uint8_t *))((uint32_t)code | 1)))(&(FTFA->FSTAT));
    6798:	4690      	mov	r8, r2
    679a:	e022      	b.n	67e2 <eeprom_write_byte+0x152>
    679c:	042a      	lsls	r2, r5, #16
    679e:	4314      	orrs	r4, r2
			if (buf[i] == 0xFF) continue;
			if ((flashaddr & 2) == 0) {
				val = (buf[i] << 8) | i;
			} else {
				val = val | (buf[i] << 24) | (i << 16);
    67a0:	061b      	lsls	r3, r3, #24
    67a2:	431c      	orrs	r4, r3
	*(uint32_t *)&(FTFA->FCCOB3) = 0x06000000 | (addr & 0x00FFFFFC);
    67a4:	23c0      	movs	r3, #192	; 0xc0
    67a6:	4a43      	ldr	r2, [pc, #268]	; (68b4 <eeprom_write_byte+0x224>)
    67a8:	04db      	lsls	r3, r3, #19
    67aa:	4032      	ands	r2, r6
    67ac:	4313      	orrs	r3, r2
    67ae:	4a3e      	ldr	r2, [pc, #248]	; (68a8 <eeprom_write_byte+0x218>)
    67b0:	6013      	str	r3, [r2, #0]
	*(uint32_t *)&(FTFA->FCCOB7) = data;
    67b2:	4b41      	ldr	r3, [pc, #260]	; (68b8 <eeprom_write_byte+0x228>)
    67b4:	601c      	str	r4, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    67b6:	b672      	cpsid	i
	(*((void (*)(volatile uint8_t *))((uint32_t)code | 1)))(&(FTFA->FSTAT));
    67b8:	4f3c      	ldr	r7, [pc, #240]	; (68ac <eeprom_write_byte+0x21c>)
    67ba:	0038      	movs	r0, r7
    67bc:	47c0      	blx	r8
  __ASM volatile ("cpsie i" : : : "memory");
    67be:	b662      	cpsie	i
    67c0:	2270      	movs	r2, #112	; 0x70
	stat = FTFA->FSTAT & (FTFA_FSTAT_RDCOLERR|FTFA_FSTAT_ACCERR|FTFA_FSTAT_FPVIOL);
    67c2:	783b      	ldrb	r3, [r7, #0]
    67c4:	401a      	ands	r2, r3
	if (stat) {
    67c6:	d000      	beq.n	67ca <eeprom_write_byte+0x13a>
		FTFA->FSTAT = stat;
    67c8:	703a      	strb	r2, [r7, #0]
	MCM->PLACR |= MCM_PLACR_CFCC;
    67ca:	2380      	movs	r3, #128	; 0x80
    67cc:	4a38      	ldr	r2, [pc, #224]	; (68b0 <eeprom_write_byte+0x220>)
    67ce:	00db      	lsls	r3, r3, #3
    67d0:	68d1      	ldr	r1, [r2, #12]
    67d2:	430b      	orrs	r3, r1
    67d4:	60d3      	str	r3, [r2, #12]
    67d6:	464a      	mov	r2, r9
				flash_write(do_flash_cmd, flashaddr, val);
			}
			flashaddr += 2;
    67d8:	3602      	adds	r6, #2
    67da:	4032      	ands	r2, r6
		for (i=0; i < EEPROM_SIZE; i++) {
    67dc:	3501      	adds	r5, #1
    67de:	2d80      	cmp	r5, #128	; 0x80
    67e0:	d00d      	beq.n	67fe <eeprom_write_byte+0x16e>
			if (buf[i] == 0xFF) continue;
    67e2:	2210      	movs	r2, #16
    67e4:	466b      	mov	r3, sp
    67e6:	189b      	adds	r3, r3, r2
    67e8:	464a      	mov	r2, r9
    67ea:	5d5b      	ldrb	r3, [r3, r5]
    67ec:	4032      	ands	r2, r6
    67ee:	2bff      	cmp	r3, #255	; 0xff
    67f0:	d0f4      	beq.n	67dc <eeprom_write_byte+0x14c>
			if ((flashaddr & 2) == 0) {
    67f2:	2a00      	cmp	r2, #0
    67f4:	d1d2      	bne.n	679c <eeprom_write_byte+0x10c>
				val = (buf[i] << 8) | i;
    67f6:	021b      	lsls	r3, r3, #8
    67f8:	432b      	orrs	r3, r5
    67fa:	001c      	movs	r4, r3
    67fc:	e7eb      	b.n	67d6 <eeprom_write_byte+0x146>
		}
		flashend = flashaddr;
    67fe:	465b      	mov	r3, fp
    6800:	601e      	str	r6, [r3, #0]
		if ((flashaddr & 2)) {
    6802:	2a00      	cmp	r2, #0
    6804:	d01d      	beq.n	6842 <eeprom_write_byte+0x1b2>
	*(uint32_t *)&(FTFA->FCCOB3) = 0x06000000 | (addr & 0x00FFFFFC);
    6806:	4b2b      	ldr	r3, [pc, #172]	; (68b4 <eeprom_write_byte+0x224>)
    6808:	401e      	ands	r6, r3
    680a:	23c0      	movs	r3, #192	; 0xc0
    680c:	04db      	lsls	r3, r3, #19
    680e:	431e      	orrs	r6, r3
    6810:	4b25      	ldr	r3, [pc, #148]	; (68a8 <eeprom_write_byte+0x218>)
    6812:	601e      	str	r6, [r3, #0]
			val |= 0xFFFF0000;
    6814:	4b29      	ldr	r3, [pc, #164]	; (68bc <eeprom_write_byte+0x22c>)
    6816:	431c      	orrs	r4, r3
	*(uint32_t *)&(FTFA->FCCOB7) = data;
    6818:	4b27      	ldr	r3, [pc, #156]	; (68b8 <eeprom_write_byte+0x228>)
    681a:	601c      	str	r4, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    681c:	b672      	cpsid	i
	(*((void (*)(volatile uint8_t *))((uint32_t)code | 1)))(&(FTFA->FSTAT));
    681e:	2301      	movs	r3, #1
    6820:	466a      	mov	r2, sp
    6822:	4c22      	ldr	r4, [pc, #136]	; (68ac <eeprom_write_byte+0x21c>)
    6824:	4313      	orrs	r3, r2
    6826:	0020      	movs	r0, r4
    6828:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
    682a:	b662      	cpsie	i
    682c:	2370      	movs	r3, #112	; 0x70
	stat = FTFA->FSTAT & (FTFA_FSTAT_RDCOLERR|FTFA_FSTAT_ACCERR|FTFA_FSTAT_FPVIOL);
    682e:	7822      	ldrb	r2, [r4, #0]
    6830:	4013      	ands	r3, r2
	if (stat) {
    6832:	d000      	beq.n	6836 <eeprom_write_byte+0x1a6>
		FTFA->FSTAT = stat;
    6834:	7023      	strb	r3, [r4, #0]
	MCM->PLACR |= MCM_PLACR_CFCC;
    6836:	2380      	movs	r3, #128	; 0x80
    6838:	4a1d      	ldr	r2, [pc, #116]	; (68b0 <eeprom_write_byte+0x220>)
    683a:	00db      	lsls	r3, r3, #3
    683c:	68d1      	ldr	r1, [r2, #12]
    683e:	430b      	orrs	r3, r1
    6840:	60d3      	str	r3, [r2, #12]
			flash_write(do_flash_cmd, flashaddr, val);
		}
	}
}
    6842:	b025      	add	sp, #148	; 0x94
    6844:	bc3c      	pop	{r2, r3, r4, r5}
    6846:	4690      	mov	r8, r2
    6848:	4699      	mov	r9, r3
    684a:	46a2      	mov	sl, r4
    684c:	46ab      	mov	fp, r5
    684e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6850:	4a12      	ldr	r2, [pc, #72]	; (689c <eeprom_write_byte+0x20c>)
    6852:	4690      	mov	r8, r2
	if (++end < (uint16_t *)SYMVAL(__eeprom_workarea_end__)) {
    6854:	3302      	adds	r3, #2
    6856:	4543      	cmp	r3, r8
    6858:	d300      	bcc.n	685c <eeprom_write_byte+0x1cc>
    685a:	e745      	b.n	66e8 <eeprom_write_byte+0x58>
		flashend = flashaddr;
    685c:	465a      	mov	r2, fp
		val = (data << 8) | offset;
    685e:	0209      	lsls	r1, r1, #8
    6860:	4308      	orrs	r0, r1
		flashend = flashaddr;
    6862:	6013      	str	r3, [r2, #0]
		if ((flashaddr & 2) == 0) {
    6864:	079a      	lsls	r2, r3, #30
    6866:	d50c      	bpl.n	6882 <eeprom_write_byte+0x1f2>
			val |= 0x0000FFFF;
    6868:	490e      	ldr	r1, [pc, #56]	; (68a4 <eeprom_write_byte+0x214>)
			val <<= 16;
    686a:	0400      	lsls	r0, r0, #16
			val |= 0x0000FFFF;
    686c:	4308      	orrs	r0, r1
	*(uint32_t *)&(FTFA->FCCOB3) = 0x06000000 | (addr & 0x00FFFFFC);
    686e:	4a11      	ldr	r2, [pc, #68]	; (68b4 <eeprom_write_byte+0x224>)
    6870:	4013      	ands	r3, r2
    6872:	22c0      	movs	r2, #192	; 0xc0
    6874:	04d2      	lsls	r2, r2, #19
    6876:	4313      	orrs	r3, r2
    6878:	4a0b      	ldr	r2, [pc, #44]	; (68a8 <eeprom_write_byte+0x218>)
    687a:	6013      	str	r3, [r2, #0]
	*(uint32_t *)&(FTFA->FCCOB7) = data;
    687c:	4b0e      	ldr	r3, [pc, #56]	; (68b8 <eeprom_write_byte+0x228>)
    687e:	6018      	str	r0, [r3, #0]
    6880:	e7cc      	b.n	681c <eeprom_write_byte+0x18c>
			val |= 0xFFFF0000;
    6882:	490e      	ldr	r1, [pc, #56]	; (68bc <eeprom_write_byte+0x22c>)
    6884:	4308      	orrs	r0, r1
    6886:	e7f2      	b.n	686e <eeprom_write_byte+0x1de>
	flashend = (uint32_t)((uint16_t *)SYMVAL(__eeprom_workarea_end__) - 1);
    6888:	0033      	movs	r3, r6
    688a:	465a      	mov	r2, fp
    688c:	3b02      	subs	r3, #2
    688e:	46b0      	mov	r8, r6
    6890:	6013      	str	r3, [r2, #0]
    6892:	e7df      	b.n	6854 <eeprom_write_byte+0x1c4>
    6894:	20000cc8 	.word	0x20000cc8
    6898:	00007a24 	.word	0x00007a24
    689c:	00010000 	.word	0x00010000
    68a0:	0000f800 	.word	0x0000f800
    68a4:	0000ffff 	.word	0x0000ffff
    68a8:	40020004 	.word	0x40020004
    68ac:	40020000 	.word	0x40020000
    68b0:	f0003000 	.word	0xf0003000
    68b4:	00fffffc 	.word	0x00fffffc
    68b8:	40020008 	.word	0x40020008
    68bc:	ffff0000 	.word	0xffff0000

000068c0 <eeprom_read_word>:
   c:	4770      	bx	lr
*/


uint16_t eeprom_read_word(const uint16_t *addr)
{
    68c0:	b570      	push	{r4, r5, r6, lr}
    68c2:	0004      	movs	r4, r0
	const uint8_t *p = (const uint8_t *)addr;
	return eeprom_read_byte(p) | (eeprom_read_byte(p+1) << 8);
    68c4:	f7ff feb4 	bl	6630 <eeprom_read_byte>
    68c8:	0005      	movs	r5, r0
    68ca:	1c60      	adds	r0, r4, #1
    68cc:	f7ff feb0 	bl	6630 <eeprom_read_byte>
    68d0:	0200      	lsls	r0, r0, #8
    68d2:	4328      	orrs	r0, r5
    68d4:	b280      	uxth	r0, r0
}
    68d6:	bd70      	pop	{r4, r5, r6, pc}
	...

000068e0 <eeconfig_init>:
/*****************/
/* TMK functions */
/*****************/

void eeconfig_init(void)
{
    68e0:	b510      	push	{r4, lr}
	eeprom_write_byte(p++, value);
    68e2:	21ed      	movs	r1, #237	; 0xed
    68e4:	2000      	movs	r0, #0
    68e6:	f7ff fed3 	bl	6690 <eeprom_write_byte>
	eeprom_write_byte(p, value >> 8);
    68ea:	21fe      	movs	r1, #254	; 0xfe
    68ec:	2001      	movs	r0, #1
    68ee:	f7ff fecf 	bl	6690 <eeprom_write_byte>
    eeprom_write_word(EECONFIG_MAGIC,          EECONFIG_MAGIC_NUMBER);
    eeprom_write_byte(EECONFIG_DEBUG,          0);
    68f2:	2100      	movs	r1, #0
    68f4:	2002      	movs	r0, #2
    68f6:	f7ff fecb 	bl	6690 <eeprom_write_byte>
    eeprom_write_byte(EECONFIG_DEFAULT_LAYER,  0);
    68fa:	2100      	movs	r1, #0
    68fc:	2003      	movs	r0, #3
    68fe:	f7ff fec7 	bl	6690 <eeprom_write_byte>
    eeprom_write_byte(EECONFIG_KEYMAP,         0);
    6902:	2100      	movs	r1, #0
    6904:	2004      	movs	r0, #4
    6906:	f7ff fec3 	bl	6690 <eeprom_write_byte>
    eeprom_write_byte(EECONFIG_MOUSEKEY_ACCEL, 0);
    690a:	2100      	movs	r1, #0
    690c:	2005      	movs	r0, #5
    690e:	f7ff febf 	bl	6690 <eeprom_write_byte>
#ifdef BACKLIGHT_ENABLE
    eeprom_write_byte(EECONFIG_BACKLIGHT,      0);
#endif
}
    6912:	bd10      	pop	{r4, pc}
	...

00006920 <eeconfig_is_enabled>:
{
    eeprom_write_word(EECONFIG_MAGIC, 0xFFFF);
}

bool eeconfig_is_enabled(void)
{
    6920:	b510      	push	{r4, lr}
    return (eeprom_read_word(EECONFIG_MAGIC) == EECONFIG_MAGIC_NUMBER);
    6922:	2000      	movs	r0, #0
    6924:	f7ff ffcc 	bl	68c0 <eeprom_read_word>
    6928:	4b03      	ldr	r3, [pc, #12]	; (6938 <eeconfig_is_enabled+0x18>)
    692a:	469c      	mov	ip, r3
    692c:	4460      	add	r0, ip
    692e:	4243      	negs	r3, r0
    6930:	4158      	adcs	r0, r3
    6932:	b2c0      	uxtb	r0, r0
}
    6934:	bd10      	pop	{r4, pc}
    6936:	46c0      	nop			; (mov r8, r8)
    6938:	ffff0113 	.word	0xffff0113
    693c:	00000000 	.word	0x00000000

00006940 <eeconfig_read_debug>:

uint8_t eeconfig_read_debug(void)      { return eeprom_read_byte(EECONFIG_DEBUG); }
    6940:	b510      	push	{r4, lr}
    6942:	2002      	movs	r0, #2
    6944:	f7ff fe74 	bl	6630 <eeprom_read_byte>
    6948:	bd10      	pop	{r4, pc}
    694a:	46c0      	nop			; (mov r8, r8)
    694c:	0000      	movs	r0, r0
	...

00006950 <eeconfig_write_debug>:
void eeconfig_write_debug(uint8_t val) { eeprom_write_byte(EECONFIG_DEBUG, val); }
    6950:	b510      	push	{r4, lr}
    6952:	0001      	movs	r1, r0
    6954:	2002      	movs	r0, #2
    6956:	f7ff fe9b 	bl	6690 <eeprom_write_byte>
    695a:	bd10      	pop	{r4, pc}
    695c:	0000      	movs	r0, r0
	...

00006960 <eeconfig_read_default_layer>:

uint8_t eeconfig_read_default_layer(void)      { return eeprom_read_byte(EECONFIG_DEFAULT_LAYER); }
    6960:	b510      	push	{r4, lr}
    6962:	2003      	movs	r0, #3
    6964:	f7ff fe64 	bl	6630 <eeprom_read_byte>
    6968:	bd10      	pop	{r4, pc}
    696a:	46c0      	nop			; (mov r8, r8)
    696c:	0000      	movs	r0, r0
	...

00006970 <eeconfig_write_default_layer>:
void eeconfig_write_default_layer(uint8_t val) { eeprom_write_byte(EECONFIG_DEFAULT_LAYER, val); }
    6970:	b510      	push	{r4, lr}
    6972:	0001      	movs	r1, r0
    6974:	2003      	movs	r0, #3
    6976:	f7ff fe8b 	bl	6690 <eeprom_write_byte>
    697a:	bd10      	pop	{r4, pc}
    697c:	0000      	movs	r0, r0
	...

00006980 <eeconfig_read_keymap>:

uint8_t eeconfig_read_keymap(void)      { return eeprom_read_byte(EECONFIG_KEYMAP); }
    6980:	b510      	push	{r4, lr}
    6982:	2004      	movs	r0, #4
    6984:	f7ff fe54 	bl	6630 <eeprom_read_byte>
    6988:	bd10      	pop	{r4, pc}
    698a:	46c0      	nop			; (mov r8, r8)
    698c:	0000      	movs	r0, r0
	...

00006990 <eeconfig_write_keymap>:
void eeconfig_write_keymap(uint8_t val) { eeprom_write_byte(EECONFIG_KEYMAP, val); }
    6990:	b510      	push	{r4, lr}
    6992:	0001      	movs	r1, r0
    6994:	2004      	movs	r0, #4
    6996:	f7ff fe7b 	bl	6690 <eeprom_write_byte>
    699a:	bd10      	pop	{r4, pc}
    699c:	0000      	movs	r0, r0
	...

000069a0 <move_unit>:

static uint16_t last_timer = 0;


static uint8_t move_unit(void)
{
    69a0:	b510      	push	{r4, lr}
    uint16_t unit;
    if (mousekey_accel & (1<<0)) {
    69a2:	4b1b      	ldr	r3, [pc, #108]	; (6a10 <move_unit+0x70>)
    69a4:	781b      	ldrb	r3, [r3, #0]
    69a6:	07da      	lsls	r2, r3, #31
    69a8:	d50a      	bpl.n	69c0 <move_unit+0x20>
        unit = (MOUSEKEY_MOVE_DELTA * mk_max_speed)/4;
    69aa:	4b1a      	ldr	r3, [pc, #104]	; (6a14 <move_unit+0x74>)
    69ac:	7818      	ldrb	r0, [r3, #0]
    69ae:	0083      	lsls	r3, r0, #2
    69b0:	181b      	adds	r3, r3, r0
    69b2:	089b      	lsrs	r3, r3, #2
    } else if (mousekey_repeat >= mk_time_to_max) {
        unit = MOUSEKEY_MOVE_DELTA * mk_max_speed;
    } else {
        unit = (MOUSEKEY_MOVE_DELTA * mk_max_speed * mousekey_repeat) / mk_time_to_max;
    }
    return (unit > MOUSEKEY_MOVE_MAX ? MOUSEKEY_MOVE_MAX : (unit == 0 ? 1 : unit));
    69b4:	2b7f      	cmp	r3, #127	; 0x7f
    69b6:	d80c      	bhi.n	69d2 <move_unit+0x32>
    69b8:	2001      	movs	r0, #1
    69ba:	2b00      	cmp	r3, #0
    69bc:	d10b      	bne.n	69d6 <move_unit+0x36>
}
    69be:	bd10      	pop	{r4, pc}
    } else if (mousekey_accel & (1<<1)) {
    69c0:	079a      	lsls	r2, r3, #30
    69c2:	d50a      	bpl.n	69da <move_unit+0x3a>
        unit = (MOUSEKEY_MOVE_DELTA * mk_max_speed)/2;
    69c4:	4b13      	ldr	r3, [pc, #76]	; (6a14 <move_unit+0x74>)
    69c6:	7818      	ldrb	r0, [r3, #0]
    69c8:	0083      	lsls	r3, r0, #2
    69ca:	181b      	adds	r3, r3, r0
    69cc:	085b      	lsrs	r3, r3, #1
    return (unit > MOUSEKEY_MOVE_MAX ? MOUSEKEY_MOVE_MAX : (unit == 0 ? 1 : unit));
    69ce:	2b7f      	cmp	r3, #127	; 0x7f
    69d0:	d9f2      	bls.n	69b8 <move_unit+0x18>
    69d2:	207f      	movs	r0, #127	; 0x7f
    69d4:	e7f3      	b.n	69be <move_unit+0x1e>
    69d6:	b2d8      	uxtb	r0, r3
    69d8:	e7f1      	b.n	69be <move_unit+0x1e>
    } else if (mousekey_accel & (1<<2)) {
    69da:	075b      	lsls	r3, r3, #29
    69dc:	d40d      	bmi.n	69fa <move_unit+0x5a>
    } else if (mousekey_repeat == 0) {
    69de:	4b0e      	ldr	r3, [pc, #56]	; (6a18 <move_unit+0x78>)
    69e0:	2005      	movs	r0, #5
    69e2:	781a      	ldrb	r2, [r3, #0]
    69e4:	2a00      	cmp	r2, #0
    69e6:	d0ea      	beq.n	69be <move_unit+0x1e>
    } else if (mousekey_repeat >= mk_time_to_max) {
    69e8:	4b0c      	ldr	r3, [pc, #48]	; (6a1c <move_unit+0x7c>)
    69ea:	7819      	ldrb	r1, [r3, #0]
    69ec:	4b09      	ldr	r3, [pc, #36]	; (6a14 <move_unit+0x74>)
    69ee:	781b      	ldrb	r3, [r3, #0]
        unit = MOUSEKEY_MOVE_DELTA * mk_max_speed;
    69f0:	0098      	lsls	r0, r3, #2
    } else if (mousekey_repeat >= mk_time_to_max) {
    69f2:	428a      	cmp	r2, r1
    69f4:	d306      	bcc.n	6a04 <move_unit+0x64>
        unit = MOUSEKEY_MOVE_DELTA * mk_max_speed;
    69f6:	181b      	adds	r3, r3, r0
    69f8:	e7dc      	b.n	69b4 <move_unit+0x14>
        unit = (MOUSEKEY_MOVE_DELTA * mk_max_speed);
    69fa:	4b06      	ldr	r3, [pc, #24]	; (6a14 <move_unit+0x74>)
    69fc:	781b      	ldrb	r3, [r3, #0]
    69fe:	0098      	lsls	r0, r3, #2
    6a00:	181b      	adds	r3, r3, r0
    6a02:	e7d7      	b.n	69b4 <move_unit+0x14>
        unit = (MOUSEKEY_MOVE_DELTA * mk_max_speed * mousekey_repeat) / mk_time_to_max;
    6a04:	18c0      	adds	r0, r0, r3
    6a06:	4350      	muls	r0, r2
    6a08:	f7f9 fe1a 	bl	640 <__divsi3>
    6a0c:	b283      	uxth	r3, r0
    6a0e:	e7d1      	b.n	69b4 <move_unit+0x14>
    6a10:	20000cd5 	.word	0x20000cd5
    6a14:	1ffffe3a 	.word	0x1ffffe3a
    6a18:	20000cd6 	.word	0x20000cd6
    6a1c:	1ffffe3b 	.word	0x1ffffe3b

00006a20 <wheel_unit>:

static uint8_t wheel_unit(void)
{
    6a20:	b510      	push	{r4, lr}
    uint16_t unit;
    if (mousekey_accel & (1<<0)) {
    6a22:	4b17      	ldr	r3, [pc, #92]	; (6a80 <wheel_unit+0x60>)
    6a24:	781b      	ldrb	r3, [r3, #0]
    6a26:	07da      	lsls	r2, r3, #31
    6a28:	d506      	bpl.n	6a38 <wheel_unit+0x18>
        unit = (MOUSEKEY_WHEEL_DELTA * mk_wheel_max_speed)/4;
    6a2a:	4b16      	ldr	r3, [pc, #88]	; (6a84 <wheel_unit+0x64>)
    6a2c:	781b      	ldrb	r3, [r3, #0]
    6a2e:	089b      	lsrs	r3, r3, #2
    } else if (mousekey_repeat >= mk_wheel_time_to_max) {
        unit = MOUSEKEY_WHEEL_DELTA * mk_wheel_max_speed;
    } else {
        unit = (MOUSEKEY_WHEEL_DELTA * mk_wheel_max_speed * mousekey_repeat) / mk_wheel_time_to_max;
    }
    return (unit > MOUSEKEY_WHEEL_MAX ? MOUSEKEY_WHEEL_MAX : (unit == 0 ? 1 : unit));
    6a30:	2001      	movs	r0, #1
    6a32:	2b00      	cmp	r3, #0
    6a34:	d107      	bne.n	6a46 <wheel_unit+0x26>
}
    6a36:	bd10      	pop	{r4, pc}
    } else if (mousekey_accel & (1<<1)) {
    6a38:	079a      	lsls	r2, r3, #30
    6a3a:	d506      	bpl.n	6a4a <wheel_unit+0x2a>
        unit = (MOUSEKEY_WHEEL_DELTA * mk_wheel_max_speed)/2;
    6a3c:	4b11      	ldr	r3, [pc, #68]	; (6a84 <wheel_unit+0x64>)
    return (unit > MOUSEKEY_WHEEL_MAX ? MOUSEKEY_WHEEL_MAX : (unit == 0 ? 1 : unit));
    6a3e:	2001      	movs	r0, #1
        unit = (MOUSEKEY_WHEEL_DELTA * mk_wheel_max_speed)/2;
    6a40:	781b      	ldrb	r3, [r3, #0]
    6a42:	085b      	lsrs	r3, r3, #1
    return (unit > MOUSEKEY_WHEEL_MAX ? MOUSEKEY_WHEEL_MAX : (unit == 0 ? 1 : unit));
    6a44:	d0f7      	beq.n	6a36 <wheel_unit+0x16>
    6a46:	b2d8      	uxtb	r0, r3
    6a48:	e7f5      	b.n	6a36 <wheel_unit+0x16>
    } else if (mousekey_accel & (1<<2)) {
    6a4a:	075b      	lsls	r3, r3, #29
    6a4c:	d505      	bpl.n	6a5a <wheel_unit+0x3a>
        unit = (MOUSEKEY_WHEEL_DELTA * mk_wheel_max_speed);
    6a4e:	4b0d      	ldr	r3, [pc, #52]	; (6a84 <wheel_unit+0x64>)
    6a50:	781b      	ldrb	r3, [r3, #0]
    return (unit > MOUSEKEY_WHEEL_MAX ? MOUSEKEY_WHEEL_MAX : (unit == 0 ? 1 : unit));
    6a52:	207f      	movs	r0, #127	; 0x7f
    6a54:	2b7f      	cmp	r3, #127	; 0x7f
    6a56:	d8ee      	bhi.n	6a36 <wheel_unit+0x16>
    6a58:	e7ea      	b.n	6a30 <wheel_unit+0x10>
    } else if (mousekey_repeat == 0) {
    6a5a:	4b0b      	ldr	r3, [pc, #44]	; (6a88 <wheel_unit+0x68>)
    6a5c:	2001      	movs	r0, #1
    6a5e:	781b      	ldrb	r3, [r3, #0]
    6a60:	2b00      	cmp	r3, #0
    6a62:	d0e8      	beq.n	6a36 <wheel_unit+0x16>
    } else if (mousekey_repeat >= mk_wheel_time_to_max) {
    6a64:	4a09      	ldr	r2, [pc, #36]	; (6a8c <wheel_unit+0x6c>)
    6a66:	7811      	ldrb	r1, [r2, #0]
    6a68:	4a06      	ldr	r2, [pc, #24]	; (6a84 <wheel_unit+0x64>)
    6a6a:	7810      	ldrb	r0, [r2, #0]
    6a6c:	428b      	cmp	r3, r1
    6a6e:	d301      	bcc.n	6a74 <wheel_unit+0x54>
        unit = (MOUSEKEY_WHEEL_DELTA * mk_wheel_max_speed * mousekey_repeat) / mk_wheel_time_to_max;
    6a70:	b283      	uxth	r3, r0
    6a72:	e7ee      	b.n	6a52 <wheel_unit+0x32>
    6a74:	4358      	muls	r0, r3
    6a76:	f7f9 fde3 	bl	640 <__divsi3>
    6a7a:	b283      	uxth	r3, r0
    6a7c:	e7e9      	b.n	6a52 <wheel_unit+0x32>
    6a7e:	46c0      	nop			; (mov r8, r8)
    6a80:	20000cd5 	.word	0x20000cd5
    6a84:	1ffffe3c 	.word	0x1ffffe3c
    6a88:	20000cd6 	.word	0x20000cd6
    6a8c:	1ffffe3d 	.word	0x1ffffe3d

00006a90 <mousekey_on>:

    mousekey_send();
}

void mousekey_on(uint8_t code)
{
    6a90:	b510      	push	{r4, lr}
    if      (code == KC_MS_UP)       mouse_report.y = move_unit() * -1;
    6a92:	28f0      	cmp	r0, #240	; 0xf0
    6a94:	d028      	beq.n	6ae8 <mousekey_on+0x58>
    else if (code == KC_MS_DOWN)     mouse_report.y = move_unit();
    6a96:	28f1      	cmp	r0, #241	; 0xf1
    6a98:	d021      	beq.n	6ade <mousekey_on+0x4e>
    else if (code == KC_MS_LEFT)     mouse_report.x = move_unit() * -1;
    6a9a:	28f2      	cmp	r0, #242	; 0xf2
    6a9c:	d02f      	beq.n	6afe <mousekey_on+0x6e>
    else if (code == KC_MS_RIGHT)    mouse_report.x = move_unit();
    6a9e:	28f3      	cmp	r0, #243	; 0xf3
    6aa0:	d033      	beq.n	6b0a <mousekey_on+0x7a>
    else if (code == KC_MS_WH_UP)    mouse_report.v = wheel_unit();
    6aa2:	28f9      	cmp	r0, #249	; 0xf9
    6aa4:	d026      	beq.n	6af4 <mousekey_on+0x64>
    else if (code == KC_MS_WH_DOWN)  mouse_report.v = wheel_unit() * -1;
    6aa6:	28fa      	cmp	r0, #250	; 0xfa
    6aa8:	d03a      	beq.n	6b20 <mousekey_on+0x90>
    else if (code == KC_MS_WH_LEFT)  mouse_report.h = wheel_unit() * -1;
    6aaa:	28fb      	cmp	r0, #251	; 0xfb
    6aac:	d03e      	beq.n	6b2c <mousekey_on+0x9c>
    else if (code == KC_MS_WH_RIGHT) mouse_report.h = wheel_unit();
    6aae:	28fc      	cmp	r0, #252	; 0xfc
    6ab0:	d042      	beq.n	6b38 <mousekey_on+0xa8>
    else if (code == KC_MS_BTN1)     mouse_report.buttons |= MOUSE_BTN1;
    6ab2:	28f4      	cmp	r0, #244	; 0xf4
    6ab4:	d02e      	beq.n	6b14 <mousekey_on+0x84>
    else if (code == KC_MS_BTN2)     mouse_report.buttons |= MOUSE_BTN2;
    6ab6:	28f5      	cmp	r0, #245	; 0xf5
    6ab8:	d043      	beq.n	6b42 <mousekey_on+0xb2>
    else if (code == KC_MS_BTN3)     mouse_report.buttons |= MOUSE_BTN3;
    6aba:	28f6      	cmp	r0, #246	; 0xf6
    6abc:	d047      	beq.n	6b4e <mousekey_on+0xbe>
    else if (code == KC_MS_BTN4)     mouse_report.buttons |= MOUSE_BTN4;
    6abe:	28f7      	cmp	r0, #247	; 0xf7
    6ac0:	d04b      	beq.n	6b5a <mousekey_on+0xca>
    else if (code == KC_MS_BTN5)     mouse_report.buttons |= MOUSE_BTN5;
    6ac2:	28f8      	cmp	r0, #248	; 0xf8
    6ac4:	d04f      	beq.n	6b66 <mousekey_on+0xd6>
    else if (code == KC_MS_ACCEL0)   mousekey_accel |= (1<<0);
    6ac6:	28fd      	cmp	r0, #253	; 0xfd
    6ac8:	d053      	beq.n	6b72 <mousekey_on+0xe2>
    else if (code == KC_MS_ACCEL1)   mousekey_accel |= (1<<1);
    6aca:	28fe      	cmp	r0, #254	; 0xfe
    6acc:	d057      	beq.n	6b7e <mousekey_on+0xee>
    else if (code == KC_MS_ACCEL2)   mousekey_accel |= (1<<2);
    6ace:	28ff      	cmp	r0, #255	; 0xff
    6ad0:	d109      	bne.n	6ae6 <mousekey_on+0x56>
    6ad2:	2104      	movs	r1, #4
    6ad4:	4a2d      	ldr	r2, [pc, #180]	; (6b8c <mousekey_on+0xfc>)
    6ad6:	7813      	ldrb	r3, [r2, #0]
    6ad8:	430b      	orrs	r3, r1
    6ada:	7013      	strb	r3, [r2, #0]
}
    6adc:	e003      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_DOWN)     mouse_report.y = move_unit();
    6ade:	f7ff ff5f 	bl	69a0 <move_unit>
    6ae2:	4b2b      	ldr	r3, [pc, #172]	; (6b90 <mousekey_on+0x100>)
    6ae4:	7098      	strb	r0, [r3, #2]
}
    6ae6:	bd10      	pop	{r4, pc}
    if      (code == KC_MS_UP)       mouse_report.y = move_unit() * -1;
    6ae8:	f7ff ff5a 	bl	69a0 <move_unit>
    6aec:	4b28      	ldr	r3, [pc, #160]	; (6b90 <mousekey_on+0x100>)
    6aee:	4240      	negs	r0, r0
    6af0:	7098      	strb	r0, [r3, #2]
    6af2:	e7f8      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_WH_UP)    mouse_report.v = wheel_unit();
    6af4:	f7ff ff94 	bl	6a20 <wheel_unit>
    6af8:	4b25      	ldr	r3, [pc, #148]	; (6b90 <mousekey_on+0x100>)
    6afa:	70d8      	strb	r0, [r3, #3]
    6afc:	e7f3      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_LEFT)     mouse_report.x = move_unit() * -1;
    6afe:	f7ff ff4f 	bl	69a0 <move_unit>
    6b02:	4b23      	ldr	r3, [pc, #140]	; (6b90 <mousekey_on+0x100>)
    6b04:	4240      	negs	r0, r0
    6b06:	7058      	strb	r0, [r3, #1]
    6b08:	e7ed      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_RIGHT)    mouse_report.x = move_unit();
    6b0a:	f7ff ff49 	bl	69a0 <move_unit>
    6b0e:	4b20      	ldr	r3, [pc, #128]	; (6b90 <mousekey_on+0x100>)
    6b10:	7058      	strb	r0, [r3, #1]
    6b12:	e7e8      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_BTN1)     mouse_report.buttons |= MOUSE_BTN1;
    6b14:	2101      	movs	r1, #1
    6b16:	4a1e      	ldr	r2, [pc, #120]	; (6b90 <mousekey_on+0x100>)
    6b18:	7813      	ldrb	r3, [r2, #0]
    6b1a:	430b      	orrs	r3, r1
    6b1c:	7013      	strb	r3, [r2, #0]
    6b1e:	e7e2      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_WH_DOWN)  mouse_report.v = wheel_unit() * -1;
    6b20:	f7ff ff7e 	bl	6a20 <wheel_unit>
    6b24:	4b1a      	ldr	r3, [pc, #104]	; (6b90 <mousekey_on+0x100>)
    6b26:	4240      	negs	r0, r0
    6b28:	70d8      	strb	r0, [r3, #3]
    6b2a:	e7dc      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_WH_LEFT)  mouse_report.h = wheel_unit() * -1;
    6b2c:	f7ff ff78 	bl	6a20 <wheel_unit>
    6b30:	4b17      	ldr	r3, [pc, #92]	; (6b90 <mousekey_on+0x100>)
    6b32:	4240      	negs	r0, r0
    6b34:	7118      	strb	r0, [r3, #4]
    6b36:	e7d6      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_WH_RIGHT) mouse_report.h = wheel_unit();
    6b38:	f7ff ff72 	bl	6a20 <wheel_unit>
    6b3c:	4b14      	ldr	r3, [pc, #80]	; (6b90 <mousekey_on+0x100>)
    6b3e:	7118      	strb	r0, [r3, #4]
    6b40:	e7d1      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_BTN2)     mouse_report.buttons |= MOUSE_BTN2;
    6b42:	2102      	movs	r1, #2
    6b44:	4a12      	ldr	r2, [pc, #72]	; (6b90 <mousekey_on+0x100>)
    6b46:	7813      	ldrb	r3, [r2, #0]
    6b48:	430b      	orrs	r3, r1
    6b4a:	7013      	strb	r3, [r2, #0]
    6b4c:	e7cb      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_BTN3)     mouse_report.buttons |= MOUSE_BTN3;
    6b4e:	2104      	movs	r1, #4
    6b50:	4a0f      	ldr	r2, [pc, #60]	; (6b90 <mousekey_on+0x100>)
    6b52:	7813      	ldrb	r3, [r2, #0]
    6b54:	430b      	orrs	r3, r1
    6b56:	7013      	strb	r3, [r2, #0]
    6b58:	e7c5      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_BTN4)     mouse_report.buttons |= MOUSE_BTN4;
    6b5a:	2108      	movs	r1, #8
    6b5c:	4a0c      	ldr	r2, [pc, #48]	; (6b90 <mousekey_on+0x100>)
    6b5e:	7813      	ldrb	r3, [r2, #0]
    6b60:	430b      	orrs	r3, r1
    6b62:	7013      	strb	r3, [r2, #0]
    6b64:	e7bf      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_BTN5)     mouse_report.buttons |= MOUSE_BTN5;
    6b66:	2110      	movs	r1, #16
    6b68:	4a09      	ldr	r2, [pc, #36]	; (6b90 <mousekey_on+0x100>)
    6b6a:	7813      	ldrb	r3, [r2, #0]
    6b6c:	430b      	orrs	r3, r1
    6b6e:	7013      	strb	r3, [r2, #0]
    6b70:	e7b9      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_ACCEL0)   mousekey_accel |= (1<<0);
    6b72:	2101      	movs	r1, #1
    6b74:	4a05      	ldr	r2, [pc, #20]	; (6b8c <mousekey_on+0xfc>)
    6b76:	7813      	ldrb	r3, [r2, #0]
    6b78:	430b      	orrs	r3, r1
    6b7a:	7013      	strb	r3, [r2, #0]
    6b7c:	e7b3      	b.n	6ae6 <mousekey_on+0x56>
    else if (code == KC_MS_ACCEL1)   mousekey_accel |= (1<<1);
    6b7e:	2102      	movs	r1, #2
    6b80:	4a02      	ldr	r2, [pc, #8]	; (6b8c <mousekey_on+0xfc>)
    6b82:	7813      	ldrb	r3, [r2, #0]
    6b84:	430b      	orrs	r3, r1
    6b86:	7013      	strb	r3, [r2, #0]
    6b88:	e7ad      	b.n	6ae6 <mousekey_on+0x56>
    6b8a:	46c0      	nop			; (mov r8, r8)
    6b8c:	20000cd5 	.word	0x20000cd5
    6b90:	20000cd0 	.word	0x20000cd0
	...

00006ba0 <mousekey_off>:

void mousekey_off(uint8_t code)
{
    6ba0:	2201      	movs	r2, #1
    6ba2:	b510      	push	{r4, lr}
    6ba4:	4b43      	ldr	r3, [pc, #268]	; (6cb4 <mousekey_off+0x114>)
    6ba6:	569a      	ldrsb	r2, [r3, r2]
    if      (code == KC_MS_UP       && mouse_report.y < 0) mouse_report.y = 0;
    6ba8:	28f0      	cmp	r0, #240	; 0xf0
    6baa:	d03f      	beq.n	6c2c <mousekey_off+0x8c>
    else if (code == KC_MS_DOWN     && mouse_report.y > 0) mouse_report.y = 0;
    6bac:	28f1      	cmp	r0, #241	; 0xf1
    6bae:	d021      	beq.n	6bf4 <mousekey_off+0x54>
    else if (code == KC_MS_LEFT     && mouse_report.x < 0) mouse_report.x = 0;
    6bb0:	28f2      	cmp	r0, #242	; 0xf2
    6bb2:	d041      	beq.n	6c38 <mousekey_off+0x98>
    else if (code == KC_MS_RIGHT    && mouse_report.x > 0) mouse_report.x = 0;
    6bb4:	28f3      	cmp	r0, #243	; 0xf3
    6bb6:	d030      	beq.n	6c1a <mousekey_off+0x7a>
    else if (code == KC_MS_WH_UP    && mouse_report.v > 0) mouse_report.v = 0;
    6bb8:	28f9      	cmp	r0, #249	; 0xf9
    6bba:	d041      	beq.n	6c40 <mousekey_off+0xa0>
    else if (code == KC_MS_WH_DOWN  && mouse_report.v < 0) mouse_report.v = 0;
    6bbc:	28fa      	cmp	r0, #250	; 0xfa
    6bbe:	d04d      	beq.n	6c5c <mousekey_off+0xbc>
    else if (code == KC_MS_WH_LEFT  && mouse_report.h < 0) mouse_report.h = 0;
    6bc0:	28fb      	cmp	r0, #251	; 0xfb
    6bc2:	d04f      	beq.n	6c64 <mousekey_off+0xc4>
    else if (code == KC_MS_WH_RIGHT && mouse_report.h > 0) mouse_report.h = 0;
    6bc4:	28fc      	cmp	r0, #252	; 0xfc
    6bc6:	d053      	beq.n	6c70 <mousekey_off+0xd0>
    else if (code == KC_MS_BTN1) mouse_report.buttons &= ~MOUSE_BTN1;
    6bc8:	28f4      	cmp	r0, #244	; 0xf4
    6bca:	d042      	beq.n	6c52 <mousekey_off+0xb2>
    else if (code == KC_MS_BTN2) mouse_report.buttons &= ~MOUSE_BTN2;
    6bcc:	28f5      	cmp	r0, #245	; 0xf5
    6bce:	d040      	beq.n	6c52 <mousekey_off+0xb2>
    else if (code == KC_MS_BTN3) mouse_report.buttons &= ~MOUSE_BTN3;
    6bd0:	28f6      	cmp	r0, #246	; 0xf6
    6bd2:	d052      	beq.n	6c7a <mousekey_off+0xda>
    else if (code == KC_MS_BTN4) mouse_report.buttons &= ~MOUSE_BTN4;
    6bd4:	28f7      	cmp	r0, #247	; 0xf7
    6bd6:	d055      	beq.n	6c84 <mousekey_off+0xe4>
    else if (code == KC_MS_BTN5) mouse_report.buttons &= ~MOUSE_BTN5;
    6bd8:	28f8      	cmp	r0, #248	; 0xf8
    6bda:	d058      	beq.n	6c8e <mousekey_off+0xee>
    else if (code == KC_MS_ACCEL0) mousekey_accel &= ~(1<<0);
    6bdc:	28fd      	cmp	r0, #253	; 0xfd
    6bde:	d05b      	beq.n	6c98 <mousekey_off+0xf8>
    else if (code == KC_MS_ACCEL1) mousekey_accel &= ~(1<<1);
    6be0:	28fe      	cmp	r0, #254	; 0xfe
    6be2:	d15f      	bne.n	6ca4 <mousekey_off+0x104>
    6be4:	2402      	movs	r4, #2
    6be6:	4834      	ldr	r0, [pc, #208]	; (6cb8 <mousekey_off+0x118>)
    6be8:	7801      	ldrb	r1, [r0, #0]
    6bea:	43a1      	bics	r1, r4
    6bec:	7001      	strb	r1, [r0, #0]
    else if (code == KC_MS_ACCEL2) mousekey_accel &= ~(1<<2);

    if (mouse_report.x == 0 && mouse_report.y == 0 && mouse_report.v == 0 && mouse_report.h == 0)
    6bee:	2a00      	cmp	r2, #0
    6bf0:	d017      	beq.n	6c22 <mousekey_off+0x82>
        mousekey_repeat = 0;
}
    6bf2:	bd10      	pop	{r4, pc}
    else if (code == KC_MS_DOWN     && mouse_report.y > 0) mouse_report.y = 0;
    6bf4:	2102      	movs	r1, #2
    6bf6:	5659      	ldrsb	r1, [r3, r1]
    6bf8:	2900      	cmp	r1, #0
    6bfa:	ddf8      	ble.n	6bee <mousekey_off+0x4e>
    if      (code == KC_MS_UP       && mouse_report.y < 0) mouse_report.y = 0;
    6bfc:	2100      	movs	r1, #0
    6bfe:	7099      	strb	r1, [r3, #2]
    if (mouse_report.x == 0 && mouse_report.y == 0 && mouse_report.v == 0 && mouse_report.h == 0)
    6c00:	2a00      	cmp	r2, #0
    6c02:	d1f6      	bne.n	6bf2 <mousekey_off+0x52>
    6c04:	2203      	movs	r2, #3
    6c06:	569a      	ldrsb	r2, [r3, r2]
    6c08:	2a00      	cmp	r2, #0
    6c0a:	d1f2      	bne.n	6bf2 <mousekey_off+0x52>
    6c0c:	791b      	ldrb	r3, [r3, #4]
    6c0e:	b25b      	sxtb	r3, r3
    6c10:	2b00      	cmp	r3, #0
    6c12:	d1ee      	bne.n	6bf2 <mousekey_off+0x52>
        mousekey_repeat = 0;
    6c14:	4a29      	ldr	r2, [pc, #164]	; (6cbc <mousekey_off+0x11c>)
    6c16:	7013      	strb	r3, [r2, #0]
}
    6c18:	e7eb      	b.n	6bf2 <mousekey_off+0x52>
    else if (code == KC_MS_RIGHT    && mouse_report.x > 0) mouse_report.x = 0;
    6c1a:	2a00      	cmp	r2, #0
    6c1c:	dde7      	ble.n	6bee <mousekey_off+0x4e>
    else if (code == KC_MS_LEFT     && mouse_report.x < 0) mouse_report.x = 0;
    6c1e:	2200      	movs	r2, #0
    6c20:	705a      	strb	r2, [r3, #1]
    if (mouse_report.x == 0 && mouse_report.y == 0 && mouse_report.v == 0 && mouse_report.h == 0)
    6c22:	2202      	movs	r2, #2
    6c24:	569a      	ldrsb	r2, [r3, r2]
    6c26:	2a00      	cmp	r2, #0
    6c28:	d1e3      	bne.n	6bf2 <mousekey_off+0x52>
    6c2a:	e7eb      	b.n	6c04 <mousekey_off+0x64>
    if      (code == KC_MS_UP       && mouse_report.y < 0) mouse_report.y = 0;
    6c2c:	7899      	ldrb	r1, [r3, #2]
    6c2e:	297f      	cmp	r1, #127	; 0x7f
    6c30:	d8e4      	bhi.n	6bfc <mousekey_off+0x5c>
    if (mouse_report.x == 0 && mouse_report.y == 0 && mouse_report.v == 0 && mouse_report.h == 0)
    6c32:	2a00      	cmp	r2, #0
    6c34:	d1dd      	bne.n	6bf2 <mousekey_off+0x52>
    6c36:	e7f4      	b.n	6c22 <mousekey_off+0x82>
    else if (code == KC_MS_LEFT     && mouse_report.x < 0) mouse_report.x = 0;
    6c38:	2a00      	cmp	r2, #0
    6c3a:	dbf0      	blt.n	6c1e <mousekey_off+0x7e>
    if (mouse_report.x == 0 && mouse_report.y == 0 && mouse_report.v == 0 && mouse_report.h == 0)
    6c3c:	d1d9      	bne.n	6bf2 <mousekey_off+0x52>
    6c3e:	e7f0      	b.n	6c22 <mousekey_off+0x82>
    else if (code == KC_MS_WH_UP    && mouse_report.v > 0) mouse_report.v = 0;
    6c40:	2103      	movs	r1, #3
    6c42:	5659      	ldrsb	r1, [r3, r1]
    6c44:	2900      	cmp	r1, #0
    6c46:	ddd2      	ble.n	6bee <mousekey_off+0x4e>
    6c48:	2100      	movs	r1, #0
    6c4a:	70d9      	strb	r1, [r3, #3]
    if (mouse_report.x == 0 && mouse_report.y == 0 && mouse_report.v == 0 && mouse_report.h == 0)
    6c4c:	2a00      	cmp	r2, #0
    6c4e:	d1d0      	bne.n	6bf2 <mousekey_off+0x52>
    6c50:	e7e7      	b.n	6c22 <mousekey_off+0x82>
    else if (code == KC_MS_BTN2) mouse_report.buttons &= ~MOUSE_BTN2;
    6c52:	7819      	ldrb	r1, [r3, #0]
    6c54:	38f3      	subs	r0, #243	; 0xf3
    6c56:	4381      	bics	r1, r0
    6c58:	7019      	strb	r1, [r3, #0]
    6c5a:	e7c8      	b.n	6bee <mousekey_off+0x4e>
    else if (code == KC_MS_WH_DOWN  && mouse_report.v < 0) mouse_report.v = 0;
    6c5c:	78d9      	ldrb	r1, [r3, #3]
    6c5e:	297f      	cmp	r1, #127	; 0x7f
    6c60:	d9c5      	bls.n	6bee <mousekey_off+0x4e>
    6c62:	e7f1      	b.n	6c48 <mousekey_off+0xa8>
    else if (code == KC_MS_WH_LEFT  && mouse_report.h < 0) mouse_report.h = 0;
    6c64:	7919      	ldrb	r1, [r3, #4]
    6c66:	297f      	cmp	r1, #127	; 0x7f
    6c68:	d9c1      	bls.n	6bee <mousekey_off+0x4e>
    6c6a:	2100      	movs	r1, #0
    6c6c:	7119      	strb	r1, [r3, #4]
    6c6e:	e7be      	b.n	6bee <mousekey_off+0x4e>
    else if (code == KC_MS_WH_RIGHT && mouse_report.h > 0) mouse_report.h = 0;
    6c70:	2104      	movs	r1, #4
    6c72:	5659      	ldrsb	r1, [r3, r1]
    6c74:	2900      	cmp	r1, #0
    6c76:	dcf8      	bgt.n	6c6a <mousekey_off+0xca>
    6c78:	e7b9      	b.n	6bee <mousekey_off+0x4e>
    else if (code == KC_MS_BTN3) mouse_report.buttons &= ~MOUSE_BTN3;
    6c7a:	7819      	ldrb	r1, [r3, #0]
    6c7c:	38f2      	subs	r0, #242	; 0xf2
    6c7e:	4381      	bics	r1, r0
    6c80:	7019      	strb	r1, [r3, #0]
    6c82:	e7b4      	b.n	6bee <mousekey_off+0x4e>
    else if (code == KC_MS_BTN4) mouse_report.buttons &= ~MOUSE_BTN4;
    6c84:	7819      	ldrb	r1, [r3, #0]
    6c86:	38ef      	subs	r0, #239	; 0xef
    6c88:	4381      	bics	r1, r0
    6c8a:	7019      	strb	r1, [r3, #0]
    6c8c:	e7af      	b.n	6bee <mousekey_off+0x4e>
    else if (code == KC_MS_BTN5) mouse_report.buttons &= ~MOUSE_BTN5;
    6c8e:	7819      	ldrb	r1, [r3, #0]
    6c90:	38e8      	subs	r0, #232	; 0xe8
    6c92:	4381      	bics	r1, r0
    6c94:	7019      	strb	r1, [r3, #0]
    6c96:	e7aa      	b.n	6bee <mousekey_off+0x4e>
    else if (code == KC_MS_ACCEL0) mousekey_accel &= ~(1<<0);
    6c98:	2401      	movs	r4, #1
    6c9a:	4807      	ldr	r0, [pc, #28]	; (6cb8 <mousekey_off+0x118>)
    6c9c:	7801      	ldrb	r1, [r0, #0]
    6c9e:	43a1      	bics	r1, r4
    6ca0:	7001      	strb	r1, [r0, #0]
    6ca2:	e7a4      	b.n	6bee <mousekey_off+0x4e>
    else if (code == KC_MS_ACCEL2) mousekey_accel &= ~(1<<2);
    6ca4:	28ff      	cmp	r0, #255	; 0xff
    6ca6:	d1a2      	bne.n	6bee <mousekey_off+0x4e>
    6ca8:	2404      	movs	r4, #4
    6caa:	4803      	ldr	r0, [pc, #12]	; (6cb8 <mousekey_off+0x118>)
    6cac:	7801      	ldrb	r1, [r0, #0]
    6cae:	43a1      	bics	r1, r4
    6cb0:	7001      	strb	r1, [r0, #0]
    6cb2:	e79c      	b.n	6bee <mousekey_off+0x4e>
    6cb4:	20000cd0 	.word	0x20000cd0
    6cb8:	20000cd5 	.word	0x20000cd5
    6cbc:	20000cd6 	.word	0x20000cd6

00006cc0 <mousekey_send>:
    mousekey_accel = 0;
}

static void mousekey_debug(void)
{
    if (!debug_mouse) return;
    6cc0:	4b26      	ldr	r3, [pc, #152]	; (6d5c <mousekey_send+0x9c>)
{
    6cc2:	b570      	push	{r4, r5, r6, lr}
    if (!debug_mouse) return;
    6cc4:	781b      	ldrb	r3, [r3, #0]
    6cc6:	071b      	lsls	r3, r3, #28
    6cc8:	d408      	bmi.n	6cdc <mousekey_send+0x1c>
    6cca:	4c25      	ldr	r4, [pc, #148]	; (6d60 <mousekey_send+0xa0>)
    host_mouse_send(&mouse_report);
    6ccc:	0020      	movs	r0, r4
    6cce:	f7fd fbb7 	bl	4440 <host_mouse_send>
    last_timer = timer_read();
    6cd2:	f7ff fa7d 	bl	61d0 <timer_read>
    6cd6:	4b23      	ldr	r3, [pc, #140]	; (6d64 <mousekey_send+0xa4>)
    6cd8:	8018      	strh	r0, [r3, #0]
}
    6cda:	bd70      	pop	{r4, r5, r6, pc}
    print("mousekey [btn|x y v h](rep/acl): [");
    6cdc:	4822      	ldr	r0, [pc, #136]	; (6d68 <mousekey_send+0xa8>)
    6cde:	f7ff fa57 	bl	6190 <tfp_printf>
    phex(mouse_report.buttons); print("|");
    6ce2:	4c1f      	ldr	r4, [pc, #124]	; (6d60 <mousekey_send+0xa0>)
    6ce4:	4821      	ldr	r0, [pc, #132]	; (6d6c <mousekey_send+0xac>)
    6ce6:	7821      	ldrb	r1, [r4, #0]
    6ce8:	f7ff fa52 	bl	6190 <tfp_printf>
    6cec:	4820      	ldr	r0, [pc, #128]	; (6d70 <mousekey_send+0xb0>)
    6cee:	f7ff fa4f 	bl	6190 <tfp_printf>
    print_decs(mouse_report.x); print(" ");
    6cf2:	2101      	movs	r1, #1
    6cf4:	4d1f      	ldr	r5, [pc, #124]	; (6d74 <mousekey_send+0xb4>)
    6cf6:	5661      	ldrsb	r1, [r4, r1]
    6cf8:	0028      	movs	r0, r5
    6cfa:	f7ff fa49 	bl	6190 <tfp_printf>
    6cfe:	4e1e      	ldr	r6, [pc, #120]	; (6d78 <mousekey_send+0xb8>)
    6d00:	0030      	movs	r0, r6
    6d02:	f7ff fa45 	bl	6190 <tfp_printf>
    print_decs(mouse_report.y); print(" ");
    6d06:	2102      	movs	r1, #2
    6d08:	0028      	movs	r0, r5
    6d0a:	5661      	ldrsb	r1, [r4, r1]
    6d0c:	f7ff fa40 	bl	6190 <tfp_printf>
    6d10:	0030      	movs	r0, r6
    6d12:	f7ff fa3d 	bl	6190 <tfp_printf>
    print_decs(mouse_report.v); print(" ");
    6d16:	2103      	movs	r1, #3
    6d18:	0028      	movs	r0, r5
    6d1a:	5661      	ldrsb	r1, [r4, r1]
    6d1c:	f7ff fa38 	bl	6190 <tfp_printf>
    6d20:	0030      	movs	r0, r6
    6d22:	f7ff fa35 	bl	6190 <tfp_printf>
    print_decs(mouse_report.h); print("](");
    6d26:	2104      	movs	r1, #4
    6d28:	0028      	movs	r0, r5
    6d2a:	5661      	ldrsb	r1, [r4, r1]
    6d2c:	f7ff fa30 	bl	6190 <tfp_printf>
    6d30:	4812      	ldr	r0, [pc, #72]	; (6d7c <mousekey_send+0xbc>)
    6d32:	f7ff fa2d 	bl	6190 <tfp_printf>
    print_dec(mousekey_repeat); print("/");
    6d36:	4b12      	ldr	r3, [pc, #72]	; (6d80 <mousekey_send+0xc0>)
    6d38:	4d12      	ldr	r5, [pc, #72]	; (6d84 <mousekey_send+0xc4>)
    6d3a:	7819      	ldrb	r1, [r3, #0]
    6d3c:	0028      	movs	r0, r5
    6d3e:	f7ff fa27 	bl	6190 <tfp_printf>
    6d42:	4811      	ldr	r0, [pc, #68]	; (6d88 <mousekey_send+0xc8>)
    6d44:	f7ff fa24 	bl	6190 <tfp_printf>
    print_dec(mousekey_accel); print(")\n");
    6d48:	4b10      	ldr	r3, [pc, #64]	; (6d8c <mousekey_send+0xcc>)
    6d4a:	0028      	movs	r0, r5
    6d4c:	7819      	ldrb	r1, [r3, #0]
    6d4e:	f7ff fa1f 	bl	6190 <tfp_printf>
    6d52:	480f      	ldr	r0, [pc, #60]	; (6d90 <mousekey_send+0xd0>)
    6d54:	f7ff fa1c 	bl	6190 <tfp_printf>
    6d58:	e7b8      	b.n	6ccc <mousekey_send+0xc>
    6d5a:	46c0      	nop			; (mov r8, r8)
    6d5c:	20000cb8 	.word	0x20000cb8
    6d60:	20000cd0 	.word	0x20000cd0
    6d64:	20000ccc 	.word	0x20000ccc
    6d68:	00008958 	.word	0x00008958
    6d6c:	00008794 	.word	0x00008794
    6d70:	0000897c 	.word	0x0000897c
    6d74:	00008980 	.word	0x00008980
    6d78:	00008790 	.word	0x00008790
    6d7c:	00008984 	.word	0x00008984
    6d80:	20000cd6 	.word	0x20000cd6
    6d84:	00008988 	.word	0x00008988
    6d88:	0000898c 	.word	0x0000898c
    6d8c:	20000cd5 	.word	0x20000cd5
    6d90:	00009294 	.word	0x00009294
	...

00006da0 <mousekey_task>:
{
    6da0:	b5f0      	push	{r4, r5, r6, r7, lr}
    6da2:	46c6      	mov	lr, r8
    if (timer_elapsed(last_timer) < (mousekey_repeat ? mk_interval : mk_delay*10))
    6da4:	4b3f      	ldr	r3, [pc, #252]	; (6ea4 <mousekey_task+0x104>)
{
    6da6:	b500      	push	{lr}
    if (timer_elapsed(last_timer) < (mousekey_repeat ? mk_interval : mk_delay*10))
    6da8:	8818      	ldrh	r0, [r3, #0]
    6daa:	f7ff fa61 	bl	6270 <timer_elapsed>
    6dae:	493e      	ldr	r1, [pc, #248]	; (6ea8 <mousekey_task+0x108>)
    6db0:	780a      	ldrb	r2, [r1, #0]
    6db2:	2a00      	cmp	r2, #0
    6db4:	d058      	beq.n	6e68 <mousekey_task+0xc8>
    6db6:	4b3d      	ldr	r3, [pc, #244]	; (6eac <mousekey_task+0x10c>)
    6db8:	781b      	ldrb	r3, [r3, #0]
    6dba:	4298      	cmp	r0, r3
    6dbc:	db51      	blt.n	6e62 <mousekey_task+0xc2>
    if (mouse_report.x == 0 && mouse_report.y == 0 && mouse_report.v == 0 && mouse_report.h == 0)
    6dbe:	2501      	movs	r5, #1
    6dc0:	2304      	movs	r3, #4
    6dc2:	2602      	movs	r6, #2
    6dc4:	2703      	movs	r7, #3
    6dc6:	4c3a      	ldr	r4, [pc, #232]	; (6eb0 <mousekey_task+0x110>)
    6dc8:	56e3      	ldrsb	r3, [r4, r3]
    6dca:	5765      	ldrsb	r5, [r4, r5]
    6dcc:	57a6      	ldrsb	r6, [r4, r6]
    6dce:	57e7      	ldrsb	r7, [r4, r7]
    6dd0:	4698      	mov	r8, r3
    6dd2:	2d00      	cmp	r5, #0
    6dd4:	d14e      	bne.n	6e74 <mousekey_task+0xd4>
    6dd6:	2e00      	cmp	r6, #0
    6dd8:	d103      	bne.n	6de2 <mousekey_task+0x42>
    6dda:	2f00      	cmp	r7, #0
    6ddc:	d101      	bne.n	6de2 <mousekey_task+0x42>
    6dde:	2b00      	cmp	r3, #0
    6de0:	d03f      	beq.n	6e62 <mousekey_task+0xc2>
    if (mousekey_repeat != UINT8_MAX)
    6de2:	2aff      	cmp	r2, #255	; 0xff
    6de4:	d00e      	beq.n	6e04 <mousekey_task+0x64>
        mousekey_repeat++;
    6de6:	3201      	adds	r2, #1
    6de8:	700a      	strb	r2, [r1, #0]
    if (mouse_report.x > 0) mouse_report.x = move_unit();
    6dea:	2d00      	cmp	r5, #0
    6dec:	dd03      	ble.n	6df6 <mousekey_task+0x56>
    6dee:	f7ff fdd7 	bl	69a0 <move_unit>
    6df2:	b245      	sxtb	r5, r0
    6df4:	7065      	strb	r5, [r4, #1]
    if (mouse_report.x < 0) mouse_report.x = move_unit() * -1;
    6df6:	2d00      	cmp	r5, #0
    6df8:	da04      	bge.n	6e04 <mousekey_task+0x64>
    6dfa:	f7ff fdd1 	bl	69a0 <move_unit>
    6dfe:	4245      	negs	r5, r0
    6e00:	b26d      	sxtb	r5, r5
    6e02:	7065      	strb	r5, [r4, #1]
    if (mouse_report.y > 0) mouse_report.y = move_unit();
    6e04:	2e00      	cmp	r6, #0
    6e06:	dd03      	ble.n	6e10 <mousekey_task+0x70>
    6e08:	f7ff fdca 	bl	69a0 <move_unit>
    6e0c:	b246      	sxtb	r6, r0
    6e0e:	70a6      	strb	r6, [r4, #2]
    if (mouse_report.y < 0) mouse_report.y = move_unit() * -1;
    6e10:	2e00      	cmp	r6, #0
    6e12:	da03      	bge.n	6e1c <mousekey_task+0x7c>
    6e14:	f7ff fdc4 	bl	69a0 <move_unit>
    6e18:	4240      	negs	r0, r0
    6e1a:	70a0      	strb	r0, [r4, #2]
    if (mouse_report.x && mouse_report.y) {
    6e1c:	2d00      	cmp	r5, #0
    6e1e:	d003      	beq.n	6e28 <mousekey_task+0x88>
    6e20:	2602      	movs	r6, #2
    6e22:	57a6      	ldrsb	r6, [r4, r6]
    6e24:	2e00      	cmp	r6, #0
    6e26:	d128      	bne.n	6e7a <mousekey_task+0xda>
    if (mouse_report.v > 0) mouse_report.v = wheel_unit();
    6e28:	2f00      	cmp	r7, #0
    6e2a:	dd03      	ble.n	6e34 <mousekey_task+0x94>
    6e2c:	f7ff fdf8 	bl	6a20 <wheel_unit>
    6e30:	b247      	sxtb	r7, r0
    6e32:	70e7      	strb	r7, [r4, #3]
    if (mouse_report.v < 0) mouse_report.v = wheel_unit() * -1;
    6e34:	2f00      	cmp	r7, #0
    6e36:	da03      	bge.n	6e40 <mousekey_task+0xa0>
    6e38:	f7ff fdf2 	bl	6a20 <wheel_unit>
    6e3c:	4240      	negs	r0, r0
    6e3e:	70e0      	strb	r0, [r4, #3]
    if (mouse_report.h > 0) mouse_report.h = wheel_unit();
    6e40:	4643      	mov	r3, r8
    6e42:	2b00      	cmp	r3, #0
    6e44:	dd04      	ble.n	6e50 <mousekey_task+0xb0>
    6e46:	f7ff fdeb 	bl	6a20 <wheel_unit>
    6e4a:	b243      	sxtb	r3, r0
    6e4c:	4698      	mov	r8, r3
    6e4e:	7123      	strb	r3, [r4, #4]
    if (mouse_report.h < 0) mouse_report.h = wheel_unit() * -1;
    6e50:	4643      	mov	r3, r8
    6e52:	2b00      	cmp	r3, #0
    6e54:	da03      	bge.n	6e5e <mousekey_task+0xbe>
    6e56:	f7ff fde3 	bl	6a20 <wheel_unit>
    6e5a:	4240      	negs	r0, r0
    6e5c:	7120      	strb	r0, [r4, #4]
    mousekey_send();
    6e5e:	f7ff ff2f 	bl	6cc0 <mousekey_send>
}
    6e62:	bc04      	pop	{r2}
    6e64:	4690      	mov	r8, r2
    6e66:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (timer_elapsed(last_timer) < (mousekey_repeat ? mk_interval : mk_delay*10))
    6e68:	4b12      	ldr	r3, [pc, #72]	; (6eb4 <mousekey_task+0x114>)
    6e6a:	781c      	ldrb	r4, [r3, #0]
    6e6c:	00a3      	lsls	r3, r4, #2
    6e6e:	191b      	adds	r3, r3, r4
    6e70:	005b      	lsls	r3, r3, #1
    6e72:	e7a2      	b.n	6dba <mousekey_task+0x1a>
    if (mousekey_repeat != UINT8_MAX)
    6e74:	2aff      	cmp	r2, #255	; 0xff
    6e76:	d1b6      	bne.n	6de6 <mousekey_task+0x46>
    6e78:	e7b7      	b.n	6dea <mousekey_task+0x4a>
        mouse_report.x *= 0.7;
    6e7a:	0028      	movs	r0, r5
    6e7c:	f7f9 ff74 	bl	d68 <__aeabi_i2d>
    6e80:	4a0d      	ldr	r2, [pc, #52]	; (6eb8 <mousekey_task+0x118>)
    6e82:	4b0e      	ldr	r3, [pc, #56]	; (6ebc <mousekey_task+0x11c>)
    6e84:	f7f9 fcc8 	bl	818 <__aeabi_dmul>
    6e88:	f7f9 ff38 	bl	cfc <__aeabi_d2iz>
    6e8c:	7060      	strb	r0, [r4, #1]
        mouse_report.y *= 0.7;
    6e8e:	0030      	movs	r0, r6
    6e90:	f7f9 ff6a 	bl	d68 <__aeabi_i2d>
    6e94:	4a08      	ldr	r2, [pc, #32]	; (6eb8 <mousekey_task+0x118>)
    6e96:	4b09      	ldr	r3, [pc, #36]	; (6ebc <mousekey_task+0x11c>)
    6e98:	f7f9 fcbe 	bl	818 <__aeabi_dmul>
    6e9c:	f7f9 ff2e 	bl	cfc <__aeabi_d2iz>
    6ea0:	70a0      	strb	r0, [r4, #2]
    6ea2:	e7c1      	b.n	6e28 <mousekey_task+0x88>
    6ea4:	20000ccc 	.word	0x20000ccc
    6ea8:	20000cd6 	.word	0x20000cd6
    6eac:	1ffffe39 	.word	0x1ffffe39
    6eb0:	20000cd0 	.word	0x20000cd0
    6eb4:	1ffffe38 	.word	0x1ffffe38
    6eb8:	66666666 	.word	0x66666666
    6ebc:	3fe66666 	.word	0x3fe66666

00006ec0 <mousekey_clear>:
{
    6ec0:	b510      	push	{r4, lr}
    mouse_report = (report_mouse_t){};
    6ec2:	2205      	movs	r2, #5
    6ec4:	2100      	movs	r1, #0
    6ec6:	4804      	ldr	r0, [pc, #16]	; (6ed8 <mousekey_clear+0x18>)
    6ec8:	f000 fd4e 	bl	7968 <memset>
    mousekey_repeat = 0;
    6ecc:	2300      	movs	r3, #0
    6ece:	4a03      	ldr	r2, [pc, #12]	; (6edc <mousekey_clear+0x1c>)
    6ed0:	7013      	strb	r3, [r2, #0]
    mousekey_accel = 0;
    6ed2:	4a03      	ldr	r2, [pc, #12]	; (6ee0 <mousekey_clear+0x20>)
    6ed4:	7013      	strb	r3, [r2, #0]
}
    6ed6:	bd10      	pop	{r4, pc}
    6ed8:	20000cd0 	.word	0x20000cd0
    6edc:	20000cd6 	.word	0x20000cd6
    6ee0:	20000cd5 	.word	0x20000cd5
	...

00006ef0 <mousekey_console_help>:
            break;
    }
}

static void mousekey_console_help(void)
{
    6ef0:	b510      	push	{r4, lr}
    print("\n\t- Mousekey -\n"
    6ef2:	4804      	ldr	r0, [pc, #16]	; (6f04 <mousekey_console_help+0x14>)
    6ef4:	f7ff f94c 	bl	6190 <tfp_printf>
          "down:	-1\n"
          "pgup:	+10\n"
          "pgdown:	-10\n"
          "\n"
          "speed = delta * max_speed * (repeat / time_to_max)\n");
    xprintf("where delta: cursor=%d, wheel=%d\n" 
    6ef8:	2201      	movs	r2, #1
    6efa:	2105      	movs	r1, #5
    6efc:	4802      	ldr	r0, [pc, #8]	; (6f08 <mousekey_console_help+0x18>)
    6efe:	f7ff f947 	bl	6190 <tfp_printf>
            "See http://en.wikipedia.org/wiki/Mouse_keys\n", MOUSEKEY_MOVE_DELTA,  MOUSEKEY_WHEEL_DELTA);
}
    6f02:	bd10      	pop	{r4, pc}
    6f04:	0000919c 	.word	0x0000919c
    6f08:	00009298 	.word	0x00009298
    6f0c:	00000000 	.word	0x00000000

00006f10 <mousekey_param_inc>:
{
    6f10:	b510      	push	{r4, lr}
    switch (param) {
    6f12:	2806      	cmp	r0, #6
    6f14:	d80d      	bhi.n	6f32 <mousekey_param_inc+0x22>
    6f16:	4b2f      	ldr	r3, [pc, #188]	; (6fd4 <mousekey_param_inc+0xc4>)
    6f18:	0080      	lsls	r0, r0, #2
    6f1a:	581b      	ldr	r3, [r3, r0]
    6f1c:	469f      	mov	pc, r3
            if (mk_wheel_time_to_max + inc < UINT8_MAX)
    6f1e:	4a2e      	ldr	r2, [pc, #184]	; (6fd8 <mousekey_param_inc+0xc8>)
    6f20:	7813      	ldrb	r3, [r2, #0]
    6f22:	1859      	adds	r1, r3, r1
    6f24:	29fe      	cmp	r1, #254	; 0xfe
    6f26:	dc3c      	bgt.n	6fa2 <mousekey_param_inc+0x92>
                mk_wheel_time_to_max += inc;
    6f28:	b2c9      	uxtb	r1, r1
    6f2a:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_wheel_time_to_max);
    6f2c:	482b      	ldr	r0, [pc, #172]	; (6fdc <mousekey_param_inc+0xcc>)
    6f2e:	f7ff f92f 	bl	6190 <tfp_printf>
}
    6f32:	bd10      	pop	{r4, pc}
            if (mk_delay + inc < UINT8_MAX)
    6f34:	4a2a      	ldr	r2, [pc, #168]	; (6fe0 <mousekey_param_inc+0xd0>)
    6f36:	7813      	ldrb	r3, [r2, #0]
    6f38:	1859      	adds	r1, r3, r1
    6f3a:	29fe      	cmp	r1, #254	; 0xfe
    6f3c:	dc39      	bgt.n	6fb2 <mousekey_param_inc+0xa2>
                mk_delay += inc;
    6f3e:	b2c9      	uxtb	r1, r1
    6f40:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_delay);
    6f42:	4828      	ldr	r0, [pc, #160]	; (6fe4 <mousekey_param_inc+0xd4>)
    6f44:	f7ff f924 	bl	6190 <tfp_printf>
            break;
    6f48:	e7f3      	b.n	6f32 <mousekey_param_inc+0x22>
            if (mk_interval + inc < UINT8_MAX)
    6f4a:	4a27      	ldr	r2, [pc, #156]	; (6fe8 <mousekey_param_inc+0xd8>)
    6f4c:	7813      	ldrb	r3, [r2, #0]
    6f4e:	1859      	adds	r1, r3, r1
    6f50:	29fe      	cmp	r1, #254	; 0xfe
    6f52:	dc36      	bgt.n	6fc2 <mousekey_param_inc+0xb2>
                mk_interval += inc;
    6f54:	b2c9      	uxtb	r1, r1
    6f56:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_interval);
    6f58:	4824      	ldr	r0, [pc, #144]	; (6fec <mousekey_param_inc+0xdc>)
    6f5a:	f7ff f919 	bl	6190 <tfp_printf>
            break;
    6f5e:	e7e8      	b.n	6f32 <mousekey_param_inc+0x22>
            if (mk_time_to_max + inc < UINT8_MAX)
    6f60:	4a23      	ldr	r2, [pc, #140]	; (6ff0 <mousekey_param_inc+0xe0>)
    6f62:	7813      	ldrb	r3, [r2, #0]
    6f64:	1859      	adds	r1, r3, r1
    6f66:	29fe      	cmp	r1, #254	; 0xfe
    6f68:	dc27      	bgt.n	6fba <mousekey_param_inc+0xaa>
                mk_time_to_max += inc;
    6f6a:	b2c9      	uxtb	r1, r1
    6f6c:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_time_to_max);
    6f6e:	4821      	ldr	r0, [pc, #132]	; (6ff4 <mousekey_param_inc+0xe4>)
    6f70:	f7ff f90e 	bl	6190 <tfp_printf>
            break;
    6f74:	e7dd      	b.n	6f32 <mousekey_param_inc+0x22>
            if (mk_max_speed + inc < UINT8_MAX)
    6f76:	4a20      	ldr	r2, [pc, #128]	; (6ff8 <mousekey_param_inc+0xe8>)
    6f78:	7813      	ldrb	r3, [r2, #0]
    6f7a:	1859      	adds	r1, r3, r1
    6f7c:	29fe      	cmp	r1, #254	; 0xfe
    6f7e:	dc24      	bgt.n	6fca <mousekey_param_inc+0xba>
                mk_max_speed += inc;
    6f80:	b2c9      	uxtb	r1, r1
    6f82:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_max_speed);
    6f84:	481d      	ldr	r0, [pc, #116]	; (6ffc <mousekey_param_inc+0xec>)
    6f86:	f7ff f903 	bl	6190 <tfp_printf>
            break;
    6f8a:	e7d2      	b.n	6f32 <mousekey_param_inc+0x22>
            if (mk_wheel_max_speed + inc < UINT8_MAX)
    6f8c:	4a1c      	ldr	r2, [pc, #112]	; (7000 <mousekey_param_inc+0xf0>)
    6f8e:	7813      	ldrb	r3, [r2, #0]
    6f90:	1859      	adds	r1, r3, r1
    6f92:	29fe      	cmp	r1, #254	; 0xfe
    6f94:	dc09      	bgt.n	6faa <mousekey_param_inc+0x9a>
                mk_wheel_max_speed += inc;
    6f96:	b2c9      	uxtb	r1, r1
    6f98:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_wheel_max_speed);
    6f9a:	481a      	ldr	r0, [pc, #104]	; (7004 <mousekey_param_inc+0xf4>)
    6f9c:	f7ff f8f8 	bl	6190 <tfp_printf>
            break;
    6fa0:	e7c7      	b.n	6f32 <mousekey_param_inc+0x22>
                mk_wheel_time_to_max = UINT8_MAX;
    6fa2:	23ff      	movs	r3, #255	; 0xff
    6fa4:	21ff      	movs	r1, #255	; 0xff
    6fa6:	7013      	strb	r3, [r2, #0]
    6fa8:	e7c0      	b.n	6f2c <mousekey_param_inc+0x1c>
                mk_wheel_max_speed = UINT8_MAX;
    6faa:	23ff      	movs	r3, #255	; 0xff
    6fac:	21ff      	movs	r1, #255	; 0xff
    6fae:	7013      	strb	r3, [r2, #0]
    6fb0:	e7f3      	b.n	6f9a <mousekey_param_inc+0x8a>
                mk_delay = UINT8_MAX;
    6fb2:	23ff      	movs	r3, #255	; 0xff
    6fb4:	21ff      	movs	r1, #255	; 0xff
    6fb6:	7013      	strb	r3, [r2, #0]
    6fb8:	e7c3      	b.n	6f42 <mousekey_param_inc+0x32>
                mk_time_to_max = UINT8_MAX;
    6fba:	23ff      	movs	r3, #255	; 0xff
    6fbc:	21ff      	movs	r1, #255	; 0xff
    6fbe:	7013      	strb	r3, [r2, #0]
    6fc0:	e7d5      	b.n	6f6e <mousekey_param_inc+0x5e>
                mk_interval = UINT8_MAX;
    6fc2:	23ff      	movs	r3, #255	; 0xff
    6fc4:	21ff      	movs	r1, #255	; 0xff
    6fc6:	7013      	strb	r3, [r2, #0]
    6fc8:	e7c6      	b.n	6f58 <mousekey_param_inc+0x48>
                mk_max_speed = UINT8_MAX;
    6fca:	23ff      	movs	r3, #255	; 0xff
    6fcc:	21ff      	movs	r1, #255	; 0xff
    6fce:	7013      	strb	r3, [r2, #0]
    6fd0:	e7d8      	b.n	6f84 <mousekey_param_inc+0x74>
    6fd2:	46c0      	nop			; (mov r8, r8)
    6fd4:	00008990 	.word	0x00008990
    6fd8:	1ffffe3d 	.word	0x1ffffe3d
    6fdc:	00009354 	.word	0x00009354
    6fe0:	1ffffe38 	.word	0x1ffffe38
    6fe4:	000092e8 	.word	0x000092e8
    6fe8:	1ffffe39 	.word	0x1ffffe39
    6fec:	000092f8 	.word	0x000092f8
    6ff0:	1ffffe3b 	.word	0x1ffffe3b
    6ff4:	00009320 	.word	0x00009320
    6ff8:	1ffffe3a 	.word	0x1ffffe3a
    6ffc:	0000930c 	.word	0x0000930c
    7000:	1ffffe3c 	.word	0x1ffffe3c
    7004:	00009338 	.word	0x00009338
	...

00007010 <mousekey_param_dec>:
{
    7010:	b510      	push	{r4, lr}
    switch (param) {
    7012:	2806      	cmp	r0, #6
    7014:	d80d      	bhi.n	7032 <mousekey_param_dec+0x22>
    7016:	4b2f      	ldr	r3, [pc, #188]	; (70d4 <mousekey_param_dec+0xc4>)
    7018:	0080      	lsls	r0, r0, #2
    701a:	581b      	ldr	r3, [r3, r0]
    701c:	469f      	mov	pc, r3
            if (mk_wheel_time_to_max > dec)
    701e:	4a2e      	ldr	r2, [pc, #184]	; (70d8 <mousekey_param_dec+0xc8>)
    7020:	7813      	ldrb	r3, [r2, #0]
    7022:	428b      	cmp	r3, r1
    7024:	d93d      	bls.n	70a2 <mousekey_param_dec+0x92>
                mk_wheel_time_to_max -= dec;
    7026:	1a59      	subs	r1, r3, r1
    7028:	b2c9      	uxtb	r1, r1
    702a:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_wheel_time_to_max);
    702c:	482b      	ldr	r0, [pc, #172]	; (70dc <mousekey_param_dec+0xcc>)
    702e:	f7ff f8af 	bl	6190 <tfp_printf>
}
    7032:	bd10      	pop	{r4, pc}
            if (mk_delay > dec)
    7034:	4a2a      	ldr	r2, [pc, #168]	; (70e0 <mousekey_param_dec+0xd0>)
    7036:	7813      	ldrb	r3, [r2, #0]
    7038:	428b      	cmp	r3, r1
    703a:	d93a      	bls.n	70b2 <mousekey_param_dec+0xa2>
                mk_delay -= dec;
    703c:	1a59      	subs	r1, r3, r1
    703e:	b2c9      	uxtb	r1, r1
    7040:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_delay);
    7042:	4828      	ldr	r0, [pc, #160]	; (70e4 <mousekey_param_dec+0xd4>)
    7044:	f7ff f8a4 	bl	6190 <tfp_printf>
            break;
    7048:	e7f3      	b.n	7032 <mousekey_param_dec+0x22>
            if (mk_interval > dec)
    704a:	4a27      	ldr	r2, [pc, #156]	; (70e8 <mousekey_param_dec+0xd8>)
    704c:	7813      	ldrb	r3, [r2, #0]
    704e:	428b      	cmp	r3, r1
    7050:	d937      	bls.n	70c2 <mousekey_param_dec+0xb2>
                mk_interval -= dec;
    7052:	1a59      	subs	r1, r3, r1
    7054:	b2c9      	uxtb	r1, r1
    7056:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_interval);
    7058:	4824      	ldr	r0, [pc, #144]	; (70ec <mousekey_param_dec+0xdc>)
    705a:	f7ff f899 	bl	6190 <tfp_printf>
            break;
    705e:	e7e8      	b.n	7032 <mousekey_param_dec+0x22>
            if (mk_time_to_max > dec)
    7060:	4a23      	ldr	r2, [pc, #140]	; (70f0 <mousekey_param_dec+0xe0>)
    7062:	7813      	ldrb	r3, [r2, #0]
    7064:	428b      	cmp	r3, r1
    7066:	d928      	bls.n	70ba <mousekey_param_dec+0xaa>
                mk_time_to_max -= dec;
    7068:	1a59      	subs	r1, r3, r1
    706a:	b2c9      	uxtb	r1, r1
    706c:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_time_to_max);
    706e:	4821      	ldr	r0, [pc, #132]	; (70f4 <mousekey_param_dec+0xe4>)
    7070:	f7ff f88e 	bl	6190 <tfp_printf>
            break;
    7074:	e7dd      	b.n	7032 <mousekey_param_dec+0x22>
            if (mk_max_speed > dec)
    7076:	4a20      	ldr	r2, [pc, #128]	; (70f8 <mousekey_param_dec+0xe8>)
    7078:	7813      	ldrb	r3, [r2, #0]
    707a:	428b      	cmp	r3, r1
    707c:	d925      	bls.n	70ca <mousekey_param_dec+0xba>
                mk_max_speed -= dec;
    707e:	1a59      	subs	r1, r3, r1
    7080:	b2c9      	uxtb	r1, r1
    7082:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_max_speed);
    7084:	481d      	ldr	r0, [pc, #116]	; (70fc <mousekey_param_dec+0xec>)
    7086:	f7ff f883 	bl	6190 <tfp_printf>
            break;
    708a:	e7d2      	b.n	7032 <mousekey_param_dec+0x22>
            if (mk_wheel_max_speed > dec)
    708c:	4a1c      	ldr	r2, [pc, #112]	; (7100 <mousekey_param_dec+0xf0>)
    708e:	7813      	ldrb	r3, [r2, #0]
    7090:	428b      	cmp	r3, r1
    7092:	d90a      	bls.n	70aa <mousekey_param_dec+0x9a>
                mk_wheel_max_speed -= dec;
    7094:	1a59      	subs	r1, r3, r1
    7096:	b2c9      	uxtb	r1, r1
    7098:	7011      	strb	r1, [r2, #0]
            PRINT_SET_VAL(mk_wheel_max_speed);
    709a:	481a      	ldr	r0, [pc, #104]	; (7104 <mousekey_param_dec+0xf4>)
    709c:	f7ff f878 	bl	6190 <tfp_printf>
            break;
    70a0:	e7c7      	b.n	7032 <mousekey_param_dec+0x22>
                mk_wheel_time_to_max = 0;
    70a2:	2300      	movs	r3, #0
    70a4:	2100      	movs	r1, #0
    70a6:	7013      	strb	r3, [r2, #0]
    70a8:	e7c0      	b.n	702c <mousekey_param_dec+0x1c>
                mk_wheel_max_speed = 0;
    70aa:	2300      	movs	r3, #0
    70ac:	2100      	movs	r1, #0
    70ae:	7013      	strb	r3, [r2, #0]
    70b0:	e7f3      	b.n	709a <mousekey_param_dec+0x8a>
                mk_delay = 0;
    70b2:	2300      	movs	r3, #0
    70b4:	2100      	movs	r1, #0
    70b6:	7013      	strb	r3, [r2, #0]
    70b8:	e7c3      	b.n	7042 <mousekey_param_dec+0x32>
                mk_time_to_max = 0;
    70ba:	2300      	movs	r3, #0
    70bc:	2100      	movs	r1, #0
    70be:	7013      	strb	r3, [r2, #0]
    70c0:	e7d5      	b.n	706e <mousekey_param_dec+0x5e>
                mk_interval = 0;
    70c2:	2300      	movs	r3, #0
    70c4:	2100      	movs	r1, #0
    70c6:	7013      	strb	r3, [r2, #0]
    70c8:	e7c6      	b.n	7058 <mousekey_param_dec+0x48>
                mk_max_speed = 0;
    70ca:	2300      	movs	r3, #0
    70cc:	2100      	movs	r1, #0
    70ce:	7013      	strb	r3, [r2, #0]
    70d0:	e7d8      	b.n	7084 <mousekey_param_dec+0x74>
    70d2:	46c0      	nop			; (mov r8, r8)
    70d4:	000089ac 	.word	0x000089ac
    70d8:	1ffffe3d 	.word	0x1ffffe3d
    70dc:	00009354 	.word	0x00009354
    70e0:	1ffffe38 	.word	0x1ffffe38
    70e4:	000092e8 	.word	0x000092e8
    70e8:	1ffffe39 	.word	0x1ffffe39
    70ec:	000092f8 	.word	0x000092f8
    70f0:	1ffffe3b 	.word	0x1ffffe3b
    70f4:	00009320 	.word	0x00009320
    70f8:	1ffffe3a 	.word	0x1ffffe3a
    70fc:	0000930c 	.word	0x0000930c
    7100:	1ffffe3c 	.word	0x1ffffe3c
    7104:	00009338 	.word	0x00009338
	...

00007110 <switch_default_layer>:
    }
    return 0;
}

static void switch_default_layer(uint8_t layer)
{
    7110:	b510      	push	{r4, lr}
    xprintf("L%d\n", layer);
    7112:	0001      	movs	r1, r0
{
    7114:	0004      	movs	r4, r0
    xprintf("L%d\n", layer);
    7116:	4805      	ldr	r0, [pc, #20]	; (712c <switch_default_layer+0x1c>)
    7118:	f7ff f83a 	bl	6190 <tfp_printf>
    default_layer_set(1UL<<layer);
    711c:	2001      	movs	r0, #1
    711e:	40a0      	lsls	r0, r4
    7120:	f7fe fa4e 	bl	55c0 <default_layer_set>
    clear_keyboard();
    7124:	f7fd fdd4 	bl	4cd0 <clear_keyboard>
}
    7128:	bd10      	pop	{r4, pc}
    712a:	46c0      	nop			; (mov r8, r8)
    712c:	00009370 	.word	0x00009370

00007130 <command_common>:
{
    7130:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    switch (code) {
    7132:	1f83      	subs	r3, r0, #6
    7134:	b2db      	uxtb	r3, r3
    7136:	2b42      	cmp	r3, #66	; 0x42
    7138:	d900      	bls.n	713c <command_common+0xc>
    713a:	e17d      	b.n	7438 <command_common+0x308>
    713c:	4ad3      	ldr	r2, [pc, #844]	; (748c <command_common+0x35c>)
    713e:	009b      	lsls	r3, r3, #2
    7140:	58d3      	ldr	r3, [r2, r3]
    7142:	469f      	mov	pc, r3
            clear_keyboard();
    7144:	f7fd fdc4 	bl	4cd0 <clear_keyboard>
            print("\n\nbootloader... ");
    7148:	48d1      	ldr	r0, [pc, #836]	; (7490 <command_common+0x360>)
    714a:	f7ff f821 	bl	6190 <tfp_printf>
            wait_ms(1000);
    714e:	20fa      	movs	r0, #250	; 0xfa
    7150:	0080      	lsls	r0, r0, #2
    7152:	f7fa fb4d 	bl	17f0 <chThdSleep>
    return true;
    7156:	2401      	movs	r4, #1
            bootloader_jump(); // not return
    7158:	f7ff f8b2 	bl	62c0 <bootloader_jump>
}
    715c:	0020      	movs	r0, r4
    715e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            debug_enable   = false;
    7160:	21f1      	movs	r1, #241	; 0xf1
    7162:	2401      	movs	r4, #1
            debug_matrix   = false;
    7164:	4acb      	ldr	r2, [pc, #812]	; (7494 <command_common+0x364>)
    print("\n\t- Console -\n"
    7166:	48cc      	ldr	r0, [pc, #816]	; (7498 <command_common+0x368>)
            debug_matrix   = false;
    7168:	7813      	ldrb	r3, [r2, #0]
            debug_enable   = false;
    716a:	400b      	ands	r3, r1
    716c:	43a3      	bics	r3, r4
    716e:	7013      	strb	r3, [r2, #0]
    print("\n\t- Console -\n"
    7170:	f7ff f80e 	bl	6190 <tfp_printf>
            print("C> ");
    7174:	48c9      	ldr	r0, [pc, #804]	; (749c <command_common+0x36c>)
    7176:	f7ff f80b 	bl	6190 <tfp_printf>
            command_state = CONSOLE;
    717a:	4bc9      	ldr	r3, [pc, #804]	; (74a0 <command_common+0x370>)
    717c:	701c      	strb	r4, [r3, #0]
            break;
    717e:	e7ed      	b.n	715c <command_common+0x2c>
            if (debug_enable) {
    7180:	2501      	movs	r5, #1
    7182:	4cc4      	ldr	r4, [pc, #784]	; (7494 <command_common+0x364>)
    7184:	7823      	ldrb	r3, [r4, #0]
    7186:	421d      	tst	r5, r3
    7188:	d100      	bne.n	718c <command_common+0x5c>
    718a:	e175      	b.n	7478 <command_common+0x348>
                print("\ndebug: off\n");
    718c:	48c5      	ldr	r0, [pc, #788]	; (74a4 <command_common+0x374>)
    718e:	f7fe ffff 	bl	6190 <tfp_printf>
                debug_enable   = false;
    7192:	22f1      	movs	r2, #241	; 0xf1
                debug_matrix   = false;
    7194:	7823      	ldrb	r3, [r4, #0]
                debug_enable   = false;
    7196:	4013      	ands	r3, r2
    7198:	43ab      	bics	r3, r5
    719a:	7023      	strb	r3, [r4, #0]
    return true;
    719c:	2401      	movs	r4, #1
    719e:	e7dd      	b.n	715c <command_common+0x2c>
            print("eeconfig:\n");
    71a0:	48c1      	ldr	r0, [pc, #772]	; (74a8 <command_common+0x378>)
    71a2:	f7fe fff5 	bl	6190 <tfp_printf>
    print("default_layer: "); print_dec(eeconfig_read_default_layer()); print("\n");
    71a6:	48c1      	ldr	r0, [pc, #772]	; (74ac <command_common+0x37c>)
    71a8:	f7fe fff2 	bl	6190 <tfp_printf>
    71ac:	f7ff fbd8 	bl	6960 <eeconfig_read_default_layer>
    71b0:	4dbf      	ldr	r5, [pc, #764]	; (74b0 <command_common+0x380>)
    71b2:	0001      	movs	r1, r0
    71b4:	0028      	movs	r0, r5
    71b6:	f7fe ffeb 	bl	6190 <tfp_printf>
    71ba:	4cbe      	ldr	r4, [pc, #760]	; (74b4 <command_common+0x384>)
    71bc:	0020      	movs	r0, r4
    71be:	f7fe ffe7 	bl	6190 <tfp_printf>
    dc.raw = eeconfig_read_debug();
    71c2:	f7ff fbbd 	bl	6940 <eeconfig_read_debug>
    71c6:	0006      	movs	r6, r0
    print("debug_config.raw: "); print_hex8(dc.raw); print("\n");
    71c8:	48bb      	ldr	r0, [pc, #748]	; (74b8 <command_common+0x388>)
    71ca:	f7fe ffe1 	bl	6190 <tfp_printf>
    71ce:	4fbb      	ldr	r7, [pc, #748]	; (74bc <command_common+0x38c>)
    71d0:	0031      	movs	r1, r6
    71d2:	0038      	movs	r0, r7
    71d4:	f7fe ffdc 	bl	6190 <tfp_printf>
    71d8:	0020      	movs	r0, r4
    71da:	f7fe ffd9 	bl	6190 <tfp_printf>
    print(".enable: "); print_dec(dc.enable); print("\n");
    71de:	48b8      	ldr	r0, [pc, #736]	; (74c0 <command_common+0x390>)
    71e0:	f7fe ffd6 	bl	6190 <tfp_printf>
    71e4:	07f1      	lsls	r1, r6, #31
    71e6:	0fc9      	lsrs	r1, r1, #31
    71e8:	0028      	movs	r0, r5
    71ea:	f7fe ffd1 	bl	6190 <tfp_printf>
    71ee:	0020      	movs	r0, r4
    71f0:	f7fe ffce 	bl	6190 <tfp_printf>
    print(".matrix: "); print_dec(dc.matrix); print("\n");
    71f4:	48b3      	ldr	r0, [pc, #716]	; (74c4 <command_common+0x394>)
    71f6:	f7fe ffcb 	bl	6190 <tfp_printf>
    71fa:	07b1      	lsls	r1, r6, #30
    71fc:	0fc9      	lsrs	r1, r1, #31
    71fe:	0028      	movs	r0, r5
    7200:	f7fe ffc6 	bl	6190 <tfp_printf>
    7204:	0020      	movs	r0, r4
    7206:	f7fe ffc3 	bl	6190 <tfp_printf>
    print(".keyboard: "); print_dec(dc.keyboard); print("\n");
    720a:	48af      	ldr	r0, [pc, #700]	; (74c8 <command_common+0x398>)
    720c:	f7fe ffc0 	bl	6190 <tfp_printf>
    7210:	0771      	lsls	r1, r6, #29
    7212:	0fc9      	lsrs	r1, r1, #31
    7214:	0028      	movs	r0, r5
    7216:	f7fe ffbb 	bl	6190 <tfp_printf>
    721a:	0020      	movs	r0, r4
    721c:	f7fe ffb8 	bl	6190 <tfp_printf>
    print(".mouse: "); print_dec(dc.mouse); print("\n");
    7220:	48aa      	ldr	r0, [pc, #680]	; (74cc <command_common+0x39c>)
    7222:	f7fe ffb5 	bl	6190 <tfp_printf>
    7226:	0731      	lsls	r1, r6, #28
    7228:	0fc9      	lsrs	r1, r1, #31
    722a:	0028      	movs	r0, r5
    722c:	f7fe ffb0 	bl	6190 <tfp_printf>
    7230:	0020      	movs	r0, r4
    7232:	f7fe ffad 	bl	6190 <tfp_printf>
    kc.raw = eeconfig_read_keymap();
    7236:	f7ff fba3 	bl	6980 <eeconfig_read_keymap>
    723a:	0006      	movs	r6, r0
    print("keymap_config.raw: "); print_hex8(kc.raw); print("\n");
    723c:	48a4      	ldr	r0, [pc, #656]	; (74d0 <command_common+0x3a0>)
    723e:	f7fe ffa7 	bl	6190 <tfp_printf>
    7242:	0031      	movs	r1, r6
    7244:	0038      	movs	r0, r7
    7246:	f7fe ffa3 	bl	6190 <tfp_printf>
    724a:	0020      	movs	r0, r4
    724c:	f7fe ffa0 	bl	6190 <tfp_printf>
    print(".swap_control_capslock: "); print_dec(kc.swap_control_capslock); print("\n");
    7250:	48a0      	ldr	r0, [pc, #640]	; (74d4 <command_common+0x3a4>)
    7252:	f7fe ff9d 	bl	6190 <tfp_printf>
    7256:	07f1      	lsls	r1, r6, #31
    7258:	0fc9      	lsrs	r1, r1, #31
    725a:	0028      	movs	r0, r5
    725c:	f7fe ff98 	bl	6190 <tfp_printf>
    7260:	0020      	movs	r0, r4
    7262:	f7fe ff95 	bl	6190 <tfp_printf>
    print(".capslock_to_control: "); print_dec(kc.capslock_to_control); print("\n");
    7266:	489c      	ldr	r0, [pc, #624]	; (74d8 <command_common+0x3a8>)
    7268:	f7fe ff92 	bl	6190 <tfp_printf>
    726c:	07b1      	lsls	r1, r6, #30
    726e:	0fc9      	lsrs	r1, r1, #31
    7270:	0028      	movs	r0, r5
    7272:	f7fe ff8d 	bl	6190 <tfp_printf>
    7276:	0020      	movs	r0, r4
    7278:	f7fe ff8a 	bl	6190 <tfp_printf>
    print(".swap_lalt_lgui: "); print_dec(kc.swap_lalt_lgui); print("\n");
    727c:	4897      	ldr	r0, [pc, #604]	; (74dc <command_common+0x3ac>)
    727e:	f7fe ff87 	bl	6190 <tfp_printf>
    7282:	0771      	lsls	r1, r6, #29
    7284:	0fc9      	lsrs	r1, r1, #31
    7286:	0028      	movs	r0, r5
    7288:	f7fe ff82 	bl	6190 <tfp_printf>
    728c:	0020      	movs	r0, r4
    728e:	f7fe ff7f 	bl	6190 <tfp_printf>
    print(".swap_ralt_rgui: "); print_dec(kc.swap_ralt_rgui); print("\n");
    7292:	4893      	ldr	r0, [pc, #588]	; (74e0 <command_common+0x3b0>)
    7294:	f7fe ff7c 	bl	6190 <tfp_printf>
    7298:	0731      	lsls	r1, r6, #28
    729a:	0fc9      	lsrs	r1, r1, #31
    729c:	0028      	movs	r0, r5
    729e:	f7fe ff77 	bl	6190 <tfp_printf>
    72a2:	0020      	movs	r0, r4
    72a4:	f7fe ff74 	bl	6190 <tfp_printf>
    print(".no_gui: "); print_dec(kc.no_gui); print("\n");
    72a8:	488e      	ldr	r0, [pc, #568]	; (74e4 <command_common+0x3b4>)
    72aa:	f7fe ff71 	bl	6190 <tfp_printf>
    72ae:	06f1      	lsls	r1, r6, #27
    72b0:	0fc9      	lsrs	r1, r1, #31
    72b2:	0028      	movs	r0, r5
    72b4:	f7fe ff6c 	bl	6190 <tfp_printf>
    72b8:	0020      	movs	r0, r4
    72ba:	f7fe ff69 	bl	6190 <tfp_printf>
    print(".swap_grave_esc: "); print_dec(kc.swap_grave_esc); print("\n");
    72be:	488a      	ldr	r0, [pc, #552]	; (74e8 <command_common+0x3b8>)
    72c0:	f7fe ff66 	bl	6190 <tfp_printf>
    72c4:	06b1      	lsls	r1, r6, #26
    72c6:	0fc9      	lsrs	r1, r1, #31
    72c8:	0028      	movs	r0, r5
    72ca:	f7fe ff61 	bl	6190 <tfp_printf>
    72ce:	0020      	movs	r0, r4
    72d0:	f7fe ff5e 	bl	6190 <tfp_printf>
    print(".swap_backslash_backspace: "); print_dec(kc.swap_backslash_backspace); print("\n");
    72d4:	4885      	ldr	r0, [pc, #532]	; (74ec <command_common+0x3bc>)
    72d6:	f7fe ff5b 	bl	6190 <tfp_printf>
    72da:	0671      	lsls	r1, r6, #25
    72dc:	0fc9      	lsrs	r1, r1, #31
    72de:	0028      	movs	r0, r5
    72e0:	f7fe ff56 	bl	6190 <tfp_printf>
    72e4:	0020      	movs	r0, r4
    72e6:	f7fe ff53 	bl	6190 <tfp_printf>
    print(".nkro: "); print_dec(kc.nkro); print("\n");
    72ea:	4881      	ldr	r0, [pc, #516]	; (74f0 <command_common+0x3c0>)
    72ec:	f7fe ff50 	bl	6190 <tfp_printf>
    72f0:	0631      	lsls	r1, r6, #24
    72f2:	0fc9      	lsrs	r1, r1, #31
    72f4:	0028      	movs	r0, r5
    72f6:	f7fe ff4b 	bl	6190 <tfp_printf>
    72fa:	0020      	movs	r0, r4
    72fc:	f7fe ff48 	bl	6190 <tfp_printf>
    return true;
    7300:	2401      	movs	r4, #1
    7302:	e72b      	b.n	715c <command_common+0x2c>
    print("\n\t- Magic -\n"
    7304:	487b      	ldr	r0, [pc, #492]	; (74f4 <command_common+0x3c4>)
    7306:	f7fe ff43 	bl	6190 <tfp_printf>
    return true;
    730a:	2401      	movs	r4, #1
    730c:	e726      	b.n	715c <command_common+0x2c>
            debug_keyboard = !debug_keyboard;
    730e:	2501      	movs	r5, #1
    7310:	2104      	movs	r1, #4
    7312:	4c60      	ldr	r4, [pc, #384]	; (7494 <command_common+0x364>)
    7314:	7822      	ldrb	r2, [r4, #0]
    7316:	0753      	lsls	r3, r2, #29
    7318:	0fdb      	lsrs	r3, r3, #31
    731a:	406b      	eors	r3, r5
    731c:	009b      	lsls	r3, r3, #2
    731e:	438a      	bics	r2, r1
    7320:	4313      	orrs	r3, r2
    7322:	7023      	strb	r3, [r4, #0]
            if (debug_keyboard) {
    7324:	4219      	tst	r1, r3
    7326:	d100      	bne.n	732a <command_common+0x1fa>
    7328:	e0a1      	b.n	746e <command_common+0x33e>
                print("\nkeyboard: on\n");
    732a:	4873      	ldr	r0, [pc, #460]	; (74f8 <command_common+0x3c8>)
    732c:	e05d      	b.n	73ea <command_common+0x2ba>
            debug_mouse = !debug_mouse;
    732e:	2501      	movs	r5, #1
    7330:	2108      	movs	r1, #8
    7332:	4c58      	ldr	r4, [pc, #352]	; (7494 <command_common+0x364>)
    7334:	7822      	ldrb	r2, [r4, #0]
    7336:	0713      	lsls	r3, r2, #28
    7338:	0fdb      	lsrs	r3, r3, #31
    733a:	406b      	eors	r3, r5
    733c:	00db      	lsls	r3, r3, #3
    733e:	438a      	bics	r2, r1
    7340:	4313      	orrs	r3, r2
    7342:	7023      	strb	r3, [r4, #0]
            if (debug_mouse) {
    7344:	4219      	tst	r1, r3
    7346:	d100      	bne.n	734a <command_common+0x21a>
    7348:	e08c      	b.n	7464 <command_common+0x334>
                print("\nmouse: on\n");
    734a:	486c      	ldr	r0, [pc, #432]	; (74fc <command_common+0x3cc>)
    734c:	e04d      	b.n	73ea <command_common+0x2ba>
            clear_keyboard(); //Prevents stuck keys.
    734e:	f7fd fcbf 	bl	4cd0 <clear_keyboard>
            keyboard_nkro = !keyboard_nkro;
    7352:	2201      	movs	r2, #1
    7354:	4b6a      	ldr	r3, [pc, #424]	; (7500 <command_common+0x3d0>)
    7356:	781c      	ldrb	r4, [r3, #0]
    7358:	4054      	eors	r4, r2
    735a:	701c      	strb	r4, [r3, #0]
            if (keyboard_nkro) {
    735c:	d07d      	beq.n	745a <command_common+0x32a>
                print("NKRO: on\n");
    735e:	4869      	ldr	r0, [pc, #420]	; (7504 <command_common+0x3d4>)
    7360:	f7fe ff16 	bl	6190 <tfp_printf>
    7364:	e6fa      	b.n	715c <command_common+0x2c>
            print("\n\t- Status -\n");
    7366:	4868      	ldr	r0, [pc, #416]	; (7508 <command_common+0x3d8>)
    7368:	f7fe ff12 	bl	6190 <tfp_printf>
            print_val_hex8(host_keyboard_leds());
    736c:	f7fd f818 	bl	43a0 <host_keyboard_leds>
    7370:	0001      	movs	r1, r0
    7372:	4866      	ldr	r0, [pc, #408]	; (750c <command_common+0x3dc>)
    7374:	f7fe ff0c 	bl	6190 <tfp_printf>
            print_val_hex8(keyboard_protocol);
    7378:	4b65      	ldr	r3, [pc, #404]	; (7510 <command_common+0x3e0>)
    737a:	4866      	ldr	r0, [pc, #408]	; (7514 <command_common+0x3e4>)
    737c:	7819      	ldrb	r1, [r3, #0]
    737e:	f7fe ff07 	bl	6190 <tfp_printf>
            print_val_hex8(keyboard_idle);
    7382:	4b65      	ldr	r3, [pc, #404]	; (7518 <command_common+0x3e8>)
    7384:	4865      	ldr	r0, [pc, #404]	; (751c <command_common+0x3ec>)
    7386:	7819      	ldrb	r1, [r3, #0]
    7388:	f7fe ff02 	bl	6190 <tfp_printf>
            print_val_hex8(keyboard_nkro);
    738c:	4b5c      	ldr	r3, [pc, #368]	; (7500 <command_common+0x3d0>)
    738e:	4864      	ldr	r0, [pc, #400]	; (7520 <command_common+0x3f0>)
    7390:	7819      	ldrb	r1, [r3, #0]
    7392:	f7fe fefd 	bl	6190 <tfp_printf>
            print_val_hex32(timer_read32());
    7396:	f7fe ff43 	bl	6220 <timer_read32>
    739a:	0001      	movs	r1, r0
    739c:	4861      	ldr	r0, [pc, #388]	; (7524 <command_common+0x3f4>)
    739e:	f7fe fef7 	bl	6190 <tfp_printf>
    return true;
    73a2:	2401      	movs	r4, #1
            break;
    73a4:	e6da      	b.n	715c <command_common+0x2c>
            print("\n\t- Version -\n");
    73a6:	4860      	ldr	r0, [pc, #384]	; (7528 <command_common+0x3f8>)
    73a8:	f7fe fef2 	bl	6190 <tfp_printf>
            print("DESC: " STR(DESCRIPTION) "\n");
    73ac:	485f      	ldr	r0, [pc, #380]	; (752c <command_common+0x3fc>)
    73ae:	f7fe feef 	bl	6190 <tfp_printf>
            print("VID: " STR(VENDOR_ID) "(" STR(MANUFACTURER) ") "
    73b2:	485f      	ldr	r0, [pc, #380]	; (7530 <command_common+0x400>)
    73b4:	f7fe feec 	bl	6190 <tfp_printf>
            print("BUILD: " STR(VERSION) " (" __TIME__ " " __DATE__ ")\n");
    73b8:	485e      	ldr	r0, [pc, #376]	; (7534 <command_common+0x404>)
    73ba:	f7fe fee9 	bl	6190 <tfp_printf>
            print("OPTIONS:"
    73be:	485e      	ldr	r0, [pc, #376]	; (7538 <command_common+0x408>)
    73c0:	f7fe fee6 	bl	6190 <tfp_printf>
            print("GCC: " STR(__GNUC__) "." STR(__GNUC_MINOR__) "." STR(__GNUC_PATCHLEVEL__)
    73c4:	485d      	ldr	r0, [pc, #372]	; (753c <command_common+0x40c>)
    73c6:	f7fe fee3 	bl	6190 <tfp_printf>
    return true;
    73ca:	2401      	movs	r4, #1
            break;
    73cc:	e6c6      	b.n	715c <command_common+0x2c>
            debug_matrix = !debug_matrix;
    73ce:	2501      	movs	r5, #1
    73d0:	2102      	movs	r1, #2
    73d2:	4c30      	ldr	r4, [pc, #192]	; (7494 <command_common+0x364>)
    73d4:	7822      	ldrb	r2, [r4, #0]
    73d6:	0793      	lsls	r3, r2, #30
    73d8:	0fdb      	lsrs	r3, r3, #31
    73da:	406b      	eors	r3, r5
    73dc:	005b      	lsls	r3, r3, #1
    73de:	438a      	bics	r2, r1
    73e0:	4313      	orrs	r3, r2
    73e2:	7023      	strb	r3, [r4, #0]
            if (debug_matrix) {
    73e4:	4219      	tst	r1, r3
    73e6:	d033      	beq.n	7450 <command_common+0x320>
                print("\nmatrix: on\n");
    73e8:	4855      	ldr	r0, [pc, #340]	; (7540 <command_common+0x410>)
                print("\nmouse: on\n");
    73ea:	f7fe fed1 	bl	6190 <tfp_printf>
                debug_enable = true;
    73ee:	7823      	ldrb	r3, [r4, #0]
    73f0:	431d      	orrs	r5, r3
    73f2:	7025      	strb	r5, [r4, #0]
    return true;
    73f4:	2401      	movs	r4, #1
    73f6:	e6b1      	b.n	715c <command_common+0x2c>
            print("Sleep LED test\n");
    73f8:	4852      	ldr	r0, [pc, #328]	; (7544 <command_common+0x414>)
    73fa:	f7fe fec9 	bl	6190 <tfp_printf>
            if (sleep_led_test) {
    73fe:	4c52      	ldr	r4, [pc, #328]	; (7548 <command_common+0x418>)
    7400:	7823      	ldrb	r3, [r4, #0]
    7402:	2b00      	cmp	r3, #0
    7404:	d11d      	bne.n	7442 <command_common+0x312>
                sleep_led_enable();
    7406:	f000 fa5b 	bl	78c0 <sleep_led_enable>
            sleep_led_test = !sleep_led_test;
    740a:	2201      	movs	r2, #1
    740c:	7823      	ldrb	r3, [r4, #0]
    740e:	4053      	eors	r3, r2
    7410:	7023      	strb	r3, [r4, #0]
    return true;
    7412:	2401      	movs	r4, #1
            break;
    7414:	e6a2      	b.n	715c <command_common+0x2c>
            switch_default_layer((code - KC_1) + 1);
    7416:	381d      	subs	r0, #29
    7418:	b2c0      	uxtb	r0, r0
    741a:	f7ff fe79 	bl	7110 <switch_default_layer>
    return true;
    741e:	2401      	movs	r4, #1
            break;
    7420:	e69c      	b.n	715c <command_common+0x2c>
            switch_default_layer(0);
    7422:	2000      	movs	r0, #0
    7424:	f7ff fe74 	bl	7110 <switch_default_layer>
    return true;
    7428:	2401      	movs	r4, #1
            break;
    742a:	e697      	b.n	715c <command_common+0x2c>
            switch_default_layer((code - KC_F1) + 1);
    742c:	3839      	subs	r0, #57	; 0x39
    742e:	b2c0      	uxtb	r0, r0
    7430:	f7ff fe6e 	bl	7110 <switch_default_layer>
    return true;
    7434:	2401      	movs	r4, #1
            break;
    7436:	e691      	b.n	715c <command_common+0x2c>
            print("?");
    7438:	4844      	ldr	r0, [pc, #272]	; (754c <command_common+0x41c>)
    743a:	f7fe fea9 	bl	6190 <tfp_printf>
            return false;
    743e:	2400      	movs	r4, #0
    7440:	e68c      	b.n	715c <command_common+0x2c>
                sleep_led_disable();
    7442:	f000 fa45 	bl	78d0 <sleep_led_disable>
                led_set(host_keyboard_leds());
    7446:	f7fc ffab 	bl	43a0 <host_keyboard_leds>
    744a:	f7fc ff89 	bl	4360 <led_set>
    744e:	e7dc      	b.n	740a <command_common+0x2da>
                print("\nmatrix: off\n");
    7450:	483f      	ldr	r0, [pc, #252]	; (7550 <command_common+0x420>)
    7452:	f7fe fe9d 	bl	6190 <tfp_printf>
    return true;
    7456:	2401      	movs	r4, #1
    7458:	e680      	b.n	715c <command_common+0x2c>
                print("NKRO: off\n");
    745a:	483e      	ldr	r0, [pc, #248]	; (7554 <command_common+0x424>)
    745c:	f7fe fe98 	bl	6190 <tfp_printf>
    return true;
    7460:	2401      	movs	r4, #1
    7462:	e67b      	b.n	715c <command_common+0x2c>
                print("\nmouse: off\n");
    7464:	483c      	ldr	r0, [pc, #240]	; (7558 <command_common+0x428>)
    7466:	f7fe fe93 	bl	6190 <tfp_printf>
    return true;
    746a:	2401      	movs	r4, #1
    746c:	e676      	b.n	715c <command_common+0x2c>
                print("\nkeyboard: off\n");
    746e:	483b      	ldr	r0, [pc, #236]	; (755c <command_common+0x42c>)
    7470:	f7fe fe8e 	bl	6190 <tfp_printf>
    return true;
    7474:	2401      	movs	r4, #1
    7476:	e671      	b.n	715c <command_common+0x2c>
                print("\ndebug: on\n");
    7478:	4839      	ldr	r0, [pc, #228]	; (7560 <command_common+0x430>)
    747a:	f7fe fe89 	bl	6190 <tfp_printf>
                debug_enable   = true;
    747e:	2201      	movs	r2, #1
    7480:	7823      	ldrb	r3, [r4, #0]
    7482:	4313      	orrs	r3, r2
    7484:	7023      	strb	r3, [r4, #0]
    return true;
    7486:	2401      	movs	r4, #1
    7488:	e668      	b.n	715c <command_common+0x2c>
    748a:	46c0      	nop			; (mov r8, r8)
    748c:	000089c8 	.word	0x000089c8
    7490:	00008ed0 	.word	0x00008ed0
    7494:	20000cb8 	.word	0x20000cb8
    7498:	00008ea4 	.word	0x00008ea4
    749c:	00008ecc 	.word	0x00008ecc
    74a0:	20000cd7 	.word	0x20000cd7
    74a4:	00008ee4 	.word	0x00008ee4
    74a8:	00008cd8 	.word	0x00008cd8
    74ac:	00008ce4 	.word	0x00008ce4
    74b0:	00008988 	.word	0x00008988
    74b4:	00009100 	.word	0x00009100
    74b8:	00008cf4 	.word	0x00008cf4
    74bc:	00008794 	.word	0x00008794
    74c0:	00008d08 	.word	0x00008d08
    74c4:	00008d14 	.word	0x00008d14
    74c8:	00008d20 	.word	0x00008d20
    74cc:	00008d2c 	.word	0x00008d2c
    74d0:	00008d38 	.word	0x00008d38
    74d4:	00008d4c 	.word	0x00008d4c
    74d8:	00008d68 	.word	0x00008d68
    74dc:	00008d80 	.word	0x00008d80
    74e0:	00008d94 	.word	0x00008d94
    74e4:	00008da8 	.word	0x00008da8
    74e8:	00008db4 	.word	0x00008db4
    74ec:	00008dc8 	.word	0x00008dc8
    74f0:	00008de4 	.word	0x00008de4
    74f4:	00008dec 	.word	0x00008dec
    74f8:	00008f20 	.word	0x00008f20
    74fc:	00008f40 	.word	0x00008f40
    7500:	1ffffe31 	.word	0x1ffffe31
    7504:	000090d4 	.word	0x000090d4
    7508:	00009050 	.word	0x00009050
    750c:	00009060 	.word	0x00009060
    7510:	1ffffe00 	.word	0x1ffffe00
    7514:	0000907c 	.word	0x0000907c
    7518:	20000bd0 	.word	0x20000bd0
    751c:	00009094 	.word	0x00009094
    7520:	000090a8 	.word	0x000090a8
    7524:	000090bc 	.word	0x000090bc
    7528:	00008f5c 	.word	0x00008f5c
    752c:	00008f6c 	.word	0x00008f6c
    7530:	00008f88 	.word	0x00008f88
    7534:	00008fc0 	.word	0x00008fc0
    7538:	00008ff0 	.word	0x00008ff0
    753c:	00009044 	.word	0x00009044
    7540:	00008f00 	.word	0x00008f00
    7544:	00008cc8 	.word	0x00008cc8
    7548:	20000cd9 	.word	0x20000cd9
    754c:	000090ec 	.word	0x000090ec
    7550:	00008f10 	.word	0x00008f10
    7554:	000090e0 	.word	0x000090e0
    7558:	00008f4c 	.word	0x00008f4c
    755c:	00008f30 	.word	0x00008f30
    7560:	00008ef4 	.word	0x00008ef4
	...

00007570 <command_extra>:
}
    7570:	2000      	movs	r0, #0
    7572:	4770      	bx	lr
	...

00007580 <command_console_extra>:
    7580:	2000      	movs	r0, #0
    7582:	4770      	bx	lr
	...

00007590 <command_proc>:
{
    7590:	b570      	push	{r4, r5, r6, lr}
    switch (command_state) {
    7592:	4d7e      	ldr	r5, [pc, #504]	; (778c <command_proc+0x1fc>)
{
    7594:	0006      	movs	r6, r0
    switch (command_state) {
    7596:	782b      	ldrb	r3, [r5, #0]
    7598:	2b01      	cmp	r3, #1
    759a:	d020      	beq.n	75de <command_proc+0x4e>
    759c:	2b00      	cmp	r3, #0
    759e:	d00f      	beq.n	75c0 <command_proc+0x30>
    75a0:	2b02      	cmp	r3, #2
    75a2:	d108      	bne.n	75b6 <command_proc+0x26>
    switch (code) {
    75a4:	1fc3      	subs	r3, r0, #7
    75a6:	b2db      	uxtb	r3, r3
    75a8:	2b4b      	cmp	r3, #75	; 0x4b
    75aa:	d900      	bls.n	75ae <command_proc+0x1e>
    75ac:	e0de      	b.n	776c <command_proc+0x1dc>
    75ae:	4a78      	ldr	r2, [pc, #480]	; (7790 <command_proc+0x200>)
    75b0:	009b      	lsls	r3, r3, #2
    75b2:	58d3      	ldr	r3, [r2, r3]
    75b4:	469f      	mov	pc, r3
            command_state = ONESHOT;
    75b6:	2300      	movs	r3, #0
            return false;
    75b8:	2400      	movs	r4, #0
            command_state = ONESHOT;
    75ba:	702b      	strb	r3, [r5, #0]
}
    75bc:	0020      	movs	r0, r4
    75be:	bd70      	pop	{r4, r5, r6, pc}
            if (!IS_COMMAND())
    75c0:	4b74      	ldr	r3, [pc, #464]	; (7794 <command_proc+0x204>)
                return false;
    75c2:	2400      	movs	r4, #0
            if (!IS_COMMAND())
    75c4:	681b      	ldr	r3, [r3, #0]
    75c6:	781b      	ldrb	r3, [r3, #0]
    75c8:	2b22      	cmp	r3, #34	; 0x22
    75ca:	d1f7      	bne.n	75bc <command_proc+0x2c>
            return (command_extra(code) || command_common(code));
    75cc:	f7ff ffd0 	bl	7570 <command_extra>
    75d0:	1e04      	subs	r4, r0, #0
    75d2:	d1f3      	bne.n	75bc <command_proc+0x2c>
                return (command_extra(code) || command_common(code));
    75d4:	0030      	movs	r0, r6
    75d6:	f7ff fdab 	bl	7130 <command_common>
    75da:	0004      	movs	r4, r0
    75dc:	e7ee      	b.n	75bc <command_proc+0x2c>
            if (IS_COMMAND())
    75de:	4b6d      	ldr	r3, [pc, #436]	; (7794 <command_proc+0x204>)
    75e0:	681b      	ldr	r3, [r3, #0]
    75e2:	781b      	ldrb	r3, [r3, #0]
    75e4:	2b22      	cmp	r3, #34	; 0x22
    75e6:	d00c      	beq.n	7602 <command_proc+0x72>
                return (command_console_extra(code) || command_console(code));
    75e8:	f7ff ffca 	bl	7580 <command_console_extra>
    75ec:	1e04      	subs	r4, r0, #0
    75ee:	d1e5      	bne.n	75bc <command_proc+0x2c>
    switch (code) {
    75f0:	3e0b      	subs	r6, #11
    75f2:	b2f6      	uxtb	r6, r6
    75f4:	2e2d      	cmp	r6, #45	; 0x2d
    75f6:	d900      	bls.n	75fa <command_proc+0x6a>
    75f8:	e0bd      	b.n	7776 <command_proc+0x1e6>
    75fa:	4b67      	ldr	r3, [pc, #412]	; (7798 <command_proc+0x208>)
    75fc:	00b6      	lsls	r6, r6, #2
    75fe:	599b      	ldr	r3, [r3, r6]
    7600:	469f      	mov	pc, r3
                return (command_extra(code) || command_common(code));
    7602:	f7ff ffb5 	bl	7570 <command_extra>
    7606:	1e04      	subs	r4, r0, #0
    7608:	d1d8      	bne.n	75bc <command_proc+0x2c>
    760a:	e7e3      	b.n	75d4 <command_proc+0x44>
            mousekey_param_inc(mousekey_param, 1);
    760c:	4c63      	ldr	r4, [pc, #396]	; (779c <command_proc+0x20c>)
    760e:	2101      	movs	r1, #1
    7610:	7820      	ldrb	r0, [r4, #0]
    7612:	f7ff fc7d 	bl	6f10 <mousekey_param_inc>
    7616:	7821      	ldrb	r1, [r4, #0]
    if (mousekey_param) {
    7618:	2900      	cmp	r1, #0
    761a:	d100      	bne.n	761e <command_proc+0x8e>
    761c:	e088      	b.n	7730 <command_proc+0x1a0>
        xprintf("M%d> ", mousekey_param);
    761e:	4860      	ldr	r0, [pc, #384]	; (77a0 <command_proc+0x210>)
    7620:	f7fe fdb6 	bl	6190 <tfp_printf>
    return true;
    7624:	2401      	movs	r4, #1
    7626:	e7c9      	b.n	75bc <command_proc+0x2c>
            mk_delay = MOUSEKEY_DELAY/10;
    7628:	221e      	movs	r2, #30
    762a:	4b5e      	ldr	r3, [pc, #376]	; (77a4 <command_proc+0x214>)
            print("set default\n");
    762c:	485e      	ldr	r0, [pc, #376]	; (77a8 <command_proc+0x218>)
            mk_delay = MOUSEKEY_DELAY/10;
    762e:	701a      	strb	r2, [r3, #0]
            mk_interval = MOUSEKEY_INTERVAL;
    7630:	4b5e      	ldr	r3, [pc, #376]	; (77ac <command_proc+0x21c>)
    7632:	3214      	adds	r2, #20
    7634:	701a      	strb	r2, [r3, #0]
            mk_max_speed = MOUSEKEY_MAX_SPEED;
    7636:	4b5e      	ldr	r3, [pc, #376]	; (77b0 <command_proc+0x220>)
    7638:	3a28      	subs	r2, #40	; 0x28
    763a:	701a      	strb	r2, [r3, #0]
            mk_time_to_max = MOUSEKEY_TIME_TO_MAX;
    763c:	4b5d      	ldr	r3, [pc, #372]	; (77b4 <command_proc+0x224>)
    763e:	320a      	adds	r2, #10
    7640:	701a      	strb	r2, [r3, #0]
            mk_wheel_max_speed = MOUSEKEY_WHEEL_MAX_SPEED;
    7642:	4b5d      	ldr	r3, [pc, #372]	; (77b8 <command_proc+0x228>)
    7644:	3a0c      	subs	r2, #12
    7646:	701a      	strb	r2, [r3, #0]
            mk_wheel_time_to_max = MOUSEKEY_WHEEL_TIME_TO_MAX;
    7648:	4b5c      	ldr	r3, [pc, #368]	; (77bc <command_proc+0x22c>)
    764a:	3220      	adds	r2, #32
    764c:	701a      	strb	r2, [r3, #0]
            print("set default\n");
    764e:	f7fe fd9f 	bl	6190 <tfp_printf>
    7652:	4b52      	ldr	r3, [pc, #328]	; (779c <command_proc+0x20c>)
    7654:	7819      	ldrb	r1, [r3, #0]
    7656:	e7df      	b.n	7618 <command_proc+0x88>
    7658:	4b59      	ldr	r3, [pc, #356]	; (77c0 <command_proc+0x230>)
    765a:	3e1e      	subs	r6, #30
    765c:	b2f6      	uxtb	r6, r6
    765e:	5d99      	ldrb	r1, [r3, r6]
            mousekey_param = numkey2num(code);
    7660:	4b4e      	ldr	r3, [pc, #312]	; (779c <command_proc+0x20c>)
    7662:	7019      	strb	r1, [r3, #0]
    7664:	e7d8      	b.n	7618 <command_proc+0x88>
            mousekey_param_inc(mousekey_param, 10);
    7666:	4c4d      	ldr	r4, [pc, #308]	; (779c <command_proc+0x20c>)
    7668:	210a      	movs	r1, #10
    766a:	7820      	ldrb	r0, [r4, #0]
    766c:	f7ff fc50 	bl	6f10 <mousekey_param_inc>
    7670:	7821      	ldrb	r1, [r4, #0]
    7672:	e7d1      	b.n	7618 <command_proc+0x88>
            mousekey_param_dec(mousekey_param, 10);
    7674:	4c49      	ldr	r4, [pc, #292]	; (779c <command_proc+0x20c>)
    7676:	210a      	movs	r1, #10
    7678:	7820      	ldrb	r0, [r4, #0]
    767a:	f7ff fcc9 	bl	7010 <mousekey_param_dec>
    767e:	7821      	ldrb	r1, [r4, #0]
    7680:	e7ca      	b.n	7618 <command_proc+0x88>
            mousekey_param_dec(mousekey_param, 1);
    7682:	4c46      	ldr	r4, [pc, #280]	; (779c <command_proc+0x20c>)
    7684:	2101      	movs	r1, #1
    7686:	7820      	ldrb	r0, [r4, #0]
    7688:	f7ff fcc2 	bl	7010 <mousekey_param_dec>
    768c:	7821      	ldrb	r1, [r4, #0]
    768e:	e7c3      	b.n	7618 <command_proc+0x88>
    print("\n\t- Values -\n");
    7690:	484c      	ldr	r0, [pc, #304]	; (77c4 <command_proc+0x234>)
    7692:	f7fe fd7d 	bl	6190 <tfp_printf>
    print("1: delay(*10ms): "); pdec(mk_delay); print("\n");
    7696:	484c      	ldr	r0, [pc, #304]	; (77c8 <command_proc+0x238>)
    7698:	f7fe fd7a 	bl	6190 <tfp_printf>
    769c:	4d4b      	ldr	r5, [pc, #300]	; (77cc <command_proc+0x23c>)
    769e:	4b41      	ldr	r3, [pc, #260]	; (77a4 <command_proc+0x214>)
    76a0:	0028      	movs	r0, r5
    76a2:	7819      	ldrb	r1, [r3, #0]
    76a4:	f7fe fd74 	bl	6190 <tfp_printf>
    76a8:	4c49      	ldr	r4, [pc, #292]	; (77d0 <command_proc+0x240>)
    76aa:	0020      	movs	r0, r4
    76ac:	f7fe fd70 	bl	6190 <tfp_printf>
    print("2: interval(ms): "); pdec(mk_interval); print("\n");
    76b0:	4848      	ldr	r0, [pc, #288]	; (77d4 <command_proc+0x244>)
    76b2:	f7fe fd6d 	bl	6190 <tfp_printf>
    76b6:	4b3d      	ldr	r3, [pc, #244]	; (77ac <command_proc+0x21c>)
    76b8:	0028      	movs	r0, r5
    76ba:	7819      	ldrb	r1, [r3, #0]
    76bc:	f7fe fd68 	bl	6190 <tfp_printf>
    76c0:	0020      	movs	r0, r4
    76c2:	f7fe fd65 	bl	6190 <tfp_printf>
    print("3: max_speed: "); pdec(mk_max_speed); print("\n");
    76c6:	4844      	ldr	r0, [pc, #272]	; (77d8 <command_proc+0x248>)
    76c8:	f7fe fd62 	bl	6190 <tfp_printf>
    76cc:	4b38      	ldr	r3, [pc, #224]	; (77b0 <command_proc+0x220>)
    76ce:	0028      	movs	r0, r5
    76d0:	7819      	ldrb	r1, [r3, #0]
    76d2:	f7fe fd5d 	bl	6190 <tfp_printf>
    76d6:	0020      	movs	r0, r4
    76d8:	f7fe fd5a 	bl	6190 <tfp_printf>
    print("4: time_to_max: "); pdec(mk_time_to_max); print("\n");
    76dc:	483f      	ldr	r0, [pc, #252]	; (77dc <command_proc+0x24c>)
    76de:	f7fe fd57 	bl	6190 <tfp_printf>
    76e2:	4b34      	ldr	r3, [pc, #208]	; (77b4 <command_proc+0x224>)
    76e4:	0028      	movs	r0, r5
    76e6:	7819      	ldrb	r1, [r3, #0]
    76e8:	f7fe fd52 	bl	6190 <tfp_printf>
    76ec:	0020      	movs	r0, r4
    76ee:	f7fe fd4f 	bl	6190 <tfp_printf>
    print("5: wheel_max_speed: "); pdec(mk_wheel_max_speed); print("\n");
    76f2:	483b      	ldr	r0, [pc, #236]	; (77e0 <command_proc+0x250>)
    76f4:	f7fe fd4c 	bl	6190 <tfp_printf>
    76f8:	4b2f      	ldr	r3, [pc, #188]	; (77b8 <command_proc+0x228>)
    76fa:	0028      	movs	r0, r5
    76fc:	7819      	ldrb	r1, [r3, #0]
    76fe:	f7fe fd47 	bl	6190 <tfp_printf>
    7702:	0020      	movs	r0, r4
    7704:	f7fe fd44 	bl	6190 <tfp_printf>
    print("6: wheel_time_to_max: "); pdec(mk_wheel_time_to_max); print("\n");
    7708:	4836      	ldr	r0, [pc, #216]	; (77e4 <command_proc+0x254>)
    770a:	f7fe fd41 	bl	6190 <tfp_printf>
    770e:	4b2b      	ldr	r3, [pc, #172]	; (77bc <command_proc+0x22c>)
    7710:	0028      	movs	r0, r5
    7712:	7819      	ldrb	r1, [r3, #0]
    7714:	f7fe fd3c 	bl	6190 <tfp_printf>
    7718:	0020      	movs	r0, r4
    771a:	f7fe fd39 	bl	6190 <tfp_printf>
    771e:	4b1f      	ldr	r3, [pc, #124]	; (779c <command_proc+0x20c>)
    7720:	7819      	ldrb	r1, [r3, #0]
    7722:	e779      	b.n	7618 <command_proc+0x88>
            if (mousekey_param) {
    7724:	4b1d      	ldr	r3, [pc, #116]	; (779c <command_proc+0x20c>)
    7726:	781a      	ldrb	r2, [r3, #0]
    7728:	2a00      	cmp	r2, #0
    772a:	d028      	beq.n	777e <command_proc+0x1ee>
                mousekey_param = 0;
    772c:	2200      	movs	r2, #0
    772e:	701a      	strb	r2, [r3, #0]
        print("M>" );
    7730:	482d      	ldr	r0, [pc, #180]	; (77e8 <command_proc+0x258>)
    7732:	f7fe fd2d 	bl	6190 <tfp_printf>
    return true;
    7736:	2401      	movs	r4, #1
    7738:	e740      	b.n	75bc <command_proc+0x2c>
            mousekey_console_help();
    773a:	f7ff fbd9 	bl	6ef0 <mousekey_console_help>
    773e:	4b17      	ldr	r3, [pc, #92]	; (779c <command_proc+0x20c>)
    7740:	7819      	ldrb	r1, [r3, #0]
    7742:	e769      	b.n	7618 <command_proc+0x88>
            command_state = ONESHOT;
    7744:	2300      	movs	r3, #0
    7746:	702b      	strb	r3, [r5, #0]
    7748:	e738      	b.n	75bc <command_proc+0x2c>
            mousekey_console_help();
    774a:	f7ff fbd1 	bl	6ef0 <mousekey_console_help>
            print("M> ");
    774e:	4827      	ldr	r0, [pc, #156]	; (77ec <command_proc+0x25c>)
    7750:	f7fe fd1e 	bl	6190 <tfp_printf>
            command_state = MOUSEKEY;
    7754:	2302      	movs	r3, #2
    7756:	2401      	movs	r4, #1
    7758:	702b      	strb	r3, [r5, #0]
    775a:	e72f      	b.n	75bc <command_proc+0x2c>
    print("\n\t- Console -\n"
    775c:	4824      	ldr	r0, [pc, #144]	; (77f0 <command_proc+0x260>)
    775e:	f7fe fd17 	bl	6190 <tfp_printf>
    print("C> ");
    7762:	4824      	ldr	r0, [pc, #144]	; (77f4 <command_proc+0x264>)
    7764:	f7fe fd14 	bl	6190 <tfp_printf>
    7768:	2401      	movs	r4, #1
    776a:	e727      	b.n	75bc <command_proc+0x2c>
            print("?");
    776c:	4822      	ldr	r0, [pc, #136]	; (77f8 <command_proc+0x268>)
    776e:	f7fe fd0f 	bl	6190 <tfp_printf>
    return true;
    7772:	2401      	movs	r4, #1
    7774:	e722      	b.n	75bc <command_proc+0x2c>
            print("?");
    7776:	4820      	ldr	r0, [pc, #128]	; (77f8 <command_proc+0x268>)
    7778:	f7fe fd0a 	bl	6190 <tfp_printf>
                return (command_console_extra(code) || command_console(code));
    777c:	e71e      	b.n	75bc <command_proc+0x2c>
                print("C> ");
    777e:	481d      	ldr	r0, [pc, #116]	; (77f4 <command_proc+0x264>)
    7780:	f7fe fd06 	bl	6190 <tfp_printf>
                command_state = CONSOLE;
    7784:	2301      	movs	r3, #1
    return true;
    7786:	2401      	movs	r4, #1
                command_state = CONSOLE;
    7788:	702b      	strb	r3, [r5, #0]
    778a:	e717      	b.n	75bc <command_proc+0x2c>
    778c:	20000cd7 	.word	0x20000cd7
    7790:	00008ad4 	.word	0x00008ad4
    7794:	1ffffe34 	.word	0x1ffffe34
    7798:	00008c04 	.word	0x00008c04
    779c:	20000cd8 	.word	0x20000cd8
    77a0:	00009190 	.word	0x00009190
    77a4:	1ffffe38 	.word	0x1ffffe38
    77a8:	00009180 	.word	0x00009180
    77ac:	1ffffe39 	.word	0x1ffffe39
    77b0:	1ffffe3a 	.word	0x1ffffe3a
    77b4:	1ffffe3b 	.word	0x1ffffe3b
    77b8:	1ffffe3c 	.word	0x1ffffe3c
    77bc:	1ffffe3d 	.word	0x1ffffe3d
    77c0:	00008cbc 	.word	0x00008cbc
    77c4:	000090f4 	.word	0x000090f4
    77c8:	00009104 	.word	0x00009104
    77cc:	00008988 	.word	0x00008988
    77d0:	00009100 	.word	0x00009100
    77d4:	00009118 	.word	0x00009118
    77d8:	0000912c 	.word	0x0000912c
    77dc:	0000913c 	.word	0x0000913c
    77e0:	00009150 	.word	0x00009150
    77e4:	00009168 	.word	0x00009168
    77e8:	00009198 	.word	0x00009198
    77ec:	000090f0 	.word	0x000090f0
    77f0:	00008ea4 	.word	0x00008ea4
    77f4:	00008ecc 	.word	0x00008ecc
    77f8:	000090ec 	.word	0x000090ec
    77fc:	00000000 	.word	0x00000000

00007800 <VectorB0>:
255, 252, 245, 233, 218, 199, 179, 157, 135, 113, 93, 74, 58, 44, 32, 23,
15, 10, 6, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* interrupt handler */
OSAL_IRQ_HANDLER(TIMER_INTERRUPT_VECTOR) {
    7800:	b570      	push	{r4, r5, r6, lr}
    OSAL_IRQ_PROLOGUE();
    7802:	4675      	mov	r5, lr
    7804:	f7f9 fc4c 	bl	10a0 <_dbg_check_enter_isr>
      uint8_t duration:2;
      uint8_t index:6;
    } pwm;
    } timer = { .row = 0 };

    timer.row++;
    7808:	4c13      	ldr	r4, [pc, #76]	; (7858 <VectorB0+0x58>)
    780a:	8823      	ldrh	r3, [r4, #0]
    780c:	3301      	adds	r3, #1
    780e:	b29b      	uxth	r3, r3
    7810:	8023      	strh	r3, [r4, #0]
    7812:	b2db      	uxtb	r3, r3

    // LED on
    if (timer.pwm.count == 0) {
    7814:	2b00      	cmp	r3, #0
    7816:	d010      	beq.n	783a <VectorB0+0x3a>
        led_set(1<<USB_LED_CAPS_LOCK);
    }
    // LED off
    if (timer.pwm.count == breathing_table[timer.pwm.index]) {
    7818:	7862      	ldrb	r2, [r4, #1]
    781a:	4910      	ldr	r1, [pc, #64]	; (785c <VectorB0+0x5c>)
    781c:	0892      	lsrs	r2, r2, #2
    781e:	5c8a      	ldrb	r2, [r1, r2]
    7820:	429a      	cmp	r2, r3
    7822:	d014      	beq.n	784e <VectorB0+0x4e>
        led_set(0);
    }

    /* Reset the counter */
    RESET_COUNTER;
    7824:	2180      	movs	r1, #128	; 0x80
    7826:	4a0e      	ldr	r2, [pc, #56]	; (7860 <VectorB0+0x60>)
    7828:	6813      	ldr	r3, [r2, #0]
    782a:	430b      	orrs	r3, r1
    782c:	6013      	str	r3, [r2, #0]

    OSAL_IRQ_EPILOGUE();
    782e:	f7f9 fc4f 	bl	10d0 <_dbg_check_leave_isr>
    7832:	0028      	movs	r0, r5
    7834:	f7fa fb0c 	bl	1e50 <_port_irq_epilogue>
}
    7838:	bd70      	pop	{r4, r5, r6, pc}
        led_set(1<<USB_LED_CAPS_LOCK);
    783a:	2002      	movs	r0, #2
    783c:	f7fc fd90 	bl	4360 <led_set>
    if (timer.pwm.count == breathing_table[timer.pwm.index]) {
    7840:	7862      	ldrb	r2, [r4, #1]
    7842:	4906      	ldr	r1, [pc, #24]	; (785c <VectorB0+0x5c>)
    7844:	0892      	lsrs	r2, r2, #2
    7846:	7823      	ldrb	r3, [r4, #0]
    7848:	5c8a      	ldrb	r2, [r1, r2]
    784a:	429a      	cmp	r2, r3
    784c:	d1ea      	bne.n	7824 <VectorB0+0x24>
        led_set(0);
    784e:	2000      	movs	r0, #0
    7850:	f7fc fd86 	bl	4360 <led_set>
    7854:	e7e6      	b.n	7824 <VectorB0+0x24>
    7856:	46c0      	nop			; (mov r8, r8)
    7858:	20000cdc 	.word	0x20000cdc
    785c:	00009378 	.word	0x00009378
    7860:	40040000 	.word	0x40040000
	...

00007870 <sleep_led_init>:
#endif

/* Initialise the timer */
void sleep_led_init(void) {
    /* Make sure the clock to the LPTMR is enabled */
    SIM->SCGC5 |= SIM_SCGC5_LPTMR;
    7870:	2001      	movs	r0, #1
    7872:	490f      	ldr	r1, [pc, #60]	; (78b0 <sleep_led_init+0x40>)
    7874:	4a0f      	ldr	r2, [pc, #60]	; (78b4 <sleep_led_init+0x44>)
void sleep_led_init(void) {
    7876:	b510      	push	{r4, lr}
    SIM->SCGC5 |= SIM_SCGC5_LPTMR;
    7878:	588b      	ldr	r3, [r1, r2]
    /* Reset LPTMR settings */
    LPTMR0->CSR = 0;
    787a:	4c0f      	ldr	r4, [pc, #60]	; (78b8 <sleep_led_init+0x48>)
    SIM->SCGC5 |= SIM_SCGC5_LPTMR;
    787c:	4303      	orrs	r3, r0
    787e:	508b      	str	r3, [r1, r2]
    LPTMR0->CSR = 0;
    7880:	2300      	movs	r3, #0
    #endif /* OPTION 1 */

    /* === OPTION 2 === */
    #if 1
    //  nMHz IRC (n=4 on KL25Z, KL26Z and K20x; n=2 or 8 on KL27Z)
    MCG->C2 |= MCG_C2_IRCS; // fast (4MHz) internal ref clock
    7882:	2101      	movs	r1, #1
    LPTMR0->CSR = 0;
    7884:	6023      	str	r3, [r4, #0]
    LPTMR0->CMR = 0;  // trigger on counter value (i.e. every time)
    7886:	60a3      	str	r3, [r4, #8]
    MCG->C2 |= MCG_C2_IRCS; // fast (4MHz) internal ref clock
    7888:	4b0c      	ldr	r3, [pc, #48]	; (78bc <sleep_led_init+0x4c>)
    LPTMR0->PSR = LPTMRx_PSR_PCS(LPTMR_CLOCK_OSCERCLK)|LPTMRx_PSR_PRESCALE(7);
    #endif /* OPTION 3 */
    /* === END OPTIONS === */

    /* Interrupt on TCF set (compare flag) */
    nvicEnableVector(LPTMR0_IRQn, 2); // vector, priority
    788a:	301b      	adds	r0, #27
    MCG->C2 |= MCG_C2_IRCS; // fast (4MHz) internal ref clock
    788c:	785a      	ldrb	r2, [r3, #1]
    788e:	430a      	orrs	r2, r1
    MCG->C1 |= MCG_C1_IRCLKEN; // enable internal ref clock
    7890:	2102      	movs	r1, #2
    MCG->C2 |= MCG_C2_IRCS; // fast (4MHz) internal ref clock
    7892:	705a      	strb	r2, [r3, #1]
    MCG->C1 |= MCG_C1_IRCLKEN; // enable internal ref clock
    7894:	781a      	ldrb	r2, [r3, #0]
    7896:	430a      	orrs	r2, r1
    7898:	701a      	strb	r2, [r3, #0]
    LPTMR0->PSR = LPTMRx_PSR_PCS(LPTMR_CLOCK_MCGIRCLK)|LPTMRx_PSR_PRESCALE(6);
    789a:	2330      	movs	r3, #48	; 0x30
    nvicEnableVector(LPTMR0_IRQn, 2); // vector, priority
    789c:	2102      	movs	r1, #2
    LPTMR0->PSR = LPTMRx_PSR_PCS(LPTMR_CLOCK_MCGIRCLK)|LPTMRx_PSR_PRESCALE(6);
    789e:	6063      	str	r3, [r4, #4]
    nvicEnableVector(LPTMR0_IRQn, 2); // vector, priority
    78a0:	f7fb f866 	bl	2970 <nvicEnableVector>
    LPTMR0->CSR |= LPTMRx_CSR_TIE;
    78a4:	2240      	movs	r2, #64	; 0x40
    78a6:	6823      	ldr	r3, [r4, #0]
    78a8:	4313      	orrs	r3, r2
    78aa:	6023      	str	r3, [r4, #0]
}
    78ac:	bd10      	pop	{r4, pc}
    78ae:	46c0      	nop			; (mov r8, r8)
    78b0:	40047000 	.word	0x40047000
    78b4:	00001038 	.word	0x00001038
    78b8:	40040000 	.word	0x40040000
    78bc:	40064000 	.word	0x40064000

000078c0 <sleep_led_enable>:

void sleep_led_enable(void) {
    /* Enable the timer */
    LPTMR0->CSR |= LPTMRx_CSR_TEN;
    78c0:	2101      	movs	r1, #1
    78c2:	4a02      	ldr	r2, [pc, #8]	; (78cc <sleep_led_enable+0xc>)
    78c4:	6813      	ldr	r3, [r2, #0]
    78c6:	430b      	orrs	r3, r1
    78c8:	6013      	str	r3, [r2, #0]
}
    78ca:	4770      	bx	lr
    78cc:	40040000 	.word	0x40040000

000078d0 <sleep_led_disable>:

void sleep_led_disable(void) {
    /* Disable the timer */
    LPTMR0->CSR &= ~LPTMRx_CSR_TEN;
    78d0:	2101      	movs	r1, #1
    78d2:	4a02      	ldr	r2, [pc, #8]	; (78dc <sleep_led_disable+0xc>)
    78d4:	6813      	ldr	r3, [r2, #0]
    78d6:	438b      	bics	r3, r1
    78d8:	6013      	str	r3, [r2, #0]
}
    78da:	4770      	bx	lr
    78dc:	40040000 	.word	0x40040000

000078e0 <memcpy>:
    78e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    78e2:	2a0f      	cmp	r2, #15
    78e4:	d937      	bls.n	7956 <memcpy+0x76>
    78e6:	000d      	movs	r5, r1
    78e8:	4305      	orrs	r5, r0
    78ea:	000c      	movs	r4, r1
    78ec:	0003      	movs	r3, r0
    78ee:	07ad      	lsls	r5, r5, #30
    78f0:	d135      	bne.n	795e <memcpy+0x7e>
    78f2:	0015      	movs	r5, r2
    78f4:	3d10      	subs	r5, #16
    78f6:	092d      	lsrs	r5, r5, #4
    78f8:	012e      	lsls	r6, r5, #4
    78fa:	1836      	adds	r6, r6, r0
    78fc:	3610      	adds	r6, #16
    78fe:	6827      	ldr	r7, [r4, #0]
    7900:	601f      	str	r7, [r3, #0]
    7902:	6867      	ldr	r7, [r4, #4]
    7904:	605f      	str	r7, [r3, #4]
    7906:	68a7      	ldr	r7, [r4, #8]
    7908:	609f      	str	r7, [r3, #8]
    790a:	68e7      	ldr	r7, [r4, #12]
    790c:	3410      	adds	r4, #16
    790e:	60df      	str	r7, [r3, #12]
    7910:	3310      	adds	r3, #16
    7912:	42b3      	cmp	r3, r6
    7914:	d1f3      	bne.n	78fe <memcpy+0x1e>
    7916:	240f      	movs	r4, #15
    7918:	3501      	adds	r5, #1
    791a:	012d      	lsls	r5, r5, #4
    791c:	1949      	adds	r1, r1, r5
    791e:	4014      	ands	r4, r2
    7920:	1945      	adds	r5, r0, r5
    7922:	2c03      	cmp	r4, #3
    7924:	d91d      	bls.n	7962 <memcpy+0x82>
    7926:	2300      	movs	r3, #0
    7928:	58ce      	ldr	r6, [r1, r3]
    792a:	50ee      	str	r6, [r5, r3]
    792c:	3304      	adds	r3, #4
    792e:	1ae6      	subs	r6, r4, r3
    7930:	2e03      	cmp	r6, #3
    7932:	d8f9      	bhi.n	7928 <memcpy+0x48>
    7934:	2303      	movs	r3, #3
    7936:	3c04      	subs	r4, #4
    7938:	08a4      	lsrs	r4, r4, #2
    793a:	3401      	adds	r4, #1
    793c:	00a4      	lsls	r4, r4, #2
    793e:	401a      	ands	r2, r3
    7940:	192d      	adds	r5, r5, r4
    7942:	1909      	adds	r1, r1, r4
    7944:	2a00      	cmp	r2, #0
    7946:	d005      	beq.n	7954 <memcpy+0x74>
    7948:	2300      	movs	r3, #0
    794a:	5ccc      	ldrb	r4, [r1, r3]
    794c:	54ec      	strb	r4, [r5, r3]
    794e:	3301      	adds	r3, #1
    7950:	4293      	cmp	r3, r2
    7952:	d1fa      	bne.n	794a <memcpy+0x6a>
    7954:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7956:	0005      	movs	r5, r0
    7958:	2a00      	cmp	r2, #0
    795a:	d1f5      	bne.n	7948 <memcpy+0x68>
    795c:	e7fa      	b.n	7954 <memcpy+0x74>
    795e:	0005      	movs	r5, r0
    7960:	e7f2      	b.n	7948 <memcpy+0x68>
    7962:	0022      	movs	r2, r4
    7964:	e7f8      	b.n	7958 <memcpy+0x78>
    7966:	46c0      	nop			; (mov r8, r8)

00007968 <memset>:
    7968:	b5f0      	push	{r4, r5, r6, r7, lr}
    796a:	0783      	lsls	r3, r0, #30
    796c:	d046      	beq.n	79fc <memset+0x94>
    796e:	1e54      	subs	r4, r2, #1
    7970:	2a00      	cmp	r2, #0
    7972:	d042      	beq.n	79fa <memset+0x92>
    7974:	b2ce      	uxtb	r6, r1
    7976:	0002      	movs	r2, r0
    7978:	2503      	movs	r5, #3
    797a:	e002      	b.n	7982 <memset+0x1a>
    797c:	001a      	movs	r2, r3
    797e:	3c01      	subs	r4, #1
    7980:	d33b      	bcc.n	79fa <memset+0x92>
    7982:	1c53      	adds	r3, r2, #1
    7984:	7016      	strb	r6, [r2, #0]
    7986:	422b      	tst	r3, r5
    7988:	d1f8      	bne.n	797c <memset+0x14>
    798a:	2c03      	cmp	r4, #3
    798c:	d92d      	bls.n	79ea <memset+0x82>
    798e:	22ff      	movs	r2, #255	; 0xff
    7990:	400a      	ands	r2, r1
    7992:	0215      	lsls	r5, r2, #8
    7994:	4315      	orrs	r5, r2
    7996:	042a      	lsls	r2, r5, #16
    7998:	4315      	orrs	r5, r2
    799a:	2c0f      	cmp	r4, #15
    799c:	d916      	bls.n	79cc <memset+0x64>
    799e:	0027      	movs	r7, r4
    79a0:	3f10      	subs	r7, #16
    79a2:	093f      	lsrs	r7, r7, #4
    79a4:	013e      	lsls	r6, r7, #4
    79a6:	46b4      	mov	ip, r6
    79a8:	001e      	movs	r6, r3
    79aa:	001a      	movs	r2, r3
    79ac:	3610      	adds	r6, #16
    79ae:	4466      	add	r6, ip
    79b0:	6015      	str	r5, [r2, #0]
    79b2:	6055      	str	r5, [r2, #4]
    79b4:	6095      	str	r5, [r2, #8]
    79b6:	60d5      	str	r5, [r2, #12]
    79b8:	3210      	adds	r2, #16
    79ba:	42b2      	cmp	r2, r6
    79bc:	d1f8      	bne.n	79b0 <memset+0x48>
    79be:	220f      	movs	r2, #15
    79c0:	3701      	adds	r7, #1
    79c2:	013f      	lsls	r7, r7, #4
    79c4:	19db      	adds	r3, r3, r7
    79c6:	4014      	ands	r4, r2
    79c8:	2c03      	cmp	r4, #3
    79ca:	d90e      	bls.n	79ea <memset+0x82>
    79cc:	1f26      	subs	r6, r4, #4
    79ce:	08b6      	lsrs	r6, r6, #2
    79d0:	00b7      	lsls	r7, r6, #2
    79d2:	46bc      	mov	ip, r7
    79d4:	001a      	movs	r2, r3
    79d6:	1d1f      	adds	r7, r3, #4
    79d8:	4467      	add	r7, ip
    79da:	c220      	stmia	r2!, {r5}
    79dc:	42ba      	cmp	r2, r7
    79de:	d1fc      	bne.n	79da <memset+0x72>
    79e0:	2203      	movs	r2, #3
    79e2:	3601      	adds	r6, #1
    79e4:	00b6      	lsls	r6, r6, #2
    79e6:	199b      	adds	r3, r3, r6
    79e8:	4014      	ands	r4, r2
    79ea:	2c00      	cmp	r4, #0
    79ec:	d005      	beq.n	79fa <memset+0x92>
    79ee:	b2c9      	uxtb	r1, r1
    79f0:	191c      	adds	r4, r3, r4
    79f2:	7019      	strb	r1, [r3, #0]
    79f4:	3301      	adds	r3, #1
    79f6:	429c      	cmp	r4, r3
    79f8:	d1fb      	bne.n	79f2 <memset+0x8a>
    79fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    79fc:	0014      	movs	r4, r2
    79fe:	0003      	movs	r3, r0
    7a00:	e7c3      	b.n	798a <memset+0x22>
    7a02:	46c0      	nop			; (mov r8, r8)
